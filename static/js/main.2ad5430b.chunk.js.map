{"version":3,"sources":["algorithms/plain/breadth-first-search.js","components/PlainGraph/PlainGraph.jsx","components/Graph/Vertex/Vertex.jsx","components/Graph/Edge/Edge.jsx","utils/sleep.js","actions/index.js","actions/dialog.js","algorithms/graph/index.js","utils/graphConverter.js","actions/algorithm.js","components/Graph/VisualizationEdge/VisualizationEdge.jsx","components/Graph/Graph.jsx","components/Buttons/Buttons.jsx","components/Sliders/Sliders.jsx","components/DropDownLists/DropDownLists.jsx","components/ToggleSwitches/ToggleSwitches.jsx","utils/sizeof.js","algorithms/graph/dfs.js","utils/queue.js","algorithms/graph/bfs.js","algorithms/graph/dijkstra.js","algorithms/graph/prim-mst.js","utils/dsu.js","algorithms/graph/kruskal-mst.js","algorithms/graph/check-connected.js","algorithms/graph/check-bipartite.js","algorithms/graph/radius.js","algorithms/graph/diameter.js","algorithms/graph/topological-sort.js","algorithms/graph/find-bridges.js","algorithms/graph/find-articulation-points.js","algorithms/graph/scc-kosaraju.js","algorithms/graph/euler-path.js","algorithms/graph/euler-cycle.js","actions/matrixDialog.js","components/Menu/Menu.jsx","components/MessageBox/MessageBox.jsx","components/TextInputs/TextInputs.jsx","components/Dialogs/InputDialog/InputDialog.jsx","components/InfoBox/InfoBox.jsx","components/Dialogs/MatrixDialog/AdjacencyMatrix.jsx","components/Dialogs/MatrixDialog/MatrixDialog.jsx","components/App.jsx","serviceWorker.js","reducers/dialog.js","reducers/algorithm.js","reducers/matrixDialog.js","reducers/index.js","index.js","components/App.module.scss","components/PlainGraph/PlainGraph.module.scss","components/Menu/Menu.module.scss","components/Buttons/Buttons.module.scss","components/Sliders/Sliders.module.scss","components/DropDownLists/DropDownLists.module.scss","components/ToggleSwitches/ToggleSwitches.module.scss","components/MessageBox/MessageBox.module.scss","components/Dialogs/InputDialog/InputDialog.module.scss","components/TextInputs/TextInputs.module.scss","components/InfoBox/InfoBox.module.scss","components/Dialogs/MatrixDialog/MatrixDialog.module.scss","components/Dialogs/MatrixDialog/AdjacencyMatrix.module.scss"],"names":["algorithm","cells","cellStart","cellFinish","pathStatus","queue","x","y","parent","current","shift","console","log","next","node","minX","minY","maxX","maxY","res","push","neighbours","length","i","findIndex","n","cx","classnames","bind","styles","CellState","Object","freeze","EMPTY","BLOCKED","START","FINISH","PATH","Cell","status","onMouseEnter","onMouseLeave","className","React","Component","Vertex","radius","name","this","state","VertexState","DEFAULT","hint","hintState","VertexHintState","CLEAR","HIGHLIGHTED","PRE_COMPLETED","COMPLETED","COLOR_1","COLOR_2","VertexComponent","vertex","draggable","onDragStart","onDragEnd","onDragMove","onClick","e","call","target","getChildren","setAttrs","scaleX","scaleY","shadowColor","shadowBlur","shadowOffset","shadowOpacity","moveToTop","handleDragStart","to","duration","shadowOffsetX","shadowOffsetY","handleDragEnd","fill","color","stroke","strokeWidth","vertexBorderWidth","text","fontSize","textColor","width","height","align","verticalAlign","hintColor","labelWidth","Edge","vertexFrom","vertexTo","oriented","weight","_from","_to","EdgeState","_oriented","undefined","FLIPPED","WALKED","ERASED","SHADOWED","EdgeComponent","edgeComponent","edge","edgeType","points","getEdgePointsForType","EdgeType","NOT_ORIENTED","linePoints","hitStrokeWidth","tension","isWeighted","labelPoints","EdgeLabel","labelRadius","labelBorderWidth","ONE_SIDE_ORIENTED","TWO_SIDE_ORIENTED","LOOP","from","isFlipped","dx","dy","angle","Math","atan2","vertexFromOffset","vertexToOffset","xFrom","cos","yFrom","sin","xTo","yTo","xMiddle","yMiddle","anchorDx","sqrt","anchorDy","xMiddleFirst","sleep","ms","Promise","resolve","setTimeout","ActionType","ADD_VERTEX","ADD_EDGE","REMOVE_VERTEX","REMOVE_EDGE","CHANGE_GRAPH_MODE","SELECT_VERTEX","UNSELECT_VERTEX","SHOW_MESSAGE","CLOSE_MESSAGE","UPDATE_VERTEX_POSITION","INVERT_ORIENTATION","ALGORITHM_STEP","CLEAN_GRAPH_SELECTIONS","SET_GRAPH","MOVE_CANVAS","addEdge","type","removeEdge","changeGraphMode","graphMode","currentMessageId","showMessage","message","isAlert","dispatch","a","messageId","showMessageConnector","closeMessage","algorithmStep","step","moveCanvas","START_DIALOG_FOR_RESULT","CLOSE_DIALOG","startDialogForResult","title","inputPlaceholder","onSubmit","onCancel","pattern","closeDialog","VertexAction","SELECT","UNSELECT","ENTER","EXIT","CLEAR_ALL_SELECTIONS","VertexHintAction","REMOVE","SET","HIGHLIGHT","EdgeAction","WALK","SHADOW","FLIP","AlgorithmActionType","VERTEX_ACTION","EDGE_ACTION","VERTEX_HINT_ACTION","PreCallAction","NOTHING","SELECT_EDGE","Criteria","WEIGHTED","CONNECTED","ORIENTED","ACYCLIC","getOperationsCount","trace","operationsCount","forEach","t","isChained","edgesListToAdjacencyList","vertices","edges","adjacencyList","isOriented","entries","verticesList","sort","b","edgesListToReversedAdjacencyList","map","edgesListToAdjacencyMatrix","verticesNumbers","v","nameToIndex","number","index","cell","adjacencyMatrix","Array","j","weighted","PRE_CALL","CALL","PAUSE","POP_TRACE_STEP","SET_ALGORITHM","SET_SPEED","SET_IS_ONE_STEP","CLEAR_TRACE","SHOW_STATISTICS","CLEAR_STATISTICS","setIsOneStep","isOneStep","getState","GraphMode","graph","graphReducer","callConnector","algorithmReducer","pause","start","callSuccess","currentVisualizationId","traceStep","popTraceStep","showStatistics","visualizationId","isActive","speed","VisualizationEdgeComponent","REMOVE_VERTEX_OR_EDGE","ALGORITHM_PRE_CALL_SELECT_VERTEX","ALGORITHM_PRE_CALL_SELECT_EDGE","Graph","isArray","Error","_vertices","_edges","_visualizationEdges","_currentName","max","splice","filter","findEdge","invertOrientation","newEdges","removeVisualizationEdgeByVertices","GraphComponent","draggedVertex","windowWidth","windowHeight","findIndexOfVertex","props","handleVertexDragStart","cancelBubble","setState","updateDraggedVertex","updateVertexPosition","handleVertexDragMove","handleVertexDragEnd","getEdgeType","handleCanvasClick","evt","clientX","canvasX","clientY","canvasY","addVertex","selectedVertex","unselectVertex","handleVertexClick","removeVertex","selectVertex","value","callAlgorithm","handleEdgeClick","handleCanvasDragEnd","handleResize","window","innerWidth","innerHeight","onresize","key","visualizationEdges","connect","vertexIndex","onClose","ButtonComponent","activated","SliderComponent","label","min","onChange","DropDownList","items","item","RoundedToggleSwitch","isChecked","checked","sizeof","object","objectList","stack","bytes","pop","indexOf","hasOwnProperty","used","memoryUsed","preCall","criteria","startTime","performance","now","dfs","action","actionType","toVertex","statistics","toFixed","Queue","_queue","isEmpty","bfs","d","Number","MAX_SAFE_INTEGER","dijkstra","floor","random","mstWeight","mst","prim","DSU","size","find","dsu","makeSet","union","kruskal","isConnected","isBipartite","p","level","peek","eccentricities","findRadius","diameter","findDiameter","topSortList","addedVertices","sortedVertices","isStartVertex","reverse","topSort","timer","tin","tout","countBridges","findBridges","countArticulationPoints","isArticulationPoint","children","findArticulationPoints","reversedAdjacencyList","componentsNumber","dfsComponents","findComponents","isEuler","outOddVertices","inOddVertices","degree","oddVertices","checkForEuler","assign","cur","currentVertices","pathLen","findEulerPath","findEulerCycle","START_MATRIX_DIALOG_FOR_RESULT","CLOSE_MATRIX_DIALOG","closeMatrixDialog","MenuComponent","algorithms","DFS","BFS","Dijkstra","PrimMST","KruskalMST","CheckConnected","CheckBipartite","FindRadius","FindDiameter","TopologicalSort","FindBridges","FindArticulationPoints","SCCKosaraju","EulerPath","EulerCycle","algorithmPaused","handleAlgorithmChange","clearVisualization","setAlgorithm","startVisualization","remainingAlgorithmSteps","clearTrace","clearStatistics","cleanGraphSelections","isVisualizationActive","continue","stepVisualization","stopVisualization","handleAlgorithmSpeedChange","setSpeed","askForAction","writeToFile","json","JSON","stringify","exportData","escape","anchorElement","document","getElementById","setAttribute","click","askReadFromFile","readFromFile","reader","FileReader","file","files","onload","parse","result","setGraph","resetCanvasPosition","readAsText","showAdjacencyMatrix","startMatrixDialog","nextProps","nextState","nextContext","visualizationSpeed","selectedAlgorithm","grid","bounds","cancel","id","style","aria-hidden","href","accept","continueCall","TextInputComponent","placeholder","autoFocus","customStyles","overlay","zIndex","InputDialog","handleChange","validity","valid","submit","preventDefault","submitDialog","cancelDialog","isOpen","onRequestClose","ariaHideApp","dialogReducer","lines","isVisible","isStatisticsShown","line","MatrixCell","topLeft","topRight","bottomLeft","bottomRight","onContextMenu","MatrixRow","row","first","last","vertexNumber","onCellClick","AdjacencyMatrix","column","MatrixDialog","reduce","prev","arr","handleCellClick","edgeIndex","matrixDialogReducer","submitMatrixDialog","cancelMatrixDialog","App","Menu","Boolean","location","hostname","match","defaultState","dialog","newState","matrixDialog","clone","create","getPrototypeOf","unselectSelectedVertex","updateVertexByAction","updateEdgeByAction","updateVertexHintByAction","combineReducers","addVisualizationEdge","store","createStore","rootReducer","applyMiddleware","thunk","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","module","exports"],"mappings":"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","file":"static/js/main.2ad5430b.chunk.js","sourcesContent":["export const algorithm = {\n    name: \"Breadth First Search\",\n    run: function (cells, cellStart, cellFinish, pathStatus) {\n        let node = { x: cellStart.x, y: cellStart.y, parent: null };\n\n        const queue = [node];\n        while (queue.length) {\n            let current = queue.shift();\n            if ((current.x !== cellStart.x) || (current.y !== cellStart.y))\n                cells[current.y][current.x] = pathStatus;\n            if ((current.x === cellFinish.x) && (current.y === cellFinish.y)) {\n                // const path = backtrace(current);\n                // TODO: something\n                return;\n            }\n            console.log(current);\n            const next = neighbours(current, 0, 0, cells[0].length - 1, cells.length - 1);\n            for (let i = 0; i < next.length; ++i)\n                if ((cells[next[i].y][next[i].x] !== pathStatus) && !((next[i].x === cellStart.x) && (next[i].y === cellStart.y)) && (queue.findIndex(n => (n.x === next[i].x) && (n.y === next[i].y)) === -1))\n                    queue.push(next[i]);\n        }\n    }\n};\n\nfunction backtrace(node) {\n    const path = [{x: node.x, y: node.y}];\n    while (node.parent !== null) {\n        node = node.parent;\n        path.push({x: node.x, y: node.y});\n    }\n    return path;\n}\n\nfunction neighbours(node, minX, minY, maxX, maxY) {\n    const res = [];\n    if (node.x < maxX)\n        res.push({ x: node.x + 1, y: node.y, parent: node });\n    if (node.x > minX)\n        res.push({ x: node.x - 1, y: node.y, parent: node });\n    if (node.y < maxY)\n        res.push({ x: node.x, y: node.y + 1, parent: node });\n    if (node.y > minY)\n        res.push({ x: node.x, y: node.y - 1, parent: node });\n    return res;\n}","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./PlainGraph.module.scss\";\nimport { algorithm } from \"../../algorithms/plain/breadth-first-search\";\n\nconst cx = classnames.bind(styles);\n\nconst CellState = Object.freeze({ EMPTY: 0, BLOCKED: 1, START: 2, FINISH: 3, PATH: 4});\n\nconst Cell = ({x, y, status, onMouseEnter, onMouseLeave}) => (\n    <rect x={x} y={y} className={cx(\"cell\", {\n            [`cell-blocked`]: status === CellState.BLOCKED,\n            [`cell-path`]: status === CellState.PATH,\n            [`cell-start`]: status === CellState.START,\n            [`cell-finish`]: status === CellState.FINISH\n          })}\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}/>\n);\n\nclass PlainGraph extends React.Component {\n    state = {\n        cells: [],\n        cellSize: 40,\n        rows: 1000 / 40 + 10,\n        columns: 2000 / 40 + 10,\n        isMouseDown: false,\n        previousMouseRow: -1,\n        previousMouseColumn: -1,\n        mouseCellState: -1\n    };\n\n    componentDidMount() {\n        const cellSize = 40;\n        const rows = 1000 / cellSize + 10;\n        const columns = 2000 / cellSize + 10;\n        const cells = [];\n        // const rows = window.innerHeight / cellSize + 10, columns = window.innerWidth / cellSize + 10; // TODO: change on resize\n        for (let i = 0; i < rows; ++i) {\n            const row = [];\n            for (let j = 0; j < columns; ++j) {\n                row.push(CellState.EMPTY);\n            }\n            cells.push(row);\n        }\n        cells[2][2] = CellState.START;\n        cells[2][40] = CellState.FINISH;\n        this.setState({ cells: cells, cellSize: cellSize, rows: rows, columns: columns});\n    }\n\n    invertCellUnderMouse = (event) => {\n        this.setState(oldState => {\n            const x = Math.floor(event.x / this.state.cellSize);\n            const y = Math.floor(event.y / this.state.cellSize);\n            if ((x === oldState.previousMouseColumn) && (y === oldState.previousMouseRow))\n                return oldState;\n            const state = {...oldState};\n\n            const currentCellState = state.cells[y][x];\n            if (currentCellState === state.mouseCellState) {\n                if ((currentCellState === CellState.EMPTY) || (currentCellState === CellState.PATH))\n                    state.cells[y][x] = CellState.BLOCKED;\n                else if (currentCellState === CellState.BLOCKED)\n                    state.cells[y][x] = CellState.EMPTY;\n            }\n            state.previousMouseRow = y;\n            state.previousMouseColumn = x;\n\n            return state;\n        });\n    };\n\n    handleMouseDown = (event) => {\n        algorithm.run(this.state.cells, {x:2,y:2},{x:40,y:2}, CellState.PATH);\n        const reducedEvent = { x: event.clientX, y: event.clientY };\n        this.setState({\n            isMouseDown: true,\n            mouseCellState: this.state.cells\n                [Math.floor(reducedEvent.y / this.state.cellSize)]\n                [Math.floor(reducedEvent.x / this.state.cellSize)]\n        });\n        this.invertCellUnderMouse(reducedEvent);\n    };\n\n    handleMouseUp = (event) => {\n        this.invertCellUnderMouse({ x: event.clientX, y: event.clientY });\n        this.setState({ isMouseDown: false, previousMouseRow: -1, previousMouseColumn: -1 });\n    };\n\n    handleCellMouseEnter = (event) => {\n        if (!this.state.isMouseDown)\n            return;\n        const reducedEvent = { x: event.clientX, y: event.clientY };\n        this.invertCellUnderMouse(reducedEvent);\n    };\n\n    render() {\n        return (\n            <div className={cx(\"plain_graph\")}>\n                <svg className={cx(\"drawing_area\")}\n                     onMouseDown={e => this.handleMouseDown(e)}\n                     onMouseUp={e => this.handleMouseUp(e)}>\n                    {this.state.cells.map((row, y) =>\n                        row.map((cell, x) =>\n                            <Cell\n                                x={x * this.state.cellSize}\n                                y={y * this.state.cellSize}\n                                status={cell}\n                                key={this.state.columns * y + x}\n                                onMouseEnter={e => this.handleCellMouseEnter(e)}/>\n                            )\n                        )\n                    }\n                </svg>\n            </div>\n        );\n    }\n}\n\nexport default PlainGraph;","import { Circle, Group, Text } from \"react-konva\";\nimport React from \"react\";\n\nexport class Vertex {\n    constructor(x, y, radius, name) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.state = VertexState.DEFAULT;\n        this.name = name;\n        this.hint = \"\";\n        this.hintState = VertexHintState.CLEAR;\n    }\n\n    get color() {\n        switch (this.state) {\n            case VertexState.DEFAULT:\n                return 'white';\n            case VertexState.HIGHLIGHTED:\n                return 'yellow';\n            case VertexState.PRE_COMPLETED:\n                return '#CCCCCC';\n            case VertexState.COMPLETED:\n                return '#444444';\n            case VertexState.COLOR_1:\n                return '#ff0000';\n            case VertexState.COLOR_2:\n                return '#0000ff';\n            default:\n                return 'white';\n        }\n    }\n\n    get textColor() {\n        switch (this.state) {\n            case VertexState.DEFAULT:\n                return 'black';\n            case VertexState.HIGHLIGHTED:\n                return 'black';\n            case VertexState.PRE_COMPLETED:\n                return 'black';\n            case VertexState.COMPLETED:\n                return 'white';\n            case VertexState.COLOR_1:\n                return 'white';\n            case VertexState.COLOR_2:\n                return 'white';\n            default:\n                return 'black';\n        }\n    }\n\n    get hintColor() {\n        switch (this.hintState) {\n            case VertexHintState.CLEAR:\n                return '#00000000';\n            case VertexHintState.DEFAULT:\n                return '#ff5f3c';\n            case VertexHintState.HIGHLIGHTED:\n                return '#2c99c3';\n            default:\n                return '#00000000';\n        }\n    }\n}\n\nconst handleDragStart = (e, call) => {\n    e.target.getChildren()[0].setAttrs({\n        scaleX: 1.1,\n        scaleY: 1.1,\n        shadowColor: 'black',\n        shadowBlur: 10,\n        shadowOffset: { x: 10, y: 10 },\n        shadowOpacity: 0.5\n    });\n    e.target.moveToTop();\n\n    call(e);\n};\n\nconst handleDragEnd = (e, call) => {\n    e.target.getChildren()[0].to({\n        duration: 0.25,\n        scaleX: 1,\n        scaleY: 1,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0\n    });\n\n    call(e);\n};\n\nexport const VertexComponent = ({ vertex, draggable, onDragStart, onDragEnd, onDragMove, onClick }) => {\n    const labelWidth = 40, labelHeight = 20;\n    return (\n        <Group\n            draggable={draggable}\n            onDragStart={e => handleDragStart(e, onDragStart)}\n            onDragEnd={e => handleDragEnd(e, onDragEnd)}\n            onDragMove={onDragMove}\n            onClick={onClick}\n            x={vertex.x}\n            y={vertex.y}>\n            <Circle\n                x={0}\n                y={0}\n                radius={vertex.radius}\n                fill={vertex.color}\n                stroke={'black'}\n                shadowBlur={0}\n                strokeWidth={vertexBorderWidth}\n                shadowOpacity={0.5}/>\n            <Text\n                text={vertex.name}\n                x={-labelWidth / 2.}\n                y={-labelHeight / 2.}\n                fontSize={20}\n                fill={vertex.textColor}\n                width={labelWidth}\n                height={labelHeight}\n                align={'center'}\n                verticalAlign={'middle'}/>\n\n            <Text\n                text={vertex.hint}\n                x={-2 * vertex.radius}\n                y={-2 * vertex.radius}\n                fontSize={25}\n                fill={vertex.hintColor}\n                stroke={vertex.hintColor}\n                width={labelWidth * 2}\n                height={labelHeight}\n                align={'center'}\n                verticalAlign={'middle'}/>\n        </Group>);\n};\n\nexport const vertexBorderWidth = 2;\n\nexport const VertexState = Object.freeze({ DEFAULT: 0, HIGHLIGHTED: 1, PRE_COMPLETED: 2, COMPLETED: 3, COLOR_1: 4, COLOR_2: 5 });\nexport const VertexHintState = Object.freeze({ CLEAR: 0, DEFAULT: 1, HIGHLIGHTED: 2 });","import { vertexBorderWidth } from \"../Vertex/Vertex\";\nimport { Arrow, Circle, Group, Line, Text } from \"react-konva\";\nimport React from \"react\";\n\nexport class Edge {\n    constructor(vertexFrom, vertexTo, oriented, weight) {\n        this._from = vertexFrom;\n        this._to = vertexTo;\n        this.weight = weight;\n        this.state = EdgeState.DEFAULT;\n        this._oriented = oriented;\n    }\n\n    get from() {\n        return this._from;\n    }\n\n    get to() {\n        return this._to;\n    }\n\n    get color() {\n        switch (this.state) {\n            case EdgeState.DEFAULT:\n                return 'black';\n            case EdgeState.HIGHLIGHTED:\n                return '#f7ff00';\n            case EdgeState.WALKED:\n                return '#ff5f3c';\n            case EdgeState.ERASED:\n                return '#ffffff00';\n            case EdgeState.SHADOWED:\n                return '#dddddd';\n            case EdgeState.FLIPPED:\n                return 'black';\n            default:\n                return 'black';\n        }\n    }\n\n    isWeighted() {\n        return (this.weight !== undefined) && (this.weight !== null);\n    }\n\n    isOriented() {\n        return this._oriented;\n    }\n\n    isFlipped() {\n        return this.state === EdgeState.FLIPPED;\n    }\n\n    invertOrientation() {\n        this._oriented = !this._oriented;\n    }\n}\n\nexport const EdgeComponent = ({ edge, edgeType, onClick }) => {\n    const points = getEdgePointsForType(edge, edgeType);\n    const color = edge.color;\n\n    let edgeComponent;\n    if (edgeType === EdgeType.NOT_ORIENTED)\n        edgeComponent = (\n            <Line\n                points={points.linePoints}\n                onClick={onClick}\n                stroke={color}\n                fill={color}\n                strokeWidth={2}\n                hitStrokeWidth={15}/>\n        );\n    else\n        edgeComponent = (\n            <Arrow\n                points={points.linePoints}\n                onClick={onClick}\n                stroke={color}\n                fill={color}\n                strokeWidth={2}\n                hitStrokeWidth={15}\n                tension={0.5}/>\n        );\n\n    if (edge.isWeighted())\n        return (\n            <Group onClick={onClick}>\n                {edgeComponent}\n                <EdgeLabel\n                    x={points.labelPoints[0]}\n                    y={points.labelPoints[1]}\n                    text={edge.weight}/>\n            </Group>\n        );\n    else\n        return (edgeComponent);\n};\n\nexport const EdgeLabel = ({ x, y, text }) => {\n    const labelRadius = 15;\n    const labelHorizontalPadding = 1, labelVerticalPadding = 5;\n    const labelBorderWidth = 0;\n    return (\n        <Group\n            x={x - labelRadius - labelHorizontalPadding - labelBorderWidth}\n            y={y - labelRadius - labelVerticalPadding - labelBorderWidth}\n            width={labelRadius * 2. + 2. * (labelHorizontalPadding + labelBorderWidth)}\n            height={labelRadius * 2. + 2. * (labelVerticalPadding + labelBorderWidth)}>\n            <Circle\n                x={labelRadius + labelHorizontalPadding + labelBorderWidth}\n                y={labelRadius + labelVerticalPadding + labelBorderWidth}\n                radius={labelRadius}\n                fill={'white'}\n                stroke={'black'}\n                strokeWidth={labelBorderWidth}/>\n            <Text\n                x={labelBorderWidth + labelHorizontalPadding}\n                y={labelBorderWidth + labelVerticalPadding}\n                text={text}\n                fontSize={20}\n                width={labelRadius * 2.}\n                height={labelRadius * 2.}\n                align={'center'}\n                verticalAlign={'middle'}/>\n        </Group>\n    );\n};\n\nexport const EdgeType = Object.freeze({ ONE_SIDE_ORIENTED: 0, TWO_SIDE_ORIENTED: 1, NOT_ORIENTED: 2, LOOP: 3 });\nexport const EdgeState = Object.freeze({ DEFAULT: 0, HIGHLIGHTED: 1, ERASED: 2, WALKED: 3, SHADOWED: 4, FLIPPED: 5 });\n\nexport const getEdgePointsForType = (edge, edgeType) => {\n    let vertexFrom = edge.from;\n    let vertexTo = edge.to;\n    if (edge.isFlipped())\n        [vertexFrom, vertexTo] = [vertexTo, vertexFrom];\n\n    const dx = vertexTo.x - vertexFrom.x;\n    const dy = vertexFrom.y - vertexTo.y;\n    const angle = Math.atan2(dy, dx);\n    const vertexFromOffset = vertexFrom.radius + vertexBorderWidth / 2.;\n    const vertexToOffset = vertexTo.radius + vertexBorderWidth / 2.;\n\n    if ((edgeType === EdgeType.ONE_SIDE_ORIENTED) || (edgeType === EdgeType.NOT_ORIENTED)) {\n        const xFrom = vertexFrom.x + vertexFromOffset * Math.cos(angle);\n        const yFrom = vertexFrom.y - vertexFromOffset * Math.sin(angle);\n        const xTo = vertexTo.x - vertexToOffset * Math.cos(angle);\n        const yTo = vertexTo.y + vertexToOffset * Math.sin(angle);\n\n        return {\n            linePoints: [\n                xFrom, yFrom,\n                xTo, yTo\n            ],\n            labelPoints: [\n                (xFrom + xTo) / 2.,\n                (yFrom + yTo) / 2.\n            ]\n        };\n    } else if (edgeType === EdgeType.TWO_SIDE_ORIENTED) {\n        const angleOffset = 0.25;\n        const xFrom = vertexFrom.x + vertexFromOffset * Math.cos(angle + angleOffset);\n        const yFrom = vertexFrom.y - vertexFromOffset * Math.sin(angle + angleOffset);\n        const xTo = vertexTo.x - vertexToOffset * Math.cos(angle - angleOffset);\n        const yTo = vertexTo.y + vertexToOffset * Math.sin(angle - angleOffset);\n\n        const middlePointHeightCoefficient = 1. / 15.;\n        const xMiddle = (xFrom + xTo) / 2. - (yFrom - yTo) * middlePointHeightCoefficient;\n        const yMiddle = (yFrom + yTo) / 2. + (xFrom - xTo) * middlePointHeightCoefficient;\n\n        return {\n            linePoints: [\n                xFrom, yFrom,\n                xMiddle, yMiddle,\n                xTo, yTo\n            ],\n            labelPoints: [\n                xMiddle,\n                yMiddle\n            ]\n        };\n    } else if (edgeType === EdgeType.LOOP) {\n        const xFrom = vertexFrom.x - vertexFromOffset;\n        const yFrom = vertexFrom.y;\n        const xTo = vertexFrom.x - vertexFromOffset;\n        const yTo = vertexFrom.y;\n\n        const anchorDx = 3. * vertexFromOffset / Math.sqrt(2.);\n        const anchorDy = 1.5 * vertexFromOffset / Math.sqrt(2.);\n        const xMiddleFirst = xFrom - anchorDx;\n        const yMiddleFirst = yFrom - anchorDy;\n        const xMiddle = xMiddleFirst - vertexFromOffset;\n        const yMiddle = yFrom;\n        const xMiddleSecond = xTo - anchorDx;\n        const yMiddleSecond = yTo + anchorDy;\n\n        return {\n            linePoints: [\n                xFrom, yFrom,\n                xMiddleFirst, yMiddleFirst,\n                xMiddle, yMiddle,\n                xMiddleSecond, yMiddleSecond,\n                xTo, yTo\n            ],\n            labelPoints: [\n                xMiddle, yMiddle\n            ]\n        };\n    }\n};","export function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}","import { sleep } from \"../utils/sleep\";\n\nexport const ActionType = Object.freeze({\n    ADD_VERTEX: 'ADD_VERTEX',\n    ADD_EDGE: 'ADD_EDGE',\n    REMOVE_VERTEX: 'REMOVE_VERTEX',\n    REMOVE_EDGE: 'REMOVE_EDGE',\n    CHANGE_GRAPH_MODE: 'CHANGE_GRAPH_MODE',\n    SELECT_VERTEX: 'SELECT_VERTEX',\n    UNSELECT_VERTEX: 'UNSELECT_VERTEX',\n    SHOW_MESSAGE: 'SHOW_MESSAGE',\n    CLOSE_MESSAGE: 'CLOSE_MESSAGE',\n    UPDATE_VERTEX_POSITION: 'UPDATE_VERTEX_POSITION',\n    INVERT_ORIENTATION: 'INVERT_ORIENTATION',\n    ALGORITHM_STEP: 'ALGORITHM_STEP',\n    CLEAN_GRAPH_SELECTIONS: 'CLEAN_GRAPH_SELECTIONS',\n    SET_GRAPH: 'SET_GRAPH',\n    MOVE_CANVAS: 'MOVE_CANVAS'\n});\n\nexport const addVertex = (x, y, radius) => ({\n    type: ActionType.ADD_VERTEX,\n    x,\n    y,\n    radius\n});\n\nexport const addEdge = (vertexFrom, vertexTo, weight) => ({\n    type: ActionType.ADD_EDGE,\n    vertexFrom,\n    vertexTo,\n    weight\n});\n\nexport const removeVertex = (vertex) => ({\n    type: ActionType.REMOVE_VERTEX,\n    vertex\n});\n\nexport const removeEdge = (edge) => ({\n    type: ActionType.REMOVE_EDGE,\n    edge\n});\n\nexport const changeGraphMode = (graphMode) => ({\n    type: ActionType.CHANGE_GRAPH_MODE,\n    graphMode\n});\n\nexport const selectVertex = (vertex) => ({\n    type: ActionType.SELECT_VERTEX,\n    vertex\n});\n\nexport const unselectVertex = (vertex) => ({\n    type: ActionType.UNSELECT_VERTEX,\n    vertex\n});\n\nlet currentMessageId = 0;\n\nexport const showMessage = (message, isAlert = false) => async (dispatch) => {\n    const messageId = ++currentMessageId;\n    dispatch(showMessageConnector(message, isAlert));\n    await sleep(2000);\n    if (messageId === currentMessageId)\n        dispatch(closeMessage());\n};\n\nconst showMessageConnector = (message, isAlert = false) => ({\n    type: ActionType.SHOW_MESSAGE,\n    message,\n    isAlert\n});\n\nexport const closeMessage = () => ({\n    type: ActionType.CLOSE_MESSAGE\n});\n\nexport const updateVertexPosition = (vertexIndex, x, y) => ({\n    type: ActionType.UPDATE_VERTEX_POSITION,\n    vertexIndex,\n    x,\n    y\n});\n\nexport const invertOrientation = () => ({\n    type: ActionType.INVERT_ORIENTATION\n});\n\nexport const algorithmStep = (step) => ({\n    type: ActionType.ALGORITHM_STEP,\n    step\n});\n\nexport const cleanGraphSelections = () => ({\n    type: ActionType.CLEAN_GRAPH_SELECTIONS\n});\n\nexport const setGraph = (graph) => ({\n    type: ActionType.SET_GRAPH,\n    graph\n});\n\nexport const moveCanvas = (x, y) => ({\n    type: ActionType.MOVE_CANVAS,\n    x,\n    y\n});","export const ActionType = Object.freeze({\n    START_DIALOG_FOR_RESULT: 'START_DIALOG_FOR_RESULT',\n    CLOSE_DIALOG: 'CLOSE_DIALOG'\n});\n\nexport const startDialogForResult = (title, text, hint, inputPlaceholder, onSubmit, onCancel, pattern = \".*\") => ({\n    type: ActionType.START_DIALOG_FOR_RESULT,\n    title,\n    text,\n    hint,\n    inputPlaceholder,\n    onSubmit,\n    onCancel,\n    pattern\n});\n\nconst closeDialog = () => ({\n   type: ActionType.CLOSE_DIALOG\n});\n\nexport const cancelDialog = (onCancel) => (dispatch) => {\n    if (onCancel)\n        onCancel();\n    dispatch(closeDialog());\n};\n\nexport const submitDialog = (onSubmit, result) => (dispatch) => {\n    if (onSubmit)\n        onSubmit(result);\n    dispatch(closeDialog());\n};","export const VertexAction = Object.freeze({\n    SELECT: 0,\n    UNSELECT: 1,\n    ENTER: 2,\n    EXIT: 3,\n    COLOR_1: 4,\n    COLOR_2: 5,\n    CLEAR_ALL_SELECTIONS: 6\n});\n\nexport const VertexHintAction = Object.freeze({\n    REMOVE: 0,\n    SET: 1,\n    HIGHLIGHT: 2\n});\n\nexport const EdgeAction = Object.freeze({\n    WALK: 0,\n    HIGHLIGHT: 1,\n    UNSELECT: 2,\n    SHADOW: 3,\n    CLEAR_ALL_SELECTIONS: 4,\n    FLIP: 5\n});\n\nexport const AlgorithmActionType = Object.freeze({\n    VERTEX_ACTION: 0,\n    EDGE_ACTION: 1,\n    VERTEX_HINT_ACTION: 2\n});\n\nexport const PreCallAction = Object.freeze({\n    NOTHING: 0,\n    SELECT_VERTEX: 1,\n    SELECT_EDGE: 2\n});\n\nexport const Criteria = Object.freeze({\n    NOTHING: 0,\n    WEIGHTED: 0b1,\n    CONNECTED: 0b10,\n    NOT_ORIENTED: 0b100,\n    ORIENTED: 0b1000,\n    ACYCLIC: 0b10000\n});\n\nexport const getOperationsCount = (trace) => {\n    let operationsCount = 0;\n    trace.forEach((t, i) => {\n        if ((i + 1 === trace.length) || !t.isChained)\n            ++operationsCount;\n    });\n    return operationsCount;\n};","import { Edge } from \"../components/Graph/Edge/Edge\";\n\nexport const edgesListToAdjacencyList = (vertices, edges) => {\n    const adjacencyList = {};\n    vertices.forEach(vertex => adjacencyList[vertex.name] = []);\n    edges.forEach(edge => {\n        adjacencyList[edge.from.name].push({name: edge.to.name, weight: edge.weight});\n        if (!edge.isOriented() && (edge.from !== edge.to))\n            adjacencyList[edge.to.name].push({name: edge.from.name, weight: edge.weight});\n    });\n    for (let [, verticesList] of Object.entries(adjacencyList))\n        verticesList = verticesList.sort((a, b) => a.name - b.name);\n    return adjacencyList;\n};\n\nexport const edgesListToReversedAdjacencyList = (vertices, edges) => {\n    return edgesListToAdjacencyList(vertices, edges.map(e =>\n        new Edge(e.to, e.from, e.isOriented(), e.weight))\n    );\n};\n\nexport const edgesListToAdjacencyMatrix = (vertices, edges) => {\n    const verticesNumbers = [];\n    vertices.forEach(v => verticesNumbers.push(v.name));\n    verticesNumbers.sort((a, b) => a - b);\n    const nameToIndex = {};\n    verticesNumbers.forEach((number, index) => nameToIndex[number] = index);\n\n    const adjacencyMatrix = new Array(vertices.length);\n    for (let i = 0; i < vertices.length; ++i) {\n        adjacencyMatrix[i] = new Array(vertices.length);\n        for (let j = 0; j < vertices.length; ++j)\n            adjacencyMatrix[i][j] = null;\n    }\n\n    let from, to, cell;\n    edges.forEach(e => {\n        from = nameToIndex[e.from.name];\n        to = nameToIndex[e.to.name];\n        cell = e.weight ? { weighted: true, weight: e.weight } : { weighted : false };\n        adjacencyMatrix[from][to] = cell;\n        if (!e.isOriented())\n            adjacencyMatrix[to][from] = cell;\n    });\n\n    return {adjacencyMatrix, verticesNumbers};\n};","import { algorithmStep, changeGraphMode, closeMessage, showMessage } from \"./index\";\nimport { GraphMode } from \"../components/Graph/Graph\";\nimport { Criteria, PreCallAction } from \"../algorithms/graph\";\nimport { sleep } from \"../utils/sleep\";\nimport { edgesListToAdjacencyList } from \"../utils/graphConverter\";\n\nexport const ActionType = Object.freeze({\n    PRE_CALL: 'PRE_CALL',\n    CALL: 'CALL',\n    START: 'START',\n    PAUSE: 'PAUSE',\n    POP_TRACE_STEP: 'POP_TRACE_STEP',\n    SET_ALGORITHM: 'SET_ALGORITHM',\n    SET_SPEED: 'SET_SPEED',\n    SET_IS_ONE_STEP: 'SET_IS_ONE_STEP',\n    CLEAR_TRACE: 'CLEAR_TRACE',\n    SHOW_STATISTICS: 'SHOW_STATISTICS',\n    CLEAR_STATISTICS: 'CLEAR_STATISTICS'\n});\n\nexport const preCall = (isOneStep = false) => (dispatch, getState) => {\n    dispatch(setIsOneStep(isOneStep));\n\n    const graph = getState().graphReducer.graph;\n    const vertices = graph.vertices;\n    const edges = graph.edges;\n    const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n\n    const criteria = getState().algorithmReducer.algorithm.criteria;\n    if (criteria & Criteria.WEIGHTED) {\n        for (const edge of edges) {\n            if (!edge.isWeighted()) {\n                dispatch(showMessage(\"Граф должен быть взвешенным!\", true));\n                return;\n            }\n        }\n    }\n    if ((criteria & Criteria.NOT_ORIENTED) && graph.isOriented()) {\n        dispatch(showMessage(\"Граф должен быть неориентированным!\", true));\n        return;\n    }\n    if ((criteria & Criteria.ORIENTED) && !graph.isOriented()) {\n        dispatch(showMessage(\"Граф должен быть ориентированным!\", true));\n        return;\n    }\n    if ((criteria & Criteria.CONNECTED) && (vertices.length > 0)) {\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        const dfs = (v) => {\n            used[v] = true;\n            let to;\n            adjacencyList[v].forEach(toVertex => {\n                to = toVertex.name;\n                if (!used[to]) {\n                    dfs(to);\n                }\n            });\n        };\n        dfs(vertices[0].name);\n\n        for (const v of vertices) {\n            if (!used[v.name]) {\n                dispatch(showMessage(\"Граф должен быть связным!\", true));\n                return;\n            }\n        }\n    }\n    if ((criteria & Criteria.ACYCLIC) && (vertices.length > 0)) {\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = 0);\n        const dfs = (v) => {\n            used[v] = 1;\n            let to;\n            for (const toVertex of adjacencyList[v]) {\n                to = toVertex.name;\n                if (!used[to]) {\n                    if (!dfs(to))\n                        return false;\n                } else if (used[to] === 1) {\n                    return false;\n                }\n            }\n            used[v] = 2;\n            return true;\n        };\n        for (const {name: start} of vertices) {\n            if (!used[start] && !dfs(start)) {\n                dispatch(showMessage(\"Граф должен быть ацикличным!\", true));\n                return;\n            }\n        }\n    }\n\n    const preCall = getState().algorithmReducer.algorithm.preCall;\n    if (preCall === PreCallAction.SELECT_VERTEX) {\n        dispatch(changeGraphMode(GraphMode.ALGORITHM_PRE_CALL_SELECT_VERTEX));\n        dispatch(showMessage(\"Выберите вершину\"));\n    } else if (preCall === PreCallAction.SELECT_EDGE) {\n        dispatch(changeGraphMode(GraphMode.ALGORITHM_PRE_CALL_SELECT_EDGE));\n        dispatch(showMessage(\"Выберите ребро\"));\n    } else if (preCall === PreCallAction.NOTHING) {\n        dispatch(call());\n    }\n};\n\nexport const setSpeed = (speed) => ({\n    type: ActionType.SET_SPEED,\n    speed\n});\n\nexport const setAlgorithm = (algorithm) => ({\n    type: ActionType.SET_ALGORITHM,\n    algorithm\n});\n\nconst setIsOneStep = (isOneStep) => ({\n    type: ActionType.SET_IS_ONE_STEP,\n    isOneStep\n});\n\nexport const call = (vertex, edge) => (dispatch, getState) => {\n    dispatch(closeMessage());\n    dispatch(changeGraphMode(GraphMode.DEFAULT));\n    const graph = getState().graphReducer.graph;\n    dispatch(callConnector(graph, vertex, edge));\n\n    const isOneStep = getState().algorithmReducer.isOneStep;\n    isOneStep ? dispatch(pause()) : dispatch(start());\n    dispatch(callSuccess(isOneStep));\n};\n\nexport const continueCall = (isOneStep = false) => (dispatch) => {\n    isOneStep ? dispatch(pause()) : dispatch(start());\n    dispatch(callSuccess(isOneStep));\n};\n\nconst start = () => ({\n    type: ActionType.START\n});\n\nexport const pause = () => ({\n    type: ActionType.PAUSE\n});\n\nconst callConnector = (graph, vertex, edge) => ({\n    type: ActionType.CALL,\n    graph,\n    vertex,\n    edge\n});\n\nlet currentVisualizationId = 0; // To prevent several visualization 'threads'\n\nconst callSuccess = (isOneStep = false) => async (dispatch, getState) => {\n    if (isOneStep) {\n        let traceStep = {isChained : true};\n        while ((getState().algorithmReducer.trace.length > 0) && traceStep.isChained) {\n            traceStep = getState().algorithmReducer.trace[0];\n            dispatch(algorithmStep(traceStep));\n            dispatch(popTraceStep());\n\n            if (getState().algorithmReducer.trace.length === 0) {\n                dispatch(showStatistics());\n            }\n        }\n        return;\n    }\n\n    const visualizationId = ++currentVisualizationId;\n    let traceStep;\n    while ((getState().algorithmReducer.trace.length > 0) && getState().algorithmReducer.isActive) {\n        traceStep = getState().algorithmReducer.trace[0];\n        dispatch(algorithmStep(traceStep));\n        dispatch(popTraceStep());\n        if ((getState().algorithmReducer.trace.length > 0) && !traceStep.isChained) {\n            await sleep(getState().algorithmReducer.speed);\n            if (currentVisualizationId !== visualizationId)\n                return;\n        }\n    }\n    if (getState().algorithmReducer.isActive) {\n        dispatch(pause());\n        dispatch(showStatistics());\n    }\n};\n\nconst popTraceStep = () => ({\n    type: ActionType.POP_TRACE_STEP\n});\n\nexport const clearTrace = () => ({\n    type: ActionType.CLEAR_TRACE\n});\n\nconst showStatistics = () => ({\n   type: ActionType.SHOW_STATISTICS\n});\n\nexport const clearStatistics = () => ({\n    type: ActionType.CLEAR_STATISTICS\n});","import { Arrow, Group, Line } from \"react-konva\";\nimport React from \"react\";\nimport { EdgeLabel, getEdgePointsForType } from \"../Edge/Edge\";\n\nexport const VisualizationEdgeComponent = ({ edge, edgeType }) => {\n    const points = getEdgePointsForType(edge, edgeType);\n    const color = edge.color;\n    let edgeComponent;\n    if (edgeType === EdgeType.NOT_ORIENTED)\n        edgeComponent = (\n            <Line\n                points={points.linePoints}\n                stroke={color}\n                fill={color}\n                strokeWidth={3}\n                hitStrokeWidth={16}/>\n        );\n    else\n        edgeComponent = (\n            <Arrow\n                points={points.linePoints}\n                stroke={color}\n                fill={color}\n                strokeWidth={3}\n                hitStrokeWidth={16}\n                tension={0.5}/>\n        );\n\n    if (edge.isWeighted())\n        return (\n            <Group>\n                {edgeComponent}\n                <EdgeLabel\n                    x={points.labelPoints[0]}\n                    y={points.labelPoints[1]}\n                    text={edge.weight}/>\n            </Group>\n        );\n    else\n        return (edgeComponent);\n};\n\nexport const EdgeType = Object.freeze({ ONE_SIDE_ORIENTED: 0, TWO_SIDE_ORIENTED: 1, NOT_ORIENTED: 2, LOOP: 3 });","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./Graph.module.scss\";\nimport { Layer, Rect, Stage } from \"react-konva\";\nimport { Vertex, VertexComponent } from \"./Vertex/Vertex\";\nimport { Edge, EdgeComponent, EdgeType } from \"./Edge/Edge\";\nimport { connect } from \"react-redux\";\nimport {\n    addEdge,\n    addVertex,\n    moveCanvas,\n    removeEdge,\n    removeVertex,\n    selectVertex,\n    unselectVertex,\n    updateVertexPosition\n} from \"../../actions\";\nimport { startDialogForResult } from \"../../actions/dialog\";\nimport { call } from \"../../actions/algorithm\";\nimport { VisualizationEdgeComponent } from \"./VisualizationEdge/VisualizationEdge\";\n\nconst cx = classnames.bind(styles);\n\nexport const vertexRadius = 20;\n\nconst mapStateToProps = state => ({\n    graph: state.graphReducer.graph,\n    graphMode: state.graphReducer.graphMode,\n    selectedVertex: state.graphReducer.selectedVertex,\n    canvasX: state.graphReducer.canvasX,\n    canvasY: state.graphReducer.canvasY\n});\n\nexport const GraphMode = Object.freeze({\n    DEFAULT: 0,\n    ADD_VERTEX: 1,\n    ADD_EDGE: 2,\n    REMOVE_VERTEX_OR_EDGE: 3,\n    ALGORITHM_PRE_CALL_SELECT_VERTEX: 4,\n    ALGORITHM_PRE_CALL_SELECT_EDGE: 5\n});\n\nexport class Graph {\n    constructor(oriented, vertices = null, edges = null) {\n        if (!vertices || !Array.isArray(vertices) || !edges || !Array.isArray(edges)) {\n            this._vertices = [];\n            this._edges = [];\n            this._visualizationEdges = [];\n            this._oriented = oriented;\n            this._currentName = 0;\n        } else {\n            for (let i = 0; i < vertices.length; ++i) {\n                if ((vertices[i].name < 0) || (vertices[i].name > 999))\n                    throw new Error(\"Invalid vertex name\");\n\n                for (let j = 0; j < vertices.length; ++j) {\n                    if ((i !== j) && (vertices[i].name === vertices[j].name))\n                        throw new Error(\"Two vertices with equal names\");\n                }\n            }\n\n            for (let i = 0; i < edges.length; ++i) {\n                if (edges[i].weight && ((edges[i].weight < 0) || (edges[i].weight > 99)))\n                    throw new Error(\"Invalid edge weight\");\n                if (vertices.findIndex(v => v.name === edges[i].from.name) === -1)\n                    throw new Error(\"Invalid vertex 'from'\");\n                if (vertices.findIndex(v => v.name === edges[i].to.name) === -1)\n                    throw new Error(\"Invalid vertex 'to'\");\n\n                for (let j = 0; j < edges.length; ++j) {\n                    if (i !== j) {\n                        if (oriented) {\n                            if ((edges[i].from.name === edges[j].from.name) && (edges[i].to.name === edges[j].to.name))\n                                throw new Error(\"Multiedges aren't supported\");\n                        } else {\n                            if ((edges[i].from.name === edges[j].from.name) && (edges[i].to.name === edges[j].to.name)\n                                || (edges[i].to.name === edges[j].from.name) && (edges[i].from.name === edges[j].to.name)) {\n                                throw new Error(\"Multiedges aren't supported\");\n                            }\n                        }\n                    }\n                }\n            }\n\n            this._vertices = [...vertices];\n            this._edges = [...edges];\n            this._visualizationEdges = [];\n            this._oriented = oriented;\n            this._currentName = Math.max(...vertices.map(v => v.name)) + 1;\n        }\n    }\n\n    addVertex(x, y, radius) {\n        const vertex = new Vertex(x, y, radius, this._currentName++);\n        this._vertices.push(vertex);\n        return vertex;\n    }\n\n    removeVertex(vertex) {\n        const index = this._vertices.findIndex(v => v === vertex);\n        if (index !== -1) {\n            this._vertices.splice(index, 1);\n            this._edges = this._edges.filter(edge => (edge.from.name !== vertex.name) && (edge.to.name !== vertex.name));\n        }\n    }\n\n    findEdge(vertexFrom, vertexTo) {\n        if (this._oriented)\n            return this._edges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo));\n        else\n            return this._edges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo)\n                || (e.to === vertexFrom) && (e.from === vertexTo));\n    }\n\n    addEdge(vertexFrom, vertexTo, weight) {\n        const i = this.findEdge(vertexFrom, vertexTo);\n        if (i === -1) {\n            const edge = new Edge(vertexFrom, vertexTo, this._oriented, weight);\n            this._edges.push(edge);\n            return edge;\n        }\n        else {\n            this._edges[i].weight = weight;\n        }\n    }\n\n    removeEdge(edge) {\n        this._edges = this._edges.filter(e => e !== edge);\n    }\n\n    invertOrientation() {\n        this._oriented = !this._oriented;\n        if (this._oriented) {\n            this._edges.forEach(edge => edge.invertOrientation());\n            const oldEdges = [...this._edges];\n            oldEdges.forEach(e => this.addEdge(e.to, e.from, e.weight));\n        } else {\n            const newEdges = [];\n            this._edges.forEach(edge => {\n                if (newEdges.findIndex(e => (e.from === edge.from) && (e.to === edge.to)\n                    || (e.to === edge.from) && (e.from === edge.to)) === -1) {\n\n                    edge.invertOrientation();\n                    newEdges.push(edge);\n                }\n            });\n            this._edges = newEdges;\n        }\n    }\n\n    findVisualizationEdge(vertexFrom, vertexTo, oriented) {\n        if (oriented)\n            return this._visualizationEdges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo));\n        else\n            return this._visualizationEdges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo)\n                || (e.to === vertexFrom) && (e.from === vertexTo));\n    }\n\n    addVisualizationEdge(vertexFrom, vertexTo, oriented, weight) {\n        this.removeVisualizationEdgeByVertices(vertexFrom, vertexTo, oriented);\n        const edge = new Edge(vertexFrom, vertexTo, oriented, weight);\n        this._visualizationEdges.push(edge);\n        return edge;\n    }\n\n    removeVisualizationEdge(edge) {\n        this._visualizationEdges = this._visualizationEdges.filter(e => e !== edge);\n    }\n\n    removeVisualizationEdgeByVertices(vertexFrom, vertexTo, oriented) {\n        if (oriented)\n            this._visualizationEdges = this._visualizationEdges.filter(e =>\n                (e.from.name !== vertexFrom.name) || (e.to.name !== vertexTo.name)\n            );\n        else\n            this._visualizationEdges = this._visualizationEdges.filter(e =>\n                ((e.from.name !== vertexFrom.name) || (e.to.name !== vertexTo.name)) &&\n                ((e.to.name !== vertexFrom.name) || (e.from.name !== vertexTo.name))\n            );\n    }\n\n    get vertices() {\n        return this._vertices;\n    }\n\n    get edges() {\n        return this._edges;\n    }\n\n    get visualizationEdges() {\n        return this._visualizationEdges;\n    }\n\n    set visualizationEdges(edges) {\n        this._visualizationEdges = edges;\n    }\n\n    isOriented() {\n        return this._oriented;\n    }\n}\n\nclass GraphComponent extends React.Component {\n    state = {\n        draggedVertex: undefined,\n        windowWidth: 700,\n        windowHeight: 700\n    };\n\n    componentDidMount() {\n        const handleResize = () => {\n            this.setState({ windowWidth: window.innerWidth, windowHeight: window.innerHeight });\n        };\n        window.onresize = handleResize;\n        handleResize();\n    }\n\n    findIndexOfVertex = (vertex) => {\n        return this.props.graph.vertices.findIndex(v => v === vertex);\n    };\n\n    handleVertexDragStart = (e, vertex) => {\n        e.cancelBubble = true;\n\n        const i = this.findIndexOfVertex(vertex);\n        this.setState({ draggedVertex: (i !== -1 ? i : undefined) });\n    };\n\n    updateDraggedVertex = (x, y) => {\n        const vertex = this.state.draggedVertex;\n        if (vertex !== undefined)\n            this.props.updateVertexPosition(vertex, x, y);\n    };\n\n    handleVertexDragMove = e => {\n        e.cancelBubble = true;\n\n        this.updateDraggedVertex(e.target.x(), e.target.y());\n    };\n\n    handleVertexDragEnd = (e, vertex) => {\n        e.cancelBubble = true;\n\n        this.updateDraggedVertex(e.target.x(), e.target.y());\n        this.setState({ draggedVertex: undefined });\n    };\n\n    getEdgeType = edge => {\n        const vertexFrom = edge.from, vertexTo = edge.to;\n\n        if (vertexTo === vertexFrom)\n            return EdgeType.LOOP;\n        else if (!edge.isOriented())\n            return EdgeType.NOT_ORIENTED;\n        else if ((this.props.graph.edges.findIndex(e => (e.from === vertexTo) && (e.to === vertexFrom)) !== -1)\n                && (this.props.graph.edges.findIndex(e => (e.to === vertexTo) && (e.from === vertexFrom)) !== -1))\n            return EdgeType.TWO_SIDE_ORIENTED;\n        else\n            return EdgeType.ONE_SIDE_ORIENTED;\n    };\n\n    handleCanvasClick = e => {\n        const x = e.evt.clientX - this.props.canvasX, y = e.evt.clientY - this.props.canvasY;\n\n        if (this.props.graphMode === GraphMode.ADD_VERTEX)\n            this.props.addVertex(x, y, vertexRadius);\n        else if (this.props.graphMode === GraphMode.ADD_EDGE) {\n            if (this.props.selectedVertex !== undefined) {\n                this.props.unselectVertex();\n            }\n        }\n    };\n\n    handleVertexClick = (e, vertex) => {\n        if (this.props.graphMode === GraphMode.REMOVE_VERTEX_OR_EDGE) {\n            e.cancelBubble = true;\n            this.props.removeVertex(vertex);\n        } else if (this.props.graphMode === GraphMode.ADD_EDGE) {\n            e.cancelBubble = true;\n\n            if (this.props.selectedVertex === undefined) {\n                this.props.selectVertex(vertex);\n            }\n            else {\n                this.props.startDialogForResult(\n                    \"Введите вес ребра\",\n                    `(${this.props.selectedVertex.name} ${this.props.graph.isOriented() ? '->' : '<->'} ${vertex.name})`,\n                    \"Оставьте поле пустым, чтобы добавить невзвешенное ребро\",\n                    \"Вес ребра\",\n                    (value) => {\n                        if (value === \"\")\n                            value = undefined;\n                        this.props.addEdge(this.props.selectedVertex, vertex, value);\n                        this.props.unselectVertex();\n                    },\n                    null,\n                    \"[0-9]{0,2}\"\n                );\n            }\n        } else if (this.props.graphMode === GraphMode.ALGORITHM_PRE_CALL_SELECT_VERTEX) {\n            e.cancelBubble = true;\n\n            this.props.callAlgorithm(vertex, null);\n        }\n    };\n\n    handleEdgeClick = (e, edge) => {\n        if (this.props.graphMode === GraphMode.REMOVE_VERTEX_OR_EDGE) {\n            e.cancelBubble = true;\n            this.props.removeEdge(edge);\n        } else if (this.props.graphMode === GraphMode.ALGORITHM_PRE_CALL_SELECT_EDGE) {\n            e.cancelBubble = true;\n            this.props.callAlgorithm(null, edge);\n        }\n    };\n\n    handleCanvasDragEnd = (e) => {\n        this.props.moveCanvas(e.target.x(), e.target.y());\n    };\n\n    render() {\n        return (\n            <Stage\n                x={this.props.canvasX}\n                y={this.props.canvasY}\n                draggable={this.props.graphMode === GraphMode.DEFAULT}\n                onDragEnd={this.handleCanvasDragEnd}\n                onClick={this.handleCanvasClick}\n                width={this.state.windowWidth}\n                height={this.state.windowHeight}>\n                <Layer>\n                    <Rect fill={'white'} x={0} y={0} width={this.state.windowWidth} height={this.state.windowHeight}/>\n                    {\n                        this.props.graph.edges.map((edge, index) =>\n                            <EdgeComponent\n                                key={index}\n                                vertexFrom={edge.from}\n                                vertexTo={edge.to}\n                                edge={edge}\n                                edgeType={this.getEdgeType(edge)}\n                                onClick={(e) => this.handleEdgeClick(e, edge)}/>\n                        )\n                    }\n                    {\n                        this.props.graph.visualizationEdges.map((edge, index) =>\n                            <VisualizationEdgeComponent\n                                key={index}\n                                vertexFrom={edge.from}\n                                vertexTo={edge.to}\n                                edge={edge}\n                                edgeType={this.getEdgeType(edge)}/>\n                        )\n                    }\n                    {\n                        this.props.graph.vertices.map((vertex, index) =>\n                            <VertexComponent\n                                key={index}\n                                vertex={vertex}\n                                draggable={this.props.graphMode === GraphMode.DEFAULT}\n                                onClick={(e) => this.handleVertexClick(e, vertex)}\n                                onDragStart={e => this.handleVertexDragStart(e, vertex)}\n                                onDragEnd={e => this.handleVertexDragEnd(e, vertex)}\n                                onDragMove={e => this.handleVertexDragMove(e, vertex)}/>\n                        )\n                    }\n                </Layer>\n            </Stage>\n        );\n    }\n}\n\n\nconst mapDispatchToProps = dispatch => ({\n    addVertex: (x, y, radius) => dispatch(addVertex(x, y, radius)),\n    addEdge: (vertexFrom, vertexTo, weight) => dispatch(addEdge(vertexFrom, vertexTo, weight)),\n    removeVertex: (vertex) => dispatch(removeVertex(vertex)),\n    removeEdge: (edge) => dispatch(removeEdge(edge)),\n    updateVertexPosition: (vertexIndex, x, y) => dispatch(updateVertexPosition(vertexIndex, x, y)),\n    selectVertex: (vertex) => dispatch(selectVertex(vertex)),\n    unselectVertex: (vertex) => dispatch(unselectVertex(vertex)),\n    startDialogForResult: (title, text, hint, inputPlaceholder, onSubmit, onClose, pattern) =>\n        dispatch(startDialogForResult(title, text, hint, inputPlaceholder, onSubmit, onClose, pattern)),\n    callAlgorithm: (vertex, edge) => dispatch(call(vertex, edge)),\n    moveCanvas: (x, y) => dispatch(moveCanvas(x, y))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(GraphComponent);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./Buttons.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const ButtonComponent = ({ text, type = \"button\", onClick, activated, className }) => {\n    return (\n        <button type={type} className={cx(\"button\", className, {[`activated`]: activated})} onClick={onClick}>\n            {text}\n        </button>\n    );\n};","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./Sliders.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const SliderComponent = ({ label, value, min, max, onChange }) => {\n    return (\n        <div className={cx(\"slider-wrapper\")}>\n            <div className={cx(\"slider-label\")}>{label}</div>\n            <input\n                type={\"range\"}\n                className={cx(\"slider\")}\n                value={value}\n                min={min}\n                max={max}\n                onChange={onChange}/>\n        </div>\n    );\n};","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./DropDownLists.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const DropDownList = ({ items, onChange }) => {\n    return (\n        <select className={cx(\"drop-down-list\")} onChange={onChange}>\n            {items.map((item, index) => <option key={index} value={index}>{item}</option>)}\n        </select>\n    );\n};","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./ToggleSwitches.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const RoundedToggleSwitch = ({ text, onChange, className, isChecked }) => {\n    return (\n        <div className={cx(\"switch-round-wrapper\", className)}>\n            <label className={cx(\"switch-round\")}>\n                <input type={\"checkbox\"} onChange={onChange} checked={isChecked}/>\n                <span className={cx(\"slider\")}/>\n            </label>\n            <span className={cx(\"text\")}>{text}</span>\n        </div>\n    );\n};","export function sizeof(object) {\n    let objectList = [],\n        stack = [object],\n        bytes = 0,\n        value,\n        i;\n\n    while (stack.length) {\n        value = stack.pop();\n\n        if (typeof value === 'boolean') {\n            bytes += 4;\n        } else if (typeof value === 'string') {\n            bytes += value.length * 2;\n        } else if (typeof value === 'number') {\n            bytes += 8;\n        } else if (typeof value === 'object'\n            && objectList.indexOf(value) === -1) {\n            objectList.push(value);\n\n            for (i in value) {\n                if (value.hasOwnProperty(i)) {\n                    stack.push(value[i]);\n                }\n            }\n        }\n    }\n    return bytes;\n}","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet used = {};\nlet trace = [];\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList) => {\n    used[vertex] = true;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to = 0;\n    adjacencyList[vertex].forEach(toVertex => {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            dfs(to, adjacencyList);\n            trace.push({ from: to, to: vertex, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    });\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    memoryUsed += sizeof(to);\n};\n\nexport default {\n    name: \"Поиск в глубину\",\n\n    preCall: PreCallAction.SELECT_VERTEX,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges, start) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        dfs(start.name, adjacencyList);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","export class Queue {\n    constructor() {\n        this._queue = [];\n    }\n\n    get length() {\n        return this._queue.length;\n    }\n\n    isEmpty() {\n        return this._queue.length === 0;\n    }\n\n    push(value) {\n        this._queue.push(value);\n    }\n\n    pop() {\n        // TODO: O(N) -> O(1)\n        return this._queue.shift();\n    }\n\n    peek() {\n        return this._queue[0];\n    }\n}","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, adjacencyList, used, trace) => {\n    used[start] = true;\n    const queue = new Queue();\n    queue.push(start);\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let vertex = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.pop();\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n                used[to] = true;\n                queue.push(to);\n                trace.push({ vertex: to, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        });\n        trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(queue) + sizeof(vertex) + sizeof(to);\n};\n\nexport default {\n    name: \"Поиск в ширину\",\n\n    preCall: PreCallAction.SELECT_VERTEX,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges, start) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        bfs(start.name, adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst dijkstra = (start, vertices, adjacencyList, used, trace) => {\n    const d = {};\n    vertices.forEach(v => {\n        if (v === start)\n            return;\n        d[v] = Number.MAX_SAFE_INTEGER;\n        trace.push({ vertex: v, hint: \"∞\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n    });\n    d[start] = 0;\n    trace.push({ vertex: start, hint: \"0\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    for (let i in vertices) {\n        let v = -1;\n\n        memoryUsed += sizeof(v);\n\n        vertices.forEach(j => {\n            if (!used[j] && ((v === -1) || (d[j] < d[v])))\n                v = j;\n        });\n        if (d[v] === Number.MAX_SAFE_INTEGER)\n            break;\n\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n        for (let {name: to, weight} of adjacencyList[v]) {\n            if (used[to])\n                continue;\n            weight = Number(weight);\n\n            trace.push({ from: v, to, oriented: true, weight, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (d[v] + weight < d[to]) {\n                d[to] = d[v] + weight;\n                trace.push({ from: v, to, oriented: true, weight, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                trace.push({ vertex: to, hint: d[to], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else {\n                trace.push({ from: v, to, oriented: true, weight, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(d);\n};\n\nexport default {\n    name: \"Алгоритм Дейкстры\",\n\n    preCall: PreCallAction.SELECT_VERTEX,\n\n    criteria: Criteria.WEIGHTED,\n\n    call: (vertices, edges, start) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        dijkstra(start.name, vertices.map(v => v.name), adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst prim = (start, vertices, edges, adjacencyList, used, trace) => {\n    edges.forEach(e => {\n        trace.push({ from: e.from.name, to: e.to.name, oriented: false, weight: e.weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    });\n\n    const d = {};\n    const mst = {};\n    vertices.forEach(v => {\n        if (v === start)\n            return;\n        d[v] = Number.MAX_SAFE_INTEGER;\n        trace.push({ vertex: v, hint: \"∞\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n        mst[v] = null;\n    });\n    d[start] = 0;\n    trace.push({ vertex: start, hint: \"0\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    for (let i in vertices) {\n        let v = -1;\n\n        memoryUsed += sizeof(v);\n\n        vertices.forEach(j => {\n            if (!used[j] && ((v === -1) || (d[j] < d[v])))\n                v = j;\n        });\n        if (d[v] === Number.MAX_SAFE_INTEGER)\n            break;\n\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n        for (let {name: to, weight} of adjacencyList[v]) {\n            if (used[to])\n                continue;\n            weight = Number(weight);\n\n            trace.push({ from: v, to, oriented: false, weight, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (weight < d[to]) {\n                d[to] = weight;\n                if (mst[to] !== null) {\n                    trace.push({ from: mst[to], to, oriented: false, weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION, isChained: false });\n                }\n                mst[to] = v;\n                trace.push({ from: v, to, oriented: false, weight, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                trace.push({ vertex: to, hint: d[to], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else {\n                trace.push({ from: v, to, oriented: false, weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    let mstWeight = 0;\n    for (const v in d)\n        mstWeight += d[v];\n\n    memoryUsed += sizeof(d) + sizeof(mst);\n\n    return mstWeight;\n};\n\nexport default {\n    name: \"Алгоритм Прима\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.CONNECTED | Criteria.WEIGHTED | Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const start = vertices[Math.floor(Math.random() * vertices.length)];\n        const mstWeight = prim(start.name, vertices.map(v => v.name), edges, adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList) +\n            sizeof(start) +\n            sizeof(mstWeight);\n\n        return {\n            trace,\n            statistics: [\n                `Вес минимального каркаса: ${mstWeight}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","export class DSU {\n    constructor() {\n        this.parent = {};\n        this.size = {};\n    }\n\n    makeSet(x) {\n        this.parent[x] = x;\n        this.size[x] = 1;\n    }\n\n    find(x) {\n        if (x === this.parent[x])\n            return x;\n        this.parent[x] = this.find(this.parent[x]);\n        return this.parent[x];\n    }\n\n    union(x, y) {\n        x = this.find(x);\n        y = this.find(y);\n        if (x !== y)\n            if (this.size[x] < this.size[y])\n                [x, y] = [y, x];\n            this.parent[y] = x;\n            this.size[x] += this.size[y];\n    }\n}","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction } from \"./index\";\nimport { DSU } from \"../../utils/dsu\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst kruskal = (vertices, edges, trace) => {\n    const dsu = new DSU();\n    vertices.forEach(v => dsu.makeSet(v.name));\n    edges.sort((a, b) => a.weight - b.weight);\n\n    edges.forEach(e => {\n        trace.push({ from: e.from.name, to: e.to.name, oriented: false, weight: e.weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    });\n\n    let mstWeight = 0;\n    let from = 0, to = 0, weight = 0;\n    edges.forEach(e => {\n        from = e.from.name;\n        to = e.to.name;\n        weight = Number(e.weight);\n        trace.push({ from, to, oriented: false, weight, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n        if (dsu.find(from) !== dsu.find(to)) {\n            mstWeight += weight;\n            dsu.union(from, to);\n            trace.push({ from, to, oriented: false, weight, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n        } else {\n            trace.push({ from, to, oriented: false, weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    });\n\n    memoryUsed +=\n        sizeof(dsu) +\n        sizeof(mstWeight) +\n        sizeof(from) +\n        sizeof(to) +\n        sizeof(weight);\n\n    return mstWeight;\n};\n\nexport default {\n    name: \"Алгоритм Краскала\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.CONNECTED | Criteria.WEIGHTED | Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const mstWeight = kruskal(vertices, edges, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        return {\n            trace,\n            statistics: [\n                `Вес минимального каркаса: ${mstWeight}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, vertices, adjacencyList, used, trace) => {\n    used[start] = true;\n    const queue = new Queue();\n    queue.push(start);\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let vertex = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.pop();\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                trace.push({ from: vertex, to: to, oriented: false, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n                used[to] = true;\n                queue.push(to);\n                trace.push({ vertex: to, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        });\n        trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(queue) + sizeof(vertex) + sizeof(to);\n    for (const vertex of vertices) {\n        if (!used[vertex.name])\n            return false;\n    }\n    return true;\n};\n\nexport default {\n    name: \"Проверка на связность\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const start = vertices[Math.floor(Math.random() * vertices.length)];\n        const isConnected = bfs(start.name, vertices, adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(isConnected) +\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Граф ${isConnected ? \"связный\" : \"несвязный\"}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet used = {};\nlet trace = [];\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList, parent = -1, color = 1) => {\n    used[vertex] = color;\n    trace.push({ vertex, action: color === 1 ? VertexAction.COLOR_1 : VertexAction.COLOR_2, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to;\n    for (const toVertex of adjacencyList[vertex]) {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (!dfs(to, adjacencyList, vertex, 3 - color))\n                return false;\n            trace.push({ from: to, to: vertex, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n        } else if ((parent !== to) && (used[to] === color)) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            return false;\n        }\n    }\n    return true;\n};\n\nexport default {\n    name: \"Проверка на двудольность\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        used = {};\n        vertices.forEach(vertex => used[vertex.name] = 0);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        let isBipartite = true;\n        for (const {name: vertex} of vertices) {\n            if (!used[vertex]) {\n                isBipartite &= dfs(vertex, adjacencyList);\n                if (!isBipartite)\n                    break;\n            }\n        }\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(isBipartite) +\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Граф ${isBipartite ? \"двудольный\" : \"недвудольный\"}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, vertices, adjacencyList, used, trace) => {\n    const d = {}, p = {};\n    vertices.forEach(vertex => {\n        d[vertex.name] = Number.MAX_SAFE_INTEGER;\n        p[vertex.name] = -1;\n    });\n    used[start] = true;\n    const queue = new Queue();\n    queue.push({ vertex: start, level: 0 });\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    let vertex = 0, level = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.peek().vertex;\n        level = queue.pop().level;\n        d[vertex] = level;\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                used[to] = true;\n                queue.push({ vertex: to, level: level + 1 });\n                p[to] = vertex;\n            }\n        });\n    }\n\n    while (p[vertex] !== -1) {\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ from: p[vertex], to: vertex, oriented: false, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        vertex = p[vertex];\n    }\n    trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex: start, hint: level, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    memoryUsed +=\n        sizeof(d) +\n        sizeof(p) +\n        sizeof(queue) +\n        sizeof(vertex) +\n        sizeof(level) +\n        sizeof(to);\n\n    return level;\n};\n\nconst findRadius = (vertices, edges, adjacencyList, trace) => {\n    let used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n\n    let eccentricities = {};\n    let radius = Number.MAX_SAFE_INTEGER;\n    for (const {name: start} of vertices) {\n        vertices.forEach(vertex => used[vertex.name] = false);\n        eccentricities[start] = bfs(start, vertices, adjacencyList, used, trace);\n        trace.push({ vertex: start, hint: eccentricities[start], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n\n        trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n\n        radius = Math.min(radius, eccentricities[start]);\n    }\n\n    for (const {name: v} of vertices) {\n        if (eccentricities[v] === radius)\n            trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    }\n\n    memoryUsed +=\n        sizeof(used) +\n        sizeof(eccentricities) +\n        sizeof(radius);\n\n    return radius;\n};\n\nexport default {\n    name: \"Радиус и центр графа\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED | Criteria.CONNECTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const trace = [];\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const radius = findRadius(vertices, edges, adjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(radius);\n\n        return {\n            trace,\n            statistics: [\n                `Радиус графа: ${radius}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, vertices, adjacencyList, used, trace) => {\n    const d = {}, p = {};\n    vertices.forEach(vertex => {\n        d[vertex.name] = Number.MAX_SAFE_INTEGER;\n        p[vertex.name] = -1;\n    });\n    used[start] = true;\n    const queue = new Queue();\n    queue.push({ vertex: start, level: 0 });\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    let vertex = 0, level = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.peek().vertex;\n        level = queue.pop().level;\n        d[vertex] = level;\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                used[to] = true;\n                queue.push({ vertex: to, level: level + 1 });\n                p[to] = vertex;\n            }\n        });\n    }\n\n    while (p[vertex] !== -1) {\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ from: p[vertex], to: vertex, oriented: false, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        vertex = p[vertex];\n    }\n    trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex: start, hint: level, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    memoryUsed +=\n        sizeof(queue) +\n        sizeof(d) +\n        sizeof(p) +\n        sizeof(vertex) +\n        sizeof(level) +\n        sizeof(to);\n\n    return level;\n};\n\nconst findDiameter = (vertices, edges, adjacencyList, trace) => {\n    let used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n\n    let eccentricities = {};\n    let diameter = 0;\n    for (const {name: start} of vertices) {\n        vertices.forEach(vertex => used[vertex.name] = false);\n        eccentricities[start] = bfs(start, vertices, adjacencyList, used, trace);\n        trace.push({ vertex: start, hint: eccentricities[start], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n\n        trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n\n        diameter = Math.max(diameter, eccentricities[start]);\n    }\n\n    for (const {name: v} of vertices) {\n        if (eccentricities[v] === diameter)\n            trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    }\n\n    memoryUsed +=\n        sizeof(used) +\n        sizeof(eccentricities) +\n        sizeof(diameter);\n\n    return diameter;\n};\n\nexport default {\n    name: \"Диаметр и переферийные вершины графа\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED | Criteria.CONNECTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const trace = [];\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const diameter = findDiameter(vertices, edges, adjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(diameter);\n\n        return {\n            trace,\n            statistics: [\n                `Диаметр графа: ${diameter}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet used = {};\nlet trace = [];\nlet topSortList = [];\nlet addedVertices = 0;\nlet sortedVertices = 0;\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList) => {\n    used[vertex] = true;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to = 0;\n    adjacencyList[vertex].forEach(toVertex => {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            dfs(to, adjacencyList);\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        }\n    });\n    trace.push({ vertex, hint: addedVertices++, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    topSortList.push(vertex);\n\n    memoryUsed += sizeof(to);\n};\n\nconst topSort = (vertices, edges, adjacencyList, trace) => {\n    used = {};\n    topSortList = [];\n    const isStartVertex = {};\n    vertices.forEach(vertex => {\n        used[vertex.name] = false;\n        isStartVertex[vertex.name] = true;\n    });\n    for (const {name: from} of vertices) {\n        adjacencyList[from].forEach(to => {\n            isStartVertex[to.name] = false;\n        });\n    }\n    addedVertices = 0;\n    sortedVertices = 0;\n\n    for (const {name: start} of vertices) {\n        if (isStartVertex[start]) {\n            dfs(start, adjacencyList);\n        }\n    }\n\n    for (const v of topSortList.reverse()) {\n        trace.push({ vertex: v, hint: sortedVertices++, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n        trace.push({ vertex: v, action: VertexAction.UNSELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(isStartVertex);\n};\n\nexport default {\n    name: \"Топологическая сортировка\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.ORIENTED | Criteria.ACYCLIC,\n\n    call: (vertices, edges) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        topSort(vertices, edges, adjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(used) +\n            sizeof(topSortList) +\n            sizeof(addedVertices) +\n            sizeof(sortedVertices);\n\n        return {\n            trace,\n            statistics: [\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet used = {};\nlet trace = [];\nlet timer = 0;\nlet tin = {}, tout = {};\nlet countBridges = 0;\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList, parent = -1) => {\n    used[vertex] = true;\n    tin[vertex] = tout[vertex] = timer++;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    for (const {name: to} of adjacencyList[vertex]) {\n        if (to === parent)\n            continue;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            dfs(to, adjacencyList, vertex);\n            tout[vertex] = Math.min(tout[vertex], tout[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (tout[to] > tin[vertex]) {\n                ++countBridges;\n                trace.push({ from: vertex, to, oriented: false, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        } else {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            tout[vertex] = Math.min(tout[vertex], tin[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    }\n\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n};\n\nconst findBridges = (vertices, edges, adjacencyList) => {\n    used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n    timer = 0;\n    tin = {};\n    tout = {};\n    countBridges = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start])\n            dfs(start, adjacencyList);\n    }\n};\n\nexport default {\n    name: \"Поиск мостов\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        findBridges(vertices, edges, adjacencyList);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList) +\n            sizeof(timer) +\n            sizeof(tin) +\n            sizeof(tout) +\n            sizeof(countBridges);\n\n        return {\n            trace,\n            statistics: [\n                `Количество мостов: ${countBridges}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet used = {};\nlet trace = [];\nlet timer = 0;\nlet tin = {}, tout = {};\nlet countArticulationPoints = 0;\nlet isArticulationPoint = {};\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList, parent = -1) => {\n    used[vertex] = true;\n    tin[vertex] = tout[vertex] = timer++;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n    let children = 0;\n\n    for (const {name: to} of adjacencyList[vertex]) {\n        if (to === parent)\n            continue;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            dfs(to, adjacencyList, vertex);\n            tout[vertex] = Math.min(tout[vertex], tout[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if ((tout[to] >= tin[vertex]) && (parent !== -1) && !isArticulationPoint[vertex]) {\n                ++countArticulationPoints;\n                isArticulationPoint[vertex] = true;\n                trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n            ++children;\n        } else {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            tout[vertex] = Math.min(tout[vertex], tin[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    }\n\n    if (!isArticulationPoint[vertex]) {\n        trace.push({vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION});\n\n        if ((parent === -1) && (children > 1)) {\n            trace.push({vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION});\n        }\n    }\n\n    memoryUsed += sizeof(children);\n};\n\nconst findArticulationPoints = (vertices, edges, adjacencyList) => {\n    used = {};\n    vertices.forEach(vertex => {\n        used[vertex.name] = false;\n        isArticulationPoint[vertex.name] = false;\n    });\n    timer = 0;\n    tin = {};\n    tout = {};\n    countArticulationPoints = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start])\n            dfs(start, adjacencyList);\n    }\n};\n\nexport default {\n    name: \"Поиск точек сочленения\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        findArticulationPoints(vertices, edges, adjacencyList);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList) +\n            sizeof(timer) +\n            sizeof(tin) +\n            sizeof(tout) +\n            sizeof(countArticulationPoints) +\n            sizeof(isArticulationPoint);\n\n        return {\n            trace,\n            statistics: [\n                `Количество точек сочленения: ${countArticulationPoints}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList, edgesListToReversedAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet used = {};\nlet trace = [];\nlet topSortList = [];\nlet addedVertices = 0;\nlet sortedVertices = 0;\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList) => {\n    used[vertex] = true;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to = 0;\n    adjacencyList[vertex].forEach(toVertex => {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            dfs(to, adjacencyList);\n            trace.push({ from: vertex, to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        }\n    });\n    trace.push({ vertex, hint: addedVertices++, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    topSortList.push(vertex);\n\n    memoryUsed += sizeof(to);\n};\n\nconst topSort = (vertices, edges, adjacencyList, trace) => {\n    used = {};\n    topSortList = [];\n    vertices.forEach(vertex => used[vertex.name] = false);\n    addedVertices = 0;\n    sortedVertices = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start]) {\n            dfs(start, adjacencyList);\n        }\n    }\n\n    for (const v of topSortList.reverse()) {\n        trace.push({ vertex: v, hint: sortedVertices++, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n        trace.push({ vertex: v, action: VertexAction.UNSELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n};\n\nconst findComponents = (vertices, edges, adjacencyList, trace) => {\n    for (const {from, to} of edges) {\n        trace.push({ from: from.name, to: to.name, oriented: true, action: EdgeAction.FLIP, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    }\n    trace[trace.length - 1].isChained = false;\n\n    vertices.forEach(vertex => used[vertex.name] = false);\n\n    let componentsNumber = 0;\n\n    const dfsComponents = (vertex) => {\n        used[vertex] = true;\n        trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ vertex, hint: componentsNumber, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION});\n\n        let to = 0;\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                trace.push({ from: vertex, to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                dfsComponents(to);\n                trace.push({ from: vertex, to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            }\n        });\n\n        trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n        memoryUsed += sizeof(to);\n    };\n\n    for (const v of topSortList) {\n        if (!used[v]) {\n            dfsComponents(v);\n            ++componentsNumber;\n        }\n    }\n\n    for (const {from, to} of edges) {\n        trace.push({ from: from.name, to: to.name, oriented: true, action: EdgeAction.FLIP, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    }\n\n    memoryUsed += sizeof(componentsNumber);\n\n    return componentsNumber;\n};\n\nexport default {\n    name: \"Конденсация графа (алгоритм Косарайю)\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.ORIENTED,\n\n    call: (vertices, edges) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        topSort(vertices, edges, adjacencyList, trace);\n        const componentsNumber = findComponents(vertices, edges, reversedAdjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(reversedAdjacencyList) +\n            sizeof(componentsNumber) +\n            sizeof(used) +\n            sizeof(topSortList) +\n            sizeof(addedVertices) +\n            sizeof(sortedVertices);\n\n        return {\n            trace,\n            statistics: [\n                `Количество компонент сильной связности: ${componentsNumber}`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList, edgesListToReversedAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet trace = [];\nlet memoryUsed = 0;\n\nconst checkForEuler = (vertices, edges, adjacencyList, trace) => {\n    let oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    memoryUsed += sizeof(oriented) + sizeof(reversedAdjacencyList);\n\n    if (!oriented) {\n\n        // Delete loops to prevent odd degrees\n        for (const {name: v} of vertices) {\n            adjacencyList[v] = adjacencyList[v].filter(toVertex => toVertex.name !== v);\n        }\n\n        let oddVertices = 0;\n        memoryUsed += sizeof(oddVertices);\n\n        for (const {name: v} of vertices) {\n            if (adjacencyList[v].length % 2 === 1) {\n                ++oddVertices;\n                if (oddVertices > 2) {\n                    trace.push({ vertex: v, hint: 1, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                    return false;\n                } else\n                    trace.push({ vertex: v, hint: 1, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    } else {\n        let outOddVertices = 0;\n        let inOddVertices = 0;\n        let degree = 0;\n        memoryUsed += sizeof(outOddVertices) + sizeof(inOddVertices) + sizeof(degree);\n\n        for (const {name: v} of vertices) {\n            degree = reversedAdjacencyList[v].length - adjacencyList[v].length;\n            if (degree === 1) {\n                ++outOddVertices;\n                if (outOddVertices > 1) {\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                    return false;\n                } else\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else if (degree === -1) {\n                ++inOddVertices;\n                if (outOddVertices > 1) {\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                    return false;\n                } else\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else if (degree !== 0) {\n                trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    }\n\n    const used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n    const dfs = (v) => {\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n        for (const {name: to} of adjacencyList[v]) {\n            if (!used[to]) {\n                trace.push({ from: v, to, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                dfs(to);\n            }\n        }\n        if (oriented) {\n            for (const {name: from} of reversedAdjacencyList[v]) {\n                if (!used[from]) {\n                    trace.push({ from, to: v, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                    dfs(from);\n                }\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    };\n\n    dfs(vertices[0].name);\n    memoryUsed += sizeof(used);\n\n    for (const {name: v} of vertices) {\n        if (!used[v]) {\n            if (adjacencyList[v].length > 0) {\n                trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: v, to: adjacencyList[v][0].name, oriented, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        }\n    }\n\n    return true;\n};\n\nconst findEulerPath = (vertices, edges, adjacencyList, trace) => {\n    const oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    let start = vertices[0].name;\n    for (const {name: v} of vertices) {\n        if (!oriented) {\n            if (adjacencyList[v].length % 2 === 1) {\n                start = v;\n                break;\n            }\n        } else {\n            if (reversedAdjacencyList[v].length - adjacencyList[v].length === 1) {\n                start = v;\n                break;\n            }\n        }\n    }\n    trace.push({ vertex: start, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    if (oriented)\n        adjacencyList = reversedAdjacencyList;\n\n    const currentVertices = [];\n    let pathLen = 0;\n    currentVertices.push(start);\n    let cur;\n    while (currentVertices.length > 0) {\n        cur = currentVertices[currentVertices.length - 1];\n        if (adjacencyList[cur].length > 0) {\n            currentVertices.push(adjacencyList[cur][0].name);\n            const to = adjacencyList[cur].shift().name;\n            if (!oriented) {\n                adjacencyList[to] = adjacencyList[to].filter(e => e.name !== cur);\n            }\n            trace.push({ from: cur, to, oriented: true, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n\n            memoryUsed += sizeof(to);\n        } else {\n            currentVertices.pop();\n            if (currentVertices.length > 0) {\n                if (pathLen === 0)\n                    trace.push({ vertex: cur, action: VertexAction.COLOR_1, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: cur, to: currentVertices[currentVertices.length - 1], oriented: true, weight: ++pathLen, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n    }\n\n    memoryUsed +=\n        sizeof(oriented) +\n        sizeof(reversedAdjacencyList) +\n        sizeof(start) +\n        sizeof(currentVertices) +\n        sizeof(pathLen) +\n        sizeof(cur);\n};\n\nexport default {\n    name: \"Эйлеров путь\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        let isEuler = checkForEuler(vertices, edges, Object.assign({}, adjacencyList), trace);\n        if (isEuler) {\n            trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n            trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            findEulerPath(vertices, edges, adjacencyList, trace);\n        }\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(isEuler);\n\n        return {\n            trace,\n            statistics: [\n                `Эйлеров путь ${isEuler ? '' : 'не'} существует`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList, edgesListToReversedAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\n\nlet trace = [];\nlet memoryUsed = 0;\n\nconst checkForEuler = (vertices, edges, adjacencyList, trace) => {\n    let oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    memoryUsed += sizeof(oriented) + sizeof(reversedAdjacencyList);\n\n    if (!oriented) {\n\n        // Delete loops to prevent odd degrees\n        for (const {name: v} of vertices) {\n            adjacencyList[v] = adjacencyList[v].filter(toVertex => toVertex.name !== v);\n        }\n\n        for (const {name: v} of vertices) {\n            if (adjacencyList[v].length % 2 === 1) {\n                trace.push({ vertex: v, hint: 1, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    } else {\n        let degree = 0;\n        memoryUsed += sizeof(degree);\n\n        for (const {name: v} of vertices) {\n            degree = reversedAdjacencyList[v].length - adjacencyList[v].length;\n            if (degree !== 0) {\n                trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    }\n\n    const used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n    const dfs = (v) => {\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n        for (const {name: to} of adjacencyList[v]) {\n            if (!used[to]) {\n                trace.push({ from: v, to, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                dfs(to);\n            }\n        }\n        if (oriented) {\n            for (const {name: from} of reversedAdjacencyList[v]) {\n                if (!used[from]) {\n                    trace.push({ from, to: v, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                    dfs(from);\n                }\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    };\n\n    dfs(vertices[0].name);\n    memoryUsed += sizeof(used);\n\n    for (const {name: v} of vertices) {\n        if (!used[v]) {\n            if (adjacencyList[v].length > 0) {\n                trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: v, to: adjacencyList[v][0].name, oriented, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        }\n    }\n\n    return true;\n};\n\nconst findEulerCycle = (vertices, edges, adjacencyList, trace) => {\n    const oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    let start = vertices[0].name;\n    trace.push({ vertex: start, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    if (oriented)\n        adjacencyList = reversedAdjacencyList;\n\n    const currentVertices = [];\n    let pathLen = 0;\n    currentVertices.push(start);\n    let cur = 0;\n    while (currentVertices.length > 0) {\n        cur = currentVertices[currentVertices.length - 1];\n        if (adjacencyList[cur].length > 0) {\n            currentVertices.push(adjacencyList[cur][0].name);\n            const to = adjacencyList[cur].shift().name;\n            if (!oriented) {\n                adjacencyList[to] = adjacencyList[to].filter(e => e.name !== cur);\n            }\n            trace.push({ from: cur, to, oriented: true, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n\n            memoryUsed += sizeof(to);\n        } else {\n            currentVertices.pop();\n            if (currentVertices.length > 0) {\n                if (pathLen === 0)\n                    trace.push({ vertex: cur, action: VertexAction.COLOR_1, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: cur, to: currentVertices[currentVertices.length - 1], oriented: true, weight: ++pathLen, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n    }\n\n    memoryUsed +=\n        sizeof(oriented) +\n        sizeof(reversedAdjacencyList) +\n        sizeof(start) +\n        sizeof(currentVertices) +\n        sizeof(pathLen) +\n        sizeof(cur);\n};\n\nexport default {\n    name: \"Эйлеров цикл\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        let isEuler = checkForEuler(vertices, edges, Object.assign({}, adjacencyList), trace);\n        if (isEuler) {\n            trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n            trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            findEulerCycle(vertices, edges, adjacencyList, trace);\n        }\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(isEuler);\n\n        return {\n            trace,\n            statistics: [\n                `Эйлеров цикл ${isEuler ? '' : 'не'} существует`,\n                `Время: ${duration.toFixed(4)}мс`,\n                `Кол-во операций: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ]\n        };\n    }\n};","export const ActionType = Object.freeze({\n    START_MATRIX_DIALOG_FOR_RESULT: 'START_MATRIX_DIALOG_FOR_RESULT',\n    CLOSE_MATRIX_DIALOG: 'CLOSE_MATRIX_DIALOG'\n});\n\nexport const startMatrixDialogForResult = () => ({\n    type: ActionType.START_MATRIX_DIALOG_FOR_RESULT\n});\n\nconst closeMatrixDialog = () => ({\n   type: ActionType.CLOSE_MATRIX_DIALOG\n});\n\nexport const cancelMatrixDialog = (onCancel) => (dispatch) => {\n    if (onCancel)\n        onCancel();\n    dispatch(closeMatrixDialog());\n};\n\nexport const submitMatrixDialog = (onSubmit, result) => (dispatch) => {\n    if (onSubmit)\n        onSubmit(result);\n    dispatch(closeMatrixDialog());\n};","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./Menu.module.scss\";\nimport Draggable from 'react-draggable';\nimport { ButtonComponent } from \"../Buttons/Buttons\";\nimport { SliderComponent } from \"../Sliders/Sliders\";\nimport { DropDownList } from \"../DropDownLists/DropDownLists\";\nimport {\n    changeGraphMode,\n    cleanGraphSelections,\n    closeMessage,\n    invertOrientation,\n    moveCanvas,\n    setGraph,\n    showMessage\n} from \"../../actions\";\nimport { connect } from \"react-redux\";\nimport { Graph, GraphMode, vertexRadius } from \"../Graph/Graph\";\nimport { RoundedToggleSwitch } from \"../ToggleSwitches/ToggleSwitches\";\nimport {\n    call,\n    clearStatistics,\n    clearTrace,\n    continueCall,\n    pause,\n    preCall,\n    setAlgorithm,\n    setSpeed\n} from \"../../actions/algorithm\";\nimport DFS from \"../../algorithms/graph/dfs\"\nimport BFS from \"../../algorithms/graph/bfs\"\nimport Dijkstra from \"../../algorithms/graph/dijkstra\"\nimport PrimMST from \"../../algorithms/graph/prim-mst\"\nimport KruskalMST from \"../../algorithms/graph/kruskal-mst\"\nimport CheckConnected from \"../../algorithms/graph/check-connected\"\nimport CheckBipartite from \"../../algorithms/graph/check-bipartite\"\nimport FindRadius from \"../../algorithms/graph/radius\"\nimport FindDiameter from \"../../algorithms/graph/diameter\"\nimport TopologicalSort from \"../../algorithms/graph/topological-sort\"\nimport FindBridges from \"../../algorithms/graph/find-bridges\"\nimport FindArticulationPoints from \"../../algorithms/graph/find-articulation-points\"\nimport SCCKosaraju from \"../../algorithms/graph/scc-kosaraju\"\nimport EulerPath from \"../../algorithms/graph/euler-path\"\nimport EulerCycle from \"../../algorithms/graph/euler-cycle\"\nimport { Vertex } from \"../Graph/Vertex/Vertex\";\nimport { Edge } from \"../Graph/Edge/Edge\";\nimport { startMatrixDialogForResult } from \"../../actions/matrixDialog\";\n\nconst cx = classnames.bind(styles);\n\nconst minAlgorithmSpeed = 0;\nconst maxAlgorithmSpeed = 1000;\n\nconst mapStateToProps = state => ({\n    graphMode: state.graphReducer.graphMode,\n    isOriented: state.graphReducer.graph.isOriented(),\n    isVisualizationActive: state.algorithmReducer.isActive,\n    visualizationSpeed: state.algorithmReducer.speed,\n    selectedAlgorithm: state.algorithmReducer.algorithm,\n    remainingAlgorithmSteps: state.algorithmReducer.trace.length,\n    graph: state.graphReducer.graph\n});\n\nclass MenuComponent extends React.Component {\n    state = {\n        algorithms: [\n            DFS,\n            BFS,\n            Dijkstra,\n            PrimMST,\n            KruskalMST,\n            CheckConnected,\n            CheckBipartite,\n            FindRadius,\n            FindDiameter,\n            TopologicalSort,\n            FindBridges,\n            FindArticulationPoints,\n            SCCKosaraju,\n            EulerPath,\n            EulerCycle\n        ],\n        algorithmPaused: false\n    };\n\n    componentDidMount() {\n        this.props.setAlgorithm(this.state.algorithms[0]);\n        this.props.setSpeed((minAlgorithmSpeed + maxAlgorithmSpeed) / 2);\n    }\n\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n        if (nextProps.graphMode !== this.props.graphMode)\n            return true;\n        if (nextProps.isOriented !== this.props.isOriented)\n            return true;\n        if (nextProps.isVisualizationActive !== this.props.isVisualizationActive)\n            return true;\n        if (nextProps.visualizationSpeed !== this.props.visualizationSpeed)\n            return true;\n        if (nextProps.selectedAlgorithm !== this.props.selectedAlgorithm)\n            return true;\n        if (nextProps.remainingAlgorithmSteps !== this.props.remainingAlgorithmSteps)\n            return true;\n        return false;\n    }\n\n    handleAlgorithmChange = e => {\n        this.clearVisualization();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n        this.props.closeMessage();\n\n        this.props.setAlgorithm(this.state.algorithms[e.target.value]);\n    };\n\n    startVisualization = () => {\n        if (this.props.remainingAlgorithmSteps === 0) {\n            this.props.clearTrace();\n            this.props.clearStatistics();\n            this.props.cleanGraphSelections();\n            this.props.preCall();\n        } else if (this.props.isVisualizationActive) {\n            this.props.pause();\n            this.setState({ algorithmPaused: true });\n        } else {\n            this.setState({ algorithmPaused: false });\n            this.props.continue();\n        }\n    };\n\n    stepVisualization = () => {\n        if (this.props.remainingAlgorithmSteps === 0) {\n            this.props.clearTrace();\n            this.props.clearStatistics();\n            this.props.cleanGraphSelections();\n            this.props.preCall(true);\n        } else {\n            this.setState({ algorithmPaused: false });\n            this.props.continue(true);\n        }\n    };\n\n    stopVisualization = () => {\n        this.clearVisualization();\n        this.props.closeMessage();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n    };\n\n    handleAlgorithmSpeedChange = e => {\n        this.props.setSpeed(maxAlgorithmSpeed - e.target.value);\n    };\n\n    askForAction = (message, graphMode) => {\n        this.clearVisualization();\n\n        this.props.showMessage(message);\n        this.props.changeGraphMode(graphMode);\n    };\n\n    closeMessage = () => {\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n        this.props.closeMessage();\n    };\n\n    invertOrientation = () => {\n        this.clearVisualization();\n\n        this.props.invertOrientation();\n    };\n\n    clearVisualization = () => {\n        this.props.pause();\n        this.setState({ algorithmPaused: false });\n        this.props.cleanGraphSelections();\n        this.props.clearTrace();\n        this.props.clearStatistics();\n    };\n\n    writeToFile = () => {\n        this.clearVisualization();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n\n        const json = JSON.stringify({\n            vertices: this.props.graph.vertices.map(v => ({\n                x: v.x,\n                y: v.y,\n                name: v.name\n            })),\n            edges: this.props.graph.edges.map(e => ({\n                from: e.from.name,\n                to: e.to.name,\n                weight: e.weight\n            })),\n            oriented: this.props.isOriented\n        });\n\n        const exportData = \"data:text/json;charset=utf-8,\" + escape(json);\n        const anchorElement = document.getElementById(\"fileSave\");\n        anchorElement.setAttribute(\"href\", exportData);\n        anchorElement.setAttribute(\"download\", \"graph.json\");\n        anchorElement.click();\n    };\n\n    askReadFromFile = () => {\n        this.clearVisualization();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n\n        document.getElementById(\"fileLoad\").click();\n    };\n\n    readFromFile = (e) => {\n        const reader = new FileReader();\n        const file = e.target.files[0];\n\n        reader.onload = (e) => {\n            try {\n                const json = JSON.parse(e.target.result);\n\n                const oriented = json.oriented;\n                const vertices = json.vertices.map(v => new Vertex(v.x, v.y, vertexRadius, v.name));\n                const edges = json.edges.map(e =>\n                    new Edge(\n                        vertices.find(v => v.name === e.from),\n                        vertices.find(v => v.name === e.to),\n                        oriented,\n                        e.weight\n                    )\n                );\n\n                const graph = new Graph(oriented, vertices, edges);\n\n                if (oriented !== this.props.isOriented)\n                    this.invertOrientation();\n                this.props.setGraph(graph);\n                this.props.resetCanvasPosition();\n            } catch (e) {\n                this.props.showMessage(\"Некорректный формат файла\");\n            }\n        };\n\n        reader.readAsText(file);\n        document.getElementById(\"fileLoad\").value = null;\n    };\n\n    showAdjacencyMatrix = () => {\n        this.props.startMatrixDialog();\n    };\n\n    render() {\n        return (\n            <Draggable grid={[4, 4]} bounds={\"body\"} cancel={[\"button\", \"input\", \"select\"]}>\n                <div className={cx(\"menu\")}>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"graph-control-buttons\")}>\n                            <ButtonComponent\n                                text={\"Режим просмотра\"}\n                                onClick={() => this.closeMessage()}\n                                activated={this.props.graphMode === GraphMode.DEFAULT}/>\n                            <ButtonComponent\n                                text={\"Добавить вершину\"}\n                                onClick={() => this.askForAction(\"Выберите точку для добавления вершины\", GraphMode.ADD_VERTEX)}\n                                activated={this.props.graphMode === GraphMode.ADD_VERTEX}/>\n                            <ButtonComponent\n                                text={\"Добавить ребро\"}\n                                onClick={() => this.askForAction(\"Выберите вершины, которые нужно соединить ребром\", GraphMode.ADD_EDGE)}\n                                activated={this.props.graphMode === GraphMode.ADD_EDGE}/>\n                            <ButtonComponent\n                                text={\"Удалить вершину/ребро\"}\n                                onClick={() => this.askForAction(\"Выберите объект для удаления\", GraphMode.REMOVE_VERTEX_OR_EDGE)}\n                                activated={this.props.graphMode === GraphMode.REMOVE_VERTEX_OR_EDGE}/>\n                        </div>\n                        <RoundedToggleSwitch\n                            className={cx(\"switch\")}\n                            text={\"Ориентированный?\"}\n                            onChange={() => this.invertOrientation()}\n                            isChecked={this.props.isOriented}/>\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"algorithms-list\")}>\n                            <DropDownList\n                                items={this.state.algorithms.map(a => a.name)}\n                                onChange={this.handleAlgorithmChange}/>\n                        </div>\n                        <div className={cx(\"slider\")}>\n                            <SliderComponent\n                                label={\"Скорость анимации\"}\n                                value={maxAlgorithmSpeed - this.props.visualizationSpeed}\n                                min={minAlgorithmSpeed}\n                                max={maxAlgorithmSpeed}\n                                onChange={this.handleAlgorithmSpeedChange}/>\n                        </div>\n                        <div className={cx(\"visualization-control-buttons\")}>\n                            <ButtonComponent\n                                text={this.state.algorithmPaused ? \"Далее\" : (this.props.isVisualizationActive ? \"Пауза\" : \"Старт\")}\n                                onClick={this.startVisualization}/>\n                            <ButtonComponent text={\"Шаг\"} onClick={this.stepVisualization}/>\n                            <ButtonComponent text={\"Стоп\"} onClick={this.stopVisualization}/>\n                        </div>\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"file-control-buttons\")}>\n                            <ButtonComponent\n                                text={\"Сохранить\"}\n                                onClick={() => this.writeToFile()}\n                                activated={false}/>\n                            <a id=\"fileSave\" style={{\"display\": \"none\"}} aria-hidden={true} href=\"/#\">Save graph</a>\n\n                            <ButtonComponent\n                                text={\"Загрузить\"}\n                                onClick={() => this.askReadFromFile()}\n                                activated={false}/>\n                            <input id=\"fileLoad\" type=\"file\" accept=\".json\" style={{\"display\": \"none\"}} onChange={(e) => this.readFromFile(e)}/>\n                        </div>\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"matrix-control-buttons\")}>\n                            <ButtonComponent\n                                text={\"Матрица смежности\"}\n                                onClick={() => this.showAdjacencyMatrix()}\n                                activated={false}/>\n                        </div>\n                    </div>\n                </div>\n            </Draggable>\n        );\n    }\n}\n\nconst mapDispatchToProps = dispatch => ({\n    changeGraphMode: (graphMode) => dispatch(changeGraphMode(graphMode)),\n    showMessage: (message) => dispatch(showMessage(message)),\n    closeMessage: () => dispatch(closeMessage()),\n    invertOrientation: () => dispatch(invertOrientation()),\n    setAlgorithm: (algorithm) => dispatch(setAlgorithm(algorithm)),\n    setSpeed: (speed) => dispatch(setSpeed(speed)),\n    preCall: (isOneStep) => dispatch(preCall(isOneStep)),\n    call: () => dispatch(call()),\n    pause: () => dispatch(pause()),\n    continue: (isOneStep) => dispatch(continueCall(isOneStep)),\n    cleanGraphSelections: () => dispatch(cleanGraphSelections()),\n    clearTrace: () => dispatch(clearTrace()),\n    clearStatistics: () => dispatch(clearStatistics()),\n    setGraph: (graph) => dispatch(setGraph(graph)),\n    startMatrixDialog: () => dispatch(startMatrixDialogForResult()),\n    resetCanvasPosition: () => dispatch(moveCanvas(0, 0))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MenuComponent);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./MessageBox.module.scss\";\nimport { connect } from \"react-redux\";\n\nconst cx = classnames.bind(styles);\n\nconst mapStateToProps = state => ({\n    message: state.graphReducer.message,\n    isAlert: state.graphReducer.isAlert\n});\n\nconst MessageBox = ({ message, isAlert }) => {\n    return (\n        <div className={cx(\"message-box\", {[`invisible`]: message === undefined}, {[`alert`]: isAlert})}>\n            {message}\n        </div>\n    );\n};\n\nexport default connect(mapStateToProps)(MessageBox);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./TextInputs.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const TextInputComponent = ({ value, placeholder, onChange, pattern, className, autoFocus = false }) => {\n    return (\n        <input\n            className={cx(\"text-input\", className)}\n            type=\"text\"\n            pattern={pattern}\n            value={value}\n            onChange={onChange}\n            placeholder={placeholder}\n            autoFocus={autoFocus}/>\n    );\n};","import Modal from \"react-modal\";\nimport React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./InputDialog.module.scss\";\nimport { cancelDialog, submitDialog } from \"../../../actions/dialog\";\nimport { connect } from \"react-redux\";\nimport { ButtonComponent } from \"../../Buttons/Buttons\";\nimport { TextInputComponent } from \"../../TextInputs/TextInputs\";\n\nconst cx = classnames.bind(styles);\n\nconst customStyles = {\n    overlay: {zIndex: 100000}\n};\n\nconst mapStateToProps = state => ({\n    isOpen: state.dialogReducer.isOpen,\n    title: state.dialogReducer.title,\n    text: state.dialogReducer.text,\n    hint: state.dialogReducer.hint,\n    inputPlaceholder: state.dialogReducer.inputPlaceholder,\n    pattern: state.dialogReducer.pattern,\n    onSubmit: state.dialogReducer.onSubmit,\n    onCancel: state.dialogReducer.onCancel\n});\n\nclass InputDialog extends React.Component {\n    state = {\n        value: \"\"\n    };\n\n    handleChange = (e) => {\n        if (e.target.validity.valid)\n            this.setState({ value: e.target.value });\n    };\n\n    submit = (e) => {\n        e.preventDefault();\n        this.setState({ value: \"\" });\n        this.props.submitDialog(this.props.onSubmit, this.state.value);\n    };\n\n    cancel = () => {\n        this.setState({ value: \"\" });\n        this.props.cancelDialog(this.props.onCancel);\n    };\n\n    render() {\n        return (\n            <Modal\n                isOpen={this.props.isOpen}\n                onRequestClose={() => {\n                    this.setState({ value: \"\" });\n                    this.props.cancelDialog(this.props.onCancel);\n                }}\n                ariaHideApp={false}\n                className={cx(\"input-dialog\")}\n                style={customStyles}>\n\n                <h2>{this.props.title}</h2>\n                <div className={cx(\"text\")}>{this.props.text}</div>\n                <form onSubmit={(e) => this.submit(e)}>\n                    <TextInputComponent\n                        autoFocus={true}\n                        className={cx(\"text-input\")}\n                        placeholder={this.props.inputPlaceholder}\n                        pattern={this.props.pattern}\n                        onChange={this.handleChange}\n                        value={this.state.value}/>\n\n                    <ButtonComponent\n                        type={\"submit\"}\n                        className={cx(\"button\")}\n                        text={\"Ок\"}\n                        onClick={(e) => this.submit(e)}/>\n                    <ButtonComponent\n                        className={cx(\"button\")}\n                        text={\"Отмена\"}\n                        onClick={() => this.cancel()}/>\n                </form>\n\n                <div className={cx(\"hint\")}>{this.props.hint}</div>\n            </Modal>\n        );\n    }\n}\n\nconst mapDispatchToProps = dispatch => ({\n    submitDialog: (onSubmit, result) => dispatch(submitDialog(onSubmit, result)),\n    cancelDialog: (onCancel) => dispatch(cancelDialog(onCancel))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(InputDialog);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./InfoBox.module.scss\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\n\nconst cx = classnames.bind(styles);\n\nconst mapStateToProps = state => ({\n    lines: state.algorithmReducer.statistics,\n    isVisible: state.algorithmReducer.isStatisticsShown\n});\n\nconst InfoBox = ({ lines, isVisible }) => {\n    return (\n        <div className={cx(\"info-box\", {[`invisible`]: !(isVisible && Array.isArray(lines) && lines.length)})}>\n            {lines.map((line, index) => <div className={cx(\"text\")} key={index}>{line}</div>)}\n        </div>\n    );\n};\n\nInfoBox.propTypes = {\n    lines: PropTypes.arrayOf(PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.number,\n        PropTypes.symbol,\n        PropTypes.bool\n    ])),\n    isVisible: PropTypes.bool\n};\n\nexport default connect(mapStateToProps)(InfoBox);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./AdjacencyMatrix.module.scss\";\nimport { edgesListToAdjacencyMatrix } from \"../../../utils/graphConverter\";\n\nconst cx = classnames.bind(styles);\n\nconst MatrixCell = ({ cell, topLeft, topRight, bottomLeft, bottomRight, onClick }) => {\n    return (\n        <div className={cx(\"matrix-cell\", {[`empty`]: !cell},\n            {[`non-weighted`]: cell && !cell.weighted},\n            {[`top-left-cell`]: topLeft},\n            {[`top-right-cell`]: topRight},\n            {[`bottom-left-cell`]: bottomLeft},\n            {[`bottom-right-cell`]: bottomRight})}\n            onClick={onClick}\n            onContextMenu={onClick}>\n            {cell ? (cell.weighted ? cell.weight : \"+\") : \"X\"}\n        </div>\n    );\n};\n\nconst MatrixRow = ({ row, first, last, vertexNumber, onCellClick }) => {\n    return (\n        <div className={cx(\"matrix-row\")}>\n            <div className={cx(\"label-cell\")}>{vertexNumber}</div>\n            {row.map((cell, index) =>\n                <MatrixCell\n                    key={index}\n                    cell={cell}\n                    topLeft={(index === 0) && first}\n                    topRight={(index + 1 === row.length) && first}\n                    bottomLeft={(index === 0) && last}\n                    bottomRight={(index + 1 === row.length) && last}\n                    onClick={(e) => onCellClick(e, index)}/>)\n            }\n        </div>\n    );\n};\n\nconst AdjacencyMatrix = ({ graph, onCellClick }) => {\n    const {adjacencyMatrix, verticesNumbers} = edgesListToAdjacencyMatrix(graph.vertices, graph.edges);\n    return (\n        <div className={cx(\"matrix\")}>\n            <div className={cx(\"label-cell\")}>{\" \"}</div>\n            {verticesNumbers.map(v => <div key={v} className={cx(\"label-cell\")}>{v}</div>)}\n            {adjacencyMatrix.map((row, index) =>\n                <MatrixRow\n                    key={index}\n                    row={row}\n                    first={index === 0}\n                    last={index + 1 === graph.vertices.length}\n                    vertexNumber={verticesNumbers[index]}\n                    onCellClick={(e, column) => onCellClick(e, verticesNumbers[index], verticesNumbers[column])}/>)\n            }\n        </div>\n    );\n};\n\nexport default AdjacencyMatrix;","import Modal from \"react-modal\";\nimport React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./MatrixDialog.module.scss\";\nimport { connect } from \"react-redux\";\nimport { ButtonComponent } from \"../../Buttons/Buttons\";\nimport { edgesListToAdjacencyMatrix } from \"../../../utils/graphConverter\";\nimport { cancelMatrixDialog, submitMatrixDialog } from \"../../../actions/matrixDialog\";\nimport AdjacencyMatrix from \"./AdjacencyMatrix\";\nimport { startDialogForResult } from \"../../../actions/dialog\";\nimport { addEdge, removeEdge } from \"../../../actions\";\n\nconst cx = classnames.bind(styles);\n\nconst customStyles = {\n    overlay: {zIndex: 99999}\n};\n\nconst mapStateToProps = state => ({\n    isOpen: state.matrixDialogReducer.isOpen,\n    graph: state.graphReducer.graph\n});\n\nclass MatrixDialog extends React.Component {\n\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n        if (!this.props.isOpen && !nextProps.isOpen)\n            return false;\n        return true;\n    }\n\n    writeToFile = () => {\n        if (this.props.graph.vertices.length === 0)\n            return;\n\n        let {adjacencyMatrix} = edgesListToAdjacencyMatrix(this.props.graph.vertices, this.props.graph.edges);\n\n        adjacencyMatrix = adjacencyMatrix.map(row => row.map(cell => cell ? (cell.weighted ? cell.weight : \"+\") : \"X\"));\n        adjacencyMatrix = adjacencyMatrix.reduce((prev, arr) => prev + arr.reduce((line, cell) => line + cell + \" \", \"\") + \"\\n\", \"\");\n\n        const exportData = \"data:text/plain;charset=utf-8,\" + escape(adjacencyMatrix);\n        const anchorElement = document.getElementById(\"fileSave\");\n        anchorElement.setAttribute(\"href\", exportData);\n        anchorElement.setAttribute(\"download\", \"adjacencyMatrix.txt\");\n        anchorElement.click();\n    };\n\n    cancel = () => {\n        this.props.cancelDialog(null);\n    };\n\n    handleCellClick = (e, from, to) => {\n        const vertexFrom = this.props.graph.vertices.find(v => v.name === from);\n        const vertexTo = this.props.graph.vertices.find(v => v.name === to);\n\n        if (e.type === \"click\") {\n            if (vertexFrom && vertexTo) {\n                this.props.startDialogForResult(\n                    \"Введите вес ребра\",\n                    `(${from} ${this.props.graph.isOriented() ? '->' : '<->'} ${to})`,\n                    \"Оставьте поле пустым, чтобы добавить невзвешенное ребро\",\n                    \"Вес ребра\",\n                    (value) => {\n                        if (value === \"\")\n                            value = undefined;\n                        this.props.addEdge(vertexFrom, vertexTo, value);\n                    },\n                    null,\n                    \"[0-9]{0,2}\"\n                );\n            }\n        } else if (e.type === \"contextmenu\") {\n            e.preventDefault();\n\n            const edgeIndex = this.props.graph.findEdge(vertexFrom, vertexTo);\n            if (edgeIndex !== -1)\n                this.props.removeEdge(this.props.graph.edges[edgeIndex]);\n        }\n    };\n\n    render() {\n        return (\n            <Modal\n                isOpen={this.props.isOpen}\n                onRequestClose={() => this.cancel()}\n                ariaHideApp={false}\n                className={cx(\"matrix-dialog\")}\n                style={customStyles}>\n\n                {\n                    this.props.graph.vertices.length > 0 ?\n                        <div>\n                            <AdjacencyMatrix graph={this.props.graph} onCellClick={this.handleCellClick}/>\n                            <div>ЛКМ - добавить ребро, ПКМ - удалить ребро</div>\n                        </div>\n                    :\n                        <div style={{\"margin\": \"20px\", \"font-size\": \"1.2em\"}}>Добавьте хотя бы одну вершину</div>\n                }\n\n                <ButtonComponent\n                    type={\"submit\"}\n                    className={cx(\"button\", {[`deactivated-button`]: this.props.graph.vertices.length === 0})}\n                    text={\"Сохранить в файл\"}\n                    onClick={() => this.writeToFile()}/>\n                <a id=\"fileSave\" style={{\"display\": \"none\"}} aria-hidden={true} href=\"/#\">Save matrix</a>\n\n                <ButtonComponent\n                    className={cx(\"button\")}\n                    text={\"Закрыть\"}\n                    onClick={() => this.cancel()}/>\n            </Modal>\n        );\n    }\n}\n\nconst mapDispatchToProps = dispatch => ({\n    submitDialog: (onSubmit, result) => dispatch(submitMatrixDialog(onSubmit, result)),\n    cancelDialog: (onCancel) => dispatch(cancelMatrixDialog(onCancel)),\n    addEdge: (vertexFrom, vertexTo, weight) => dispatch(addEdge(vertexFrom, vertexTo, weight)),\n    removeEdge: (edge) => dispatch(removeEdge(edge)),\n    startDialogForResult: (title, text, hint, inputPlaceholder, onSubmit, onClose, pattern) =>\n        dispatch(startDialogForResult(title, text, hint, inputPlaceholder, onSubmit, onClose, pattern))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MatrixDialog);","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./App.module.scss\";\nimport PlainGraph from \"./PlainGraph/PlainGraph\";\nimport GraphComponent from \"./Graph/Graph\";\nimport MenuComponent from \"./Menu/Menu\";\nimport MessageBox from \"./MessageBox/MessageBox\";\nimport InputDialog from \"./Dialogs/InputDialog/InputDialog\";\nimport InfoBox from \"./InfoBox/InfoBox\";\nimport MatrixDialog from \"./Dialogs/MatrixDialog/MatrixDialog\";\n\nconst cx = classnames.bind(styles);\n\nconst App = () => (\n    <div className={cx(\"app\")}>\n        <MenuComponent/>\n        <GraphComponent/>\n        <MessageBox/>\n        <InfoBox/>\n        <InputDialog/>\n        <MatrixDialog/>\n    </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ActionType } from \"../actions/dialog\";\nimport React from \"react\";\n\nconst defaultState = {\n    isOpen: false,\n    title: \"\",\n    text: \"\",\n    hint: \"\",\n    inputPlaceholder: \"\",\n    onSubmit: null,\n    onClose: null,\n    pattern: \".*\"\n};\n\nconst dialog = (state = defaultState, action) => {\n    let newState;\n    switch (action.type) {\n        case ActionType.START_DIALOG_FOR_RESULT:\n            newState = {\n                ...state,\n                isOpen: true,\n                title: action.title,\n                text: action.text,\n                hint: action.hint,\n                inputPlaceholder: action.inputPlaceholder,\n                pattern: action.pattern\n            };\n\n            newState.onSubmit = (value) => {\n                const onSubmit = action.onSubmit;\n                if (onSubmit)\n                    onSubmit(value);\n            };\n            newState.onCancel = () => {\n                const onCancel = action.onCancel;\n                if (onCancel)\n                    onCancel();\n            };\n\n            return newState;\n        case ActionType.CLOSE_DIALOG:\n            return defaultState;\n        default:\n            return state;\n    }\n};\n\nexport default dialog;","import { ActionType } from \"../actions/algorithm\";\nimport React from \"react\";\nimport { PreCallAction } from \"../algorithms/graph/index\";\n\nconst defaultState = {\n    trace: [],\n    isActive: false,\n    algorithm: null,\n    speed: 1000,\n    isOneStep: false,\n    statistics: [],\n    isStatisticsShown: false\n};\n\nconst algorithm = (state = defaultState, action) => {\n    let newState;\n    switch (action.type) {\n        case ActionType.CALL:\n            newState = {\n                ...state\n            };\n\n            const preCall = state.algorithm.preCall;\n            const vertices = action.graph.vertices;\n            const edges = action.graph.edges;\n            let result;\n            if (preCall === PreCallAction.SELECT_VERTEX) {\n                result = state.algorithm.call(vertices, edges, action.vertex);\n            } else if (preCall === PreCallAction.SELECT_EDGE) {\n                result = state.algorithm.call(vertices, edges, action.edge);\n            } else if (preCall === PreCallAction.NOTHING) {\n                result = state.algorithm.call(vertices, edges);\n            }\n            newState.trace = result.trace;\n            newState.statistics = result.statistics;\n\n            return newState;\n        case ActionType.POP_TRACE_STEP:\n            newState = {\n                ...state,\n                trace: [...state.trace]\n            };\n\n            newState.trace.shift();\n\n            return newState;\n        case ActionType.START:\n            return {\n                ...state,\n                isActive: true\n            };\n        case ActionType.PAUSE:\n            return {\n                ...state,\n                isActive: false\n            };\n        case ActionType.SET_ALGORITHM:\n            return {\n                ...state,\n                algorithm: action.algorithm\n            };\n        case ActionType.SET_SPEED:\n            return {\n                ...state,\n                speed: action.speed\n            };\n        case ActionType.SET_IS_ONE_STEP:\n            return {\n                ...state,\n                isOneStep: action.isOneStep\n            };\n        case ActionType.CLEAR_TRACE:\n            return {\n                ...state,\n                trace: []\n            };\n        case ActionType.SHOW_STATISTICS:\n            return {\n                ...state,\n                isStatisticsShown: true\n            };\n        case ActionType.CLEAR_STATISTICS:\n            return {\n                ...state,\n                statistics: [],\n                isStatisticsShown: false\n            };\n        default:\n            return state;\n    }\n};\n\nexport default algorithm;","import { ActionType } from \"../actions/matrixDialog\";\nimport React from \"react\";\n\nconst defaultState = {\n    isOpen: false\n};\n\nconst matrixDialog = (state = defaultState, action) => {\n    switch (action.type) {\n        case ActionType.START_MATRIX_DIALOG_FOR_RESULT:\n            return {\n                ...state,\n                isOpen: true\n            };\n        case ActionType.CLOSE_MATRIX_DIALOG:\n            return defaultState;\n        default:\n            return state;\n    }\n};\n\nexport default matrixDialog;","import { Graph, GraphMode } from \"../components/Graph/Graph\";\nimport { ActionType } from \"../actions\";\nimport { VertexHintState, VertexState } from \"../components/Graph/Vertex/Vertex\";\nimport { combineReducers } from \"redux\";\nimport dialog from \"./dialog\";\nimport algorithm from \"./algorithm\";\nimport matrixDialog from \"./matrixDialog\";\nimport { AlgorithmActionType, EdgeAction, VertexAction, VertexHintAction } from \"../algorithms/graph\";\nimport { EdgeState } from \"../components/Graph/Edge/Edge\";\n\nconst defaultState = {\n    graph: new Graph(false),\n    message: undefined,\n    isAlert: false,\n    graphMode: GraphMode.DEFAULT,\n    selectedVertex: undefined, // For 'ADD_EDGE' // TODO: Do 'ADD_EDGE' in a cleaner way\n    canvasX: 0,\n    canvasY: 0\n};\n\nconst clone = object => {\n    return Object.assign( Object.create( Object.getPrototypeOf(object)), object);\n};\n\nconst unselectSelectedVertex = (state) => {\n    if (state.selectedVertex !== undefined) {\n        const i = state.graph.vertices.findIndex(v => v === state.selectedVertex);\n        if (i !== -1)\n            state.graph.vertices[i].state = VertexState.DEFAULT;\n        state.selectedVertex = undefined;\n    }\n};\n\nconst updateVertexByAction = (vertex, action) => {\n    switch (action) {\n        case VertexAction.SELECT:\n            vertex.state = VertexState.HIGHLIGHTED;\n            break;\n        case VertexAction.ENTER:\n            vertex.state = VertexState.PRE_COMPLETED;\n            break;\n        case VertexAction.EXIT:\n            vertex.state = VertexState.COMPLETED;\n            break;\n        case VertexAction.UNSELECT:\n            vertex.state = VertexState.DEFAULT;\n            break;\n        case VertexAction.COLOR_1:\n            vertex.state = VertexState.COLOR_1;\n            break;\n        case VertexAction.COLOR_2:\n            vertex.state = VertexState.COLOR_2;\n            break;\n        default:\n    }\n};\n\nconst updateEdgeByAction = (edge, action) => {\n    switch (action) {\n        case EdgeAction.WALK:\n            edge.state = EdgeState.WALKED;\n            break;\n        case EdgeAction.HIGHLIGHT:\n            edge.state = EdgeState.HIGHLIGHTED;\n            break;\n        case EdgeAction.SHADOW:\n            edge.state = EdgeState.SHADOWED;\n            break;\n        default:\n    }\n};\n\nconst updateVertexHintByAction = (vertex, action) => {\n    switch (action) {\n        case VertexHintAction.REMOVE:\n            vertex.hintState = VertexHintState.CLEAR;\n            break;\n        case VertexHintAction.SET:\n            vertex.hintState = VertexHintState.DEFAULT;\n            break;\n        case VertexHintAction.HIGHLIGHT:\n            vertex.hintState = VertexHintState.HIGHLIGHTED;\n            break;\n        default:\n    }\n};\n\nconst cleanGraphSelections = (state) => {\n    state.graph.vertices.forEach(v => {\n        v.state = VertexState.DEFAULT;\n        v.hintState = VertexHintState.CLEAR;\n        v.hint = \"\";\n    });\n    state.graph.edges.forEach(e => e.state = EdgeState.DEFAULT);\n    state.graph.visualizationEdges = [];\n    state.selectedVertex = undefined;\n};\n\nconst reducer = (state = defaultState, action) => {\n    let newState;\n    let i;\n    switch (action.type) {\n        case ActionType.ADD_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.addVertex(action.x, action.y, action.radius);\n\n            return newState;\n        case ActionType.ADD_EDGE:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.addEdge(action.vertexFrom, action.vertexTo, action.weight);\n\n            return newState;\n        case ActionType.REMOVE_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.removeVertex(action.vertex);\n\n            return newState;\n        case ActionType.REMOVE_EDGE:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.removeEdge(action.edge);\n\n            return newState;\n        case ActionType.UPDATE_VERTEX_POSITION:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.vertices[action.vertexIndex].x = action.x;\n            newState.graph.vertices[action.vertexIndex].y = action.y;\n\n            return newState;\n        case ActionType.CHANGE_GRAPH_MODE:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            if (action.graphMode !== newState.graphMode) {\n                newState.graphMode = action.graphMode;\n\n                unselectSelectedVertex(newState);\n            }\n\n            return newState;\n        case ActionType.SELECT_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            unselectSelectedVertex(newState);\n\n            i = newState.graph.vertices.findIndex(v => v === action.vertex);\n            if (i !== -1) {\n                newState.graph.vertices[i].state = VertexState.HIGHLIGHTED;\n                newState.selectedVertex = action.vertex;\n            }\n\n            return newState;\n        case ActionType.UNSELECT_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            unselectSelectedVertex(newState);\n\n            return newState;\n        case ActionType.SHOW_MESSAGE:\n            return {\n                ...state,\n                message: action.message,\n                isAlert: action.isAlert\n            };\n        case ActionType.CLOSE_MESSAGE:\n            return {\n                ...state,\n                message: undefined,\n                isAlert: false\n            };\n        case ActionType.INVERT_ORIENTATION:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.invertOrientation();\n\n            return newState;\n        case ActionType.ALGORITHM_STEP:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            const step = action.step;\n            if (step.actionType === AlgorithmActionType.VERTEX_ACTION) {\n                if (step.action === VertexAction.CLEAR_ALL_SELECTIONS) {\n                    newState.graph.vertices.forEach(v => v.state = VertexState.DEFAULT);\n                } else {\n                    const vertex = newState.graph.vertices.find(v => v.name === step.vertex);\n                    if (vertex)\n                        updateVertexByAction(vertex, step.action);\n                }\n            } else if (step.actionType === AlgorithmActionType.EDGE_ACTION) {\n                if (step.action === EdgeAction.CLEAR_ALL_SELECTIONS) {\n                    newState.graph.visualizationEdges = [];\n                } else if (step.action === EdgeAction.FLIP) {\n                    const vertexFrom = newState.graph.vertices.find(v => v.name === step.from);\n                    const vertexTo = newState.graph.vertices.find(v => v.name === step.to);\n                    const edge = newState.graph.findEdge(vertexFrom, vertexTo);\n                    if (edge !== -1) {\n                        if (newState.graph.edges[edge].state === EdgeState.FLIPPED)\n                            newState.graph.edges[edge].state = EdgeState.DEFAULT;\n                        else\n                            newState.graph.edges[edge].state = EdgeState.FLIPPED;\n                    }\n                } else {\n                    const vertexFrom = newState.graph.vertices.find(v => v.name === step.from);\n                    const vertexTo = newState.graph.vertices.find(v => v.name === step.to);\n                    if (step.action === EdgeAction.UNSELECT) {\n                        newState.graph.removeVisualizationEdgeByVertices(vertexFrom, vertexTo, step.oriented);\n                    } else {\n                        const edge = newState.graph.addVisualizationEdge(vertexFrom, vertexTo, step.oriented, step.weight);\n                        updateEdgeByAction(edge, step.action);\n                    }\n                }\n            } else if (step.actionType === AlgorithmActionType.VERTEX_HINT_ACTION) {\n                const vertex = newState.graph.vertices.find(v => v.name === step.vertex);\n                if (vertex) {\n                    if (step.action === VertexHintAction.REMOVE)\n                        vertex.hint = \"\";\n                    else\n                        vertex.hint = step.hint;\n                    updateVertexHintByAction(vertex, step.action);\n                }\n            }\n\n            return newState;\n        case ActionType.CLEAN_GRAPH_SELECTIONS:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            cleanGraphSelections(newState);\n\n            return newState;\n        case ActionType.SET_GRAPH:\n            return {\n                ...state,\n                graph: action.graph\n            };\n        case ActionType.MOVE_CANVAS:\n            return {\n                ...state,\n                canvasX: action.x,\n                canvasY: action.y\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    graphReducer: reducer,\n    dialogReducer: dialog,\n    algorithmReducer: algorithm,\n    matrixDialogReducer: matrixDialog\n});","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from \"react-redux\";\nimport { applyMiddleware, createStore } from \"redux\";\nimport rootReducer from \"./reducers/index\";\nimport thunk from \"redux-thunk\";\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__2at_H\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"plain_graph\":\"PlainGraph_plain_graph__132cd\",\"drawing_area\":\"PlainGraph_drawing_area__poiJd\",\"cell\":\"PlainGraph_cell__2tDfs\",\"cell-blocked\":\"PlainGraph_cell-blocked__13I9p\",\"cell-path\":\"PlainGraph_cell-path__1JSUa\",\"cell-start\":\"PlainGraph_cell-start__2FTb6\",\"cell-finish\":\"PlainGraph_cell-finish__2icJo\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"menu\":\"Menu_menu__2xbQm\",\"menu-sub\":\"Menu_menu-sub__2jhA1\",\"graph-control-buttons\":\"Menu_graph-control-buttons__2CY62\",\"switch\":\"Menu_switch__3Y97k\",\"visualization-control-buttons\":\"Menu_visualization-control-buttons__1OTXW\",\"file-control-buttons\":\"Menu_file-control-buttons__3PmTU\",\"algorithms-list\":\"Menu_algorithms-list__2mwx1\",\"slider\":\"Menu_slider__RA1Ez\",\"matrix-control-buttons\":\"Menu_matrix-control-buttons__26fCf\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Buttons_button__1L6GG\",\"activated\":\"Buttons_activated__EZOmF\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"slider-wrapper\":\"Sliders_slider-wrapper__GIw-8\",\"slider-label\":\"Sliders_slider-label__1w08l\",\"slider\":\"Sliders_slider__1gqJy\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"drop-down-list\":\"DropDownLists_drop-down-list__ix94o\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"switch-round-wrapper\":\"ToggleSwitches_switch-round-wrapper__g2bxh\",\"switch-round\":\"ToggleSwitches_switch-round__1bQ1T\",\"slider\":\"ToggleSwitches_slider__Q-bUA\",\"text\":\"ToggleSwitches_text__1sKta\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"message-box\":\"MessageBox_message-box__2uEgD\",\"invisible\":\"MessageBox_invisible__10Wwp\",\"alert\":\"MessageBox_alert__14QTT\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"input-dialog\":\"InputDialog_input-dialog__2SLyF\",\"text-input\":\"InputDialog_text-input__2zjdU\",\"button\":\"InputDialog_button__1ZFHJ\",\"text\":\"InputDialog_text__2HUnn\",\"hint\":\"InputDialog_hint__1ftkv\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"text-input\":\"TextInputs_text-input__3mPdK\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"info-box\":\"InfoBox_info-box__3t_A2\",\"text\":\"InfoBox_text__sgPCj\",\"invisible\":\"InfoBox_invisible__1un1A\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"matrix-dialog\":\"MatrixDialog_matrix-dialog__2YGd3\",\"button\":\"MatrixDialog_button__3KxWd\",\"deactivated-button\":\"MatrixDialog_deactivated-button__ONTjT\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"matrix\":\"AdjacencyMatrix_matrix__3b96v\",\"matrix-row\":\"AdjacencyMatrix_matrix-row__3vHpl\",\"top-left-cell\":\"AdjacencyMatrix_top-left-cell__1-lFt\",\"top-right-cell\":\"AdjacencyMatrix_top-right-cell__1RYRb\",\"bottom-left-cell\":\"AdjacencyMatrix_bottom-left-cell__23nQC\",\"bottom-right-cell\":\"AdjacencyMatrix_bottom-right-cell__2r29f\",\"matrix-cell\":\"AdjacencyMatrix_matrix-cell__2Z91s\",\"label-cell\":\"AdjacencyMatrix_label-cell__3YJYr\",\"empty\":\"AdjacencyMatrix_empty__3-1PZ\"};"],"sourceRoot":""}