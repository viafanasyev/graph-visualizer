{"version":3,"sources":["components/Graph/Vertex/Vertex.jsx","components/Graph/Edge/Edge.jsx","utils/sleep.js","actions/index.js","actions/dialog.js","algorithms/graph/index.js","utils/graphConverter.js","actions/algorithm.js","components/Graph/VisualizationEdge/VisualizationEdge.jsx","components/Graph/Graph.jsx","components/Buttons/Buttons.jsx","components/Sliders/Sliders.jsx","components/DropDownLists/DropDownLists.jsx","components/ToggleSwitches/ToggleSwitches.jsx","utils/sizeof.js","algorithms/graph/dfs.js","utils/queue.js","algorithms/graph/bfs.js","algorithms/graph/dijkstra.js","algorithms/graph/prim-mst.js","utils/dsu.js","algorithms/graph/kruskal-mst.js","algorithms/graph/check-connected.js","algorithms/graph/check-bipartite.js","algorithms/graph/radius.js","algorithms/graph/diameter.js","algorithms/graph/topological-sort.js","algorithms/graph/find-bridges.js","algorithms/graph/find-articulation-points.js","algorithms/graph/scc-kosaraju.js","algorithms/graph/euler-path.js","algorithms/graph/euler-cycle.js","actions/matrixDialog.js","components/Menu/Menu.jsx","components/MessageBox/MessageBox.jsx","components/TextInputs/TextInputs.jsx","components/Dialogs/InputDialog/InputDialog.jsx","components/InfoBox/InfoBox.jsx","components/Dialogs/MatrixDialog/AdjacencyMatrix.jsx","components/Dialogs/MatrixDialog/MatrixDialog.jsx","components/HintBox/HintBox.jsx","components/AlgorithmInfoBox/AlgorithmInfoBox.jsx","components/App.jsx","serviceWorker.js","reducers/dialog.js","reducers/algorithm.js","reducers/matrixDialog.js","reducers/index.js","index.js","components/App.module.scss","components/Menu/Menu.module.scss","components/Buttons/Buttons.module.scss","components/Sliders/Sliders.module.scss","components/DropDownLists/DropDownLists.module.scss","components/ToggleSwitches/ToggleSwitches.module.scss","components/MessageBox/MessageBox.module.scss","components/Dialogs/InputDialog/InputDialog.module.scss","components/TextInputs/TextInputs.module.scss","components/InfoBox/InfoBox.module.scss","components/Dialogs/MatrixDialog/MatrixDialog.module.scss","components/Dialogs/MatrixDialog/AdjacencyMatrix.module.scss","components/HintBox/HintBox.module.scss","components/AlgorithmInfoBox/AlgorithmInfoBox.module.scss"],"names":["Vertex","x","y","radius","name","this","state","VertexState","DEFAULT","hint","hintState","VertexHintState","CLEAR","HIGHLIGHTED","PRE_COMPLETED","COMPLETED","COLOR_1","COLOR_2","VertexComponent","vertex","draggable","onDragStart","onDragEnd","onDragMove","onClick","e","call","target","getChildren","setAttrs","scaleX","scaleY","shadowColor","shadowBlur","shadowOffset","shadowOpacity","moveToTop","handleDragStart","to","duration","shadowOffsetX","shadowOffsetY","handleDragEnd","fill","color","stroke","strokeWidth","vertexBorderWidth","text","fontSize","textColor","width","height","align","verticalAlign","hintColor","labelWidth","Object","freeze","Edge","vertexFrom","vertexTo","oriented","weight","_from","_to","EdgeState","_oriented","undefined","FLIPPED","WALKED","ERASED","SHADOWED","EdgeComponent","edgeComponent","edge","edgeType","points","getEdgePointsForType","EdgeType","NOT_ORIENTED","linePoints","hitStrokeWidth","tension","isWeighted","labelPoints","EdgeLabel","labelRadius","labelBorderWidth","ONE_SIDE_ORIENTED","TWO_SIDE_ORIENTED","LOOP","from","isFlipped","dx","dy","angle","Math","atan2","vertexFromOffset","vertexToOffset","xFrom","cos","yFrom","sin","xTo","yTo","xMiddle","yMiddle","anchorDx","sqrt","anchorDy","xMiddleFirst","sleep","ms","Promise","resolve","setTimeout","ActionType","ADD_VERTEX","ADD_EDGE","REMOVE_VERTEX","REMOVE_EDGE","CHANGE_GRAPH_MODE","SELECT_VERTEX","UNSELECT_VERTEX","SHOW_MESSAGE","CLOSE_MESSAGE","UPDATE_VERTEX_POSITION","INVERT_ORIENTATION","ALGORITHM_STEP","CLEAN_GRAPH_SELECTIONS","SET_GRAPH","MOVE_CANVAS","GENERATE_GRAPH","CLEAR_GRAPH","addEdge","type","removeEdge","changeGraphMode","graphMode","currentMessageId","showMessage","message","isAlert","dispatch","a","messageId","showMessageConnector","closeMessage","algorithmStep","step","cleanGraphSelections","moveCanvas","START_DIALOG_FOR_RESULT","CLOSE_DIALOG","startDialogForResult","title","inputPlaceholder","onSubmit","onCancel","pattern","closeDialog","VertexAction","SELECT","UNSELECT","ENTER","EXIT","CLEAR_ALL_SELECTIONS","VertexHintAction","REMOVE","SET","HIGHLIGHT","EdgeAction","WALK","SHADOW","FLIP","AlgorithmActionType","VERTEX_ACTION","EDGE_ACTION","VERTEX_HINT_ACTION","PreCallAction","NOTHING","SELECT_EDGE","Criteria","WEIGHTED","CONNECTED","ORIENTED","ACYCLIC","getOperationsCount","trace","operationsCount","forEach","t","i","length","isChained","edgesListToAdjacencyList","vertices","edges","adjacencyList","push","isOriented","entries","verticesList","sort","b","edgesListToReversedAdjacencyList","map","edgesListToAdjacencyMatrix","verticesNumbers","v","nameToIndex","number","index","cell","adjacencyMatrix","Array","j","weighted","PRE_CALL","CALL","START","PAUSE","POP_TRACE_STEP","SET_ALGORITHM","SET_SPEED","SET_IS_ONE_STEP","CLEAR_TRACE","SHOW_STATISTICS","CLEAR_STATISTICS","SHOW_ALGORITHM_INFO","CLEAR_ALGORITHM_INFO","INVERT_ALGORITHM_INFO_COLLAPSED","setIsOneStep","isOneStep","getState","GraphMode","graph","graphReducer","callConnector","showAlgorithmInfo","algorithmReducer","pause","start","callSuccess","currentVisualizationId","traceStep","popTraceStep","showStatistics","visualizationId","isActive","speed","clearTrace","clearStatistics","clearAlgorithmInfo","VisualizationEdgeComponent","classnames","bind","styles","REMOVE_VERTEX_OR_EDGE","ALGORITHM_PRE_CALL_SELECT_VERTEX","ALGORITHM_PRE_CALL_SELECT_EDGE","Graph","isArray","Error","findIndex","_vertices","_edges","_visualizationEdges","_currentName","max","splice","filter","findEdge","invertOrientation","newEdges","removeVisualizationEdgeByVertices","GraphComponent","draggedVertex","windowWidth","windowHeight","findIndexOfVertex","props","handleVertexDragStart","cancelBubble","setState","updateDraggedVertex","updateVertexPosition","handleVertexDragMove","handleVertexDragEnd","getEdgeType","handleCanvasClick","evt","clientX","canvasX","clientY","canvasY","addVertex","selectedVertex","unselectVertex","handleVertexClick","removeVertex","selectVertex","value","Number","callAlgorithm","handleEdgeClick","handleCanvasDragEnd","handleResize","window","innerWidth","innerHeight","onresize","key","visualizationEdges","React","Component","connect","vertexIndex","onClose","cx","ButtonComponent","activated","className","hotKeyHint","SliderComponent","label","min","onChange","DropDownList","items","item","RoundedToggleSwitch","isChecked","checked","sizeof","object","objectList","stack","bytes","pop","indexOf","hasOwnProperty","used","memoryUsed","preCall","criteria","startTime","performance","now","dfs","action","actionType","toVertex","statistics","toFixed","algorithmInfo","Queue","_queue","shift","queue","isEmpty","bfs","d","p","MAX_SAFE_INTEGER","dijkstra","floor","random","mstWeight","mst","prim","DSU","parent","size","find","dsu","makeSet","union","kruskal","isConnected","isBipartite","level","peek","eccentricities","findRadius","diameter","findDiameter","topSortList","addedVertices","sortedVertices","reverse","topSort","timer","tin","tout","countBridges","findBridges","countArticulationPoints","isArticulationPoint","children","findArticulationPoints","reversedAdjacencyList","componentsNumber","dfsComponents","findComponents","isEuler","outOddVertices","inOddVertices","degree","oddVertices","checkForEuler","assign","cur","currentVertices","pathLen","findEulerPath","findEulerCycle","START_MATRIX_DIALOG_FOR_RESULT","CLOSE_MATRIX_DIALOG","closeMatrixDialog","MenuComponent","algorithms","DFS","BFS","Dijkstra","PrimMST","KruskalMST","CheckConnected","CheckBipartite","FindRadius","FindDiameter","TopologicalSort","FindBridges","FindArticulationPoints","SCCKosaraju","EulerPath","EulerCycle","hidden","handleAlgorithmChange","clearVisualization","setAlgorithm","startVisualization","remainingAlgorithmSteps","isVisualizationActive","continue","stepVisualization","stopVisualization","handleAlgorithmSpeedChange","setSpeed","askForAction","writeToFile","json","JSON","stringify","exportData","escape","anchorElement","document","getElementById","setAttribute","click","askReadFromFile","readFromFile","reader","FileReader","file","files","onload","parse","result","isNaN","setGraph","resetCanvasPosition","readAsText","showAdjacencyMatrix","startMatrixDialog","collapse","nextProps","nextState","nextContext","visualizationSpeed","selectedAlgorithm","grid","bounds","cancel","id","style","aria-hidden","href","accept","algorithm","continueCall","TextInputComponent","placeholder","autoFocus","customStyles","overlay","zIndex","InputDialog","handleChange","validity","valid","submit","preventDefault","submitDialog","cancelDialog","isOpen","onRequestClose","ariaHideApp","dialogReducer","lines","isVisible","isStatisticsShown","line","reduce","acc","MatrixCell","topLeft","topRight","bottomLeft","bottomRight","onContextMenu","MatrixRow","row","first","last","vertexNumber","onCellClick","AdjacencyMatrix","column","MatrixDialog","prev","arr","handleCellClick","edgeIndex","matrixDialogReducer","submitMatrixDialog","cancelMatrixDialog","HintBox","isAlgorithmInfoShown","isCollapsed","isAlgorithmInfoCollapsed","generateGraph","clearGraph","invertAlgorithmInfoCollapsed","handlers","GENERATE","COLLAPSE_ALGORITHM_INFO","keyMap","Menu","Boolean","location","hostname","match","defaultState","dialog","newState","matrixDialog","clone","create","getPrototypeOf","unselectSelectedVertex","updateVertexByAction","updateEdgeByAction","updateVertexHintByAction","combineReducers","addVisualizationEdge","removeAllEdges","edgesNumber","log2","store","createStore","rootReducer","applyMiddleware","thunk","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","module","exports"],"mappings":"4QAGaA,EAAb,WACI,WAAYC,EAAGC,EAAGC,EAAQC,GAAO,oBAC7BC,KAAKJ,EAAIA,EACTI,KAAKH,EAAIA,EACTG,KAAKF,OAASA,EACdE,KAAKC,MAAQC,EAAYC,QACzBH,KAAKD,KAAOA,EACZC,KAAKI,KAAO,GACZJ,KAAKK,UAAYC,EAAgBC,MARzC,kDAYQ,OAAQP,KAAKC,OACT,KAAKC,EAAYC,QACb,MAAO,QACX,KAAKD,EAAYM,YACb,MAAO,SACX,KAAKN,EAAYO,cACb,MAAO,UACX,KAAKP,EAAYQ,UACb,MAAO,UACX,KAAKR,EAAYS,QACb,MAAO,UACX,KAAKT,EAAYU,QACb,MAAO,UACX,QACI,MAAO,WA1BvB,gCA+BQ,OAAQZ,KAAKC,OACT,KAAKC,EAAYC,QAEjB,KAAKD,EAAYM,YAEjB,KAAKN,EAAYO,cACb,MAAO,QACX,KAAKP,EAAYQ,UAEjB,KAAKR,EAAYS,QAEjB,KAAKT,EAAYU,QACb,MAAO,QACX,QACI,MAAO,WA7CvB,gCAkDQ,OAAQZ,KAAKK,WACT,KAAKC,EAAgBC,MACjB,MAAO,YACX,KAAKD,EAAgBH,QACjB,MAAO,UACX,KAAKG,EAAgBE,YACjB,MAAO,UACX,QACI,MAAO,iBA1DvB,KA0FaK,EAAkB,SAAC,GAAwE,IAAtEC,EAAqE,EAArEA,OAAQC,EAA6D,EAA7DA,UAAWC,EAAkD,EAAlDA,YAAaC,EAAqC,EAArCA,UAAWC,EAA0B,EAA1BA,WAAYC,EAAc,EAAdA,QAErF,OACI,kBAAC,QAAD,CACIJ,UAAWA,EACXC,YAAa,SAAAI,GAAC,OAhCF,SAACA,EAAGC,GACxBD,EAAEE,OAAOC,cAAc,GAAGC,SAAS,CAC/BC,OAAQ,IACRC,OAAQ,IACRC,YAAa,QACbC,WAAY,GACZC,aAAc,CAAEjC,EAAG,GAAIC,EAAG,IAC1BiC,cAAe,KAEnBV,EAAEE,OAAOS,YAETV,EAAKD,GAqBqBY,CAAgBZ,EAAGJ,IACrCC,UAAW,SAAAG,GAAC,OAnBF,SAACA,EAAGC,GACtBD,EAAEE,OAAOC,cAAc,GAAGU,GAAG,CACzBC,SAAU,IACVT,OAAQ,EACRC,OAAQ,EACRE,WAAY,EACZO,cAAe,EACfC,cAAe,IAGnBf,EAAKD,GASmBiB,CAAcjB,EAAGH,IACjCC,WAAYA,EACZC,QAASA,EACTvB,EAAGkB,EAAOlB,EACVC,EAAGiB,EAAOjB,GACV,kBAAC,SAAD,CACID,EAAG,EACHC,EAAG,EACHC,OAAQgB,EAAOhB,OACfwC,KAAMxB,EAAOyB,MACbC,OAAQ,QACRZ,WAAY,EACZa,YAAaC,EACbZ,cAAe,KACnB,kBAAC,OAAD,CACIa,KAAM7B,EAAOf,KACbH,GAAG,GACHC,GAAG,GACH+C,SAAU,GACVN,KAAMxB,EAAO+B,UACbC,MAzBO,GA0BPC,OA1ByB,GA2BzBC,MAAO,SACPC,cAAe,WAEnB,kBAAC,OAAD,CACIN,KAAM7B,EAAOV,KACbR,GAAI,EAAIkB,EAAOhB,OACfD,GAAI,EAAIiB,EAAOhB,OACf8C,SAAU,GACVN,KAAMxB,EAAOoC,UACbV,OAAQ1B,EAAOoC,UACfJ,MAAOK,GACPJ,OAtCyB,GAuCzBC,MAAO,SACPC,cAAe,aAIlBP,EAAoB,EAEpBxC,EAAckD,OAAOC,OAAO,CAAElD,QAAS,EAAGK,YAAa,EAAGC,cAAe,EAAGC,UAAW,EAAGC,QAAS,EAAGC,QAAS,IAC/GN,EAAkB8C,OAAOC,OAAO,CAAE9C,MAAO,EAAGJ,QAAS,EAAGK,YAAa,ICzIrE8C,EAAb,WACI,WAAYC,EAAYC,EAAUC,EAAUC,GAAS,oBACjD1D,KAAK2D,MAAQJ,EACbvD,KAAK4D,IAAMJ,EACXxD,KAAK0D,OAASA,EACd1D,KAAKC,MAAQ4D,EAAU1D,QACvBH,KAAK8D,UAAYL,EANzB,yDAqCQ,YAAwBM,IAAhB/D,KAAK0D,QAA0C,OAAhB1D,KAAK0D,SArCpD,mCAyCQ,OAAO1D,KAAK8D,YAzCpB,kCA6CQ,OAAO9D,KAAKC,QAAU4D,EAAUG,UA7CxC,0CAiDQhE,KAAK8D,WAAa9D,KAAK8D,YAjD/B,2BAUQ,OAAO9D,KAAK2D,QAVpB,yBAcQ,OAAO3D,KAAK4D,MAdpB,4BAkBQ,OAAQ5D,KAAKC,OACT,KAAK4D,EAAU1D,QACX,MAAO,QACX,KAAK0D,EAAUrD,YACX,MAAO,UACX,KAAKqD,EAAUI,OACX,MAAO,UACX,KAAKJ,EAAUK,OACX,MAAO,YACX,KAAKL,EAAUM,SACX,MAAO,UACX,KAAKN,EAAUG,QAEf,QACI,MAAO,aAhCvB,KAqDaI,EAAgB,SAAC,GAAiC,IAIvDC,EAJwBC,EAA8B,EAA9BA,KAAMC,EAAwB,EAAxBA,SAAUpD,EAAc,EAAdA,QACtCqD,EAASC,EAAqBH,EAAMC,GACpChC,EAAQ+B,EAAK/B,MAyBnB,OArBI8B,EADAE,IAAaG,EAASC,aAElB,kBAAC,OAAD,CACIH,OAAQA,EAAOI,WACfzD,QAASA,EACTqB,OAAQD,EACRD,KAAMC,EACNE,YAAa,EACboC,eAAgB,KAIpB,kBAAC,QAAD,CACIL,OAAQA,EAAOI,WACfzD,QAASA,EACTqB,OAAQD,EACRD,KAAMC,EACNE,YAAa,EACboC,eAAgB,GAChBC,QAAS,KAGjBR,EAAKS,aAED,kBAAC,QAAD,CAAO5D,QAASA,GACXkD,EACD,kBAAC,EAAD,CACIzE,EAAG4E,EAAOQ,YAAY,GACtBnF,EAAG2E,EAAOQ,YAAY,GACtBrC,KAAM2B,EAAKZ,UAIfW,GAGHY,EAAY,SAAC,GAAoB,IAAlBrF,EAAiB,EAAjBA,EAAGC,EAAc,EAAdA,EAAG8C,EAAW,EAAXA,KAI9B,OACI,kBAAC,QAAD,CACI/C,EAAGA,EALS,GACW,EACN,EAIjBC,EAAGA,EANS,GACqC,EAChC,EAKjBiD,MAAOoC,GACPnC,OAAQmC,IACR,kBAAC,SAAD,CACItF,EAAGsF,GACHrF,EAAGqF,GACHpF,OAZQ,GAaRwC,KAAM,QACNE,OAAQ,QACRC,YAba,IAcjB,kBAAC,OAAD,CACI7C,EAAGuF,EACHtF,EAAGsF,EACHxC,KAAMA,EACNC,SAAU,GACVE,MAAOoC,GACPnC,OAAQmC,GACRlC,MAAO,SACPC,cAAe,aAKlByB,EAAWtB,OAAOC,OAAO,CAAE+B,kBAAmB,EAAGC,kBAAmB,EAAGV,aAAc,EAAGW,KAAM,IAC9FzB,EAAYT,OAAOC,OAAO,CAAElD,QAAS,EAAGK,YAAa,EAAG0D,OAAQ,EAAGD,OAAQ,EAAGE,SAAU,EAAGH,QAAS,IAEpGS,EAAuB,SAACH,EAAMC,GACvC,IAAIhB,EAAae,EAAKiB,KAClB/B,EAAWc,EAAKrC,GACpB,GAAIqC,EAAKkB,YAAT,OAC6B,CAAChC,EAAUD,GAAnCA,EADL,KACiBC,EADjB,KAGA,IAAMiC,EAAKjC,EAAS5D,EAAI2D,EAAW3D,EAC7B8F,EAAKnC,EAAW1D,EAAI2D,EAAS3D,EAC7B8F,EAAQC,KAAKC,MAAMH,EAAID,GACvBK,EAAmBvC,EAAWzD,OAAS4C,EAAoB,EAC3DqD,EAAiBvC,EAAS1D,OAAS4C,EAAoB,EAE7D,GAAK6B,IAAaG,EAASU,mBAAuBb,IAAaG,EAASC,aAAe,CACnF,IAAMqB,EAAQzC,EAAW3D,EAAIkG,EAAmBF,KAAKK,IAAIN,GACnDO,EAAQ3C,EAAW1D,EAAIiG,EAAmBF,KAAKO,IAAIR,GACnDS,EAAM5C,EAAS5D,EAAImG,EAAiBH,KAAKK,IAAIN,GAC7CU,EAAM7C,EAAS3D,EAAIkG,EAAiBH,KAAKO,IAAIR,GAEnD,MAAO,CACHf,WAAY,CACRoB,EAAOE,EACPE,EAAKC,GAETrB,YAAa,EACRgB,EAAQI,GAAO,GACfF,EAAQG,GAAO,IAGrB,GAAI9B,IAAaG,EAASW,kBAAmB,CAChD,IACMW,EAAQzC,EAAW3D,EAAIkG,EAAmBF,KAAKK,IAAIN,EADrC,KAEdO,EAAQ3C,EAAW1D,EAAIiG,EAAmBF,KAAKO,IAAIR,EAFrC,KAGdS,EAAM5C,EAAS5D,EAAImG,EAAiBH,KAAKK,IAAIN,EAH/B,KAIdU,EAAM7C,EAAS3D,EAAIkG,EAAiBH,KAAKO,IAAIR,EAJ/B,KAOdW,GAAWN,EAAQI,GAAO,EADK,EAAK,IACJF,EAAQG,GACxCE,GAAWL,EAAQG,GAAO,EAFK,EAAK,IAEJL,EAAQI,GAE9C,MAAO,CACHxB,WAAY,CACRoB,EAAOE,EACPI,EAASC,EACTH,EAAKC,GAETrB,YAAa,CACTsB,EACAC,IAGL,GAAIhC,IAAaG,EAASY,KAAM,CACnC,IAAMU,EAAQzC,EAAW3D,EAAIkG,EACvBI,EAAQ3C,EAAW1D,EACnBuG,EAAM7C,EAAW3D,EAAIkG,EACrBO,EAAM9C,EAAW1D,EAEjB2G,EAAW,EAAKV,EAAmBF,KAAKa,KAAK,GAC7CC,EAAW,IAAMZ,EAAmBF,KAAKa,KAAK,GAC9CE,EAAeX,EAAQQ,EAEvBF,EAAUK,EAAeb,EAK/B,MAAO,CACHlB,WAAY,CACRoB,EAAOE,EACPS,EATaT,EAAQQ,EAUrBJ,EARQJ,EACME,EAAMI,EACNH,EAAMK,EAQpBN,EAAKC,GAETrB,YAAa,CACTsB,EAbQJ,M,iCChMjB,SAASU,EAAMC,GAClB,OAAO,IAAIC,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAASF,MCC/C,IAAMI,EAAa7D,OAAOC,OAAO,CACpC6D,WAAY,aACZC,SAAU,WACVC,cAAe,gBACfC,YAAa,cACbC,kBAAmB,oBACnBC,cAAe,gBACfC,gBAAiB,kBACjBC,aAAc,eACdC,cAAe,gBACfC,uBAAwB,yBACxBC,mBAAoB,qBACpBC,eAAgB,iBAChBC,uBAAwB,yBACxBC,UAAW,YACXC,YAAa,cACbC,eAAgB,iBAChBC,YAAa,gBAUJC,EAAU,SAAC5E,EAAYC,EAAUE,GAAvB,MAAmC,CACtD0E,KAAMnB,EAAWE,SACjB5D,aACAC,WACAE,WAQS2E,EAAa,SAAC/D,GAAD,MAAW,CACjC8D,KAAMnB,EAAWI,YACjB/C,SAGSgE,EAAkB,SAACC,GAAD,MAAgB,CAC3CH,KAAMnB,EAAWK,kBACjBiB,cAaAC,EAAmB,EAEVC,EAAc,SAACC,GAAD,IAAUC,EAAV,sGAA8B,WAAOC,GAAP,eAAAC,EAAA,6DAC/CC,IAAcN,EACpBI,EAASG,EAAqBL,EAASC,IAFc,SAG/C/B,EAAM,KAHyC,OAIjDkC,IAAcN,GACdI,EAASI,KALwC,2CAA9B,uDAQrBD,EAAuB,SAACL,GAAD,IAAUC,EAAV,8DAA+B,CACxDP,KAAMnB,EAAWQ,aACjBiB,UACAC,YAGSK,EAAe,iBAAO,CAC/BZ,KAAMnB,EAAWS,gBAcRuB,EAAgB,SAACC,GAAD,MAAW,CACpCd,KAAMnB,EAAWY,eACjBqB,SAGSC,EAAuB,iBAAO,CACvCf,KAAMnB,EAAWa,yBAQRsB,EAAa,SAACxJ,EAAGC,GAAJ,MAAW,CACjCuI,KAAMnB,EAAWe,YACjBpI,IACAC,MC7GSoH,EAAa7D,OAAOC,OAAO,CACpCgG,wBAAyB,0BACzBC,aAAc,iBAGLC,EAAuB,SAACC,EAAO7G,EAAMvC,EAAMqJ,EAAkBC,EAAUC,GAAhD,IAA0DC,EAA1D,uDAAoE,KAApE,MAA8E,CAC9GxB,KAAMnB,EAAWoC,wBACjBG,QACA7G,OACAvC,OACAqJ,mBACAC,WACAC,WACAC,YAGEC,EAAc,iBAAO,CACxBzB,KAAMnB,EAAWqC,e,OCjBPQ,EAAe1G,OAAOC,OAAO,CACtC0G,OAAQ,EACRC,SAAU,EACVC,MAAO,EACPC,KAAM,EACNvJ,QAAS,EACTC,QAAS,EACTuJ,qBAAsB,IAGbC,EAAmBhH,OAAOC,OAAO,CAC1CgH,OAAQ,EACRC,IAAK,EACLC,UAAW,IAGFC,EAAapH,OAAOC,OAAO,CACpCoH,KAAM,EACNF,UAAW,EACXP,SAAU,EACVU,OAAQ,EACRP,qBAAsB,EACtBQ,KAAM,IAGGC,EAAsBxH,OAAOC,OAAO,CAC7CwH,cAAe,EACfC,YAAa,EACbC,mBAAoB,IAGXC,GAAgB5H,OAAOC,OAAO,CACvC4H,QAAS,EACT1D,cAAe,EACf2D,YAAa,IAGJC,GAAW/H,OAAOC,OAAO,CAClC4H,QAAS,EACTG,SAAU,EACVC,UAAW,EACX1G,aAAc,EACd2G,SAAU,EACVC,QAAS,KAGAC,GAAqB,SAACC,GAC/B,IAAIC,EAAkB,EAKtB,OAJAD,EAAME,SAAQ,SAACC,EAAGC,GACTA,EAAI,IAAMJ,EAAMK,QAAYF,EAAEG,aAC7BL,KAEHA,G,SClDEM,GAA2B,SAACC,EAAUC,GAC/C,IAAMC,EAAgB,GACtBF,EAASN,SAAQ,SAAA7K,GAAM,OAAIqL,EAAcrL,EAAOf,MAAQ,MACxDmM,EAAMP,SAAQ,SAAArH,GACV6H,EAAc7H,EAAKiB,KAAKxF,MAAMqM,KAAK,CAACrM,KAAMuE,EAAKrC,GAAGlC,KAAM2D,OAAQY,EAAKZ,SAChEY,EAAK+H,cAAiB/H,EAAKiB,OAASjB,EAAKrC,IAC1CkK,EAAc7H,EAAKrC,GAAGlC,MAAMqM,KAAK,CAACrM,KAAMuE,EAAKiB,KAAKxF,KAAM2D,OAAQY,EAAKZ,YAE7E,cAA6BN,OAAOkJ,QAAQH,GAA5C,oBAAYI,EAAZ,wBACIA,EAAeA,EAAaC,MAAK,SAAC3D,EAAG4D,GAAJ,OAAU5D,EAAE9I,KAAO0M,EAAE1M,QAC1D,OAAOoM,GAGEO,GAAmC,SAACT,EAAUC,GACvD,OAAOF,GAAyBC,EAAUC,EAAMS,KAAI,SAAAvL,GAAC,OACjD,IAAIkC,EAAKlC,EAAEa,GAAIb,EAAEmE,KAAMnE,EAAEiL,aAAcjL,EAAEsC,aAIpCkJ,GAA6B,SAACX,EAAUC,GACjD,IAAMW,EAAkB,GACxBZ,EAASN,SAAQ,SAAAmB,GAAC,OAAID,EAAgBT,KAAKU,EAAE/M,SAC7C8M,EAAgBL,MAAK,SAAC3D,EAAG4D,GAAJ,OAAU5D,EAAI4D,KACnC,IAAMM,EAAc,GACpBF,EAAgBlB,SAAQ,SAACqB,EAAQC,GAAT,OAAmBF,EAAYC,GAAUC,KAGjE,IADA,IAOI1H,EAAMtD,EAAIiL,EAPRC,EAAkB,IAAIC,MAAMnB,EAASH,QAClCD,EAAI,EAAGA,EAAII,EAASH,SAAUD,EAAG,CACtCsB,EAAgBtB,GAAK,IAAIuB,MAAMnB,EAASH,QACxC,IAAK,IAAIuB,EAAI,EAAGA,EAAIpB,EAASH,SAAUuB,EACnCF,EAAgBtB,GAAGwB,GAAK,KAahC,OATAnB,EAAMP,SAAQ,SAAAvK,GACVmE,EAAOwH,EAAY3L,EAAEmE,KAAKxF,MAC1BkC,EAAK8K,EAAY3L,EAAEa,GAAGlC,MACtBmN,EAAO9L,EAAEsC,OAAS,CAAE4J,UAAU,EAAM5J,OAAQtC,EAAEsC,QAAW,CAAE4J,UAAW,GACtEH,EAAgB5H,GAAMtD,GAAMiL,EACvB9L,EAAEiL,eACHc,EAAgBlL,GAAIsD,GAAQ2H,MAG7B,CAACC,kBAAiBN,oBCvChB5F,GAAa7D,OAAOC,OAAO,CACpCkK,SAAU,WACVC,KAAM,OACNC,MAAO,QACPC,MAAO,QACPC,eAAgB,iBAChBC,cAAe,gBACfC,UAAW,YACXC,gBAAiB,kBACjBC,YAAa,cACbC,gBAAiB,kBACjBC,iBAAkB,mBAClBC,oBAAqB,sBACrBC,qBAAsB,uBACtBC,gCAAiC,oCAkG/BC,GAAe,SAACC,GAAD,MAAgB,CACjClG,KAAMnB,GAAW6G,gBACjBQ,cAGSjN,GAAO,SAACP,EAAQwD,GAAT,OAAkB,SAACsE,EAAU2F,GAC7C3F,EAASI,KACTJ,EAASN,EAAgBkG,GAAUrO,UACnC,IAAMsO,EAAQF,IAAWG,aAAaD,MACtC7F,EAAS+F,GAAcF,EAAO3N,EAAQwD,IACtCsE,EAASgG,MAET,IAAMN,EAAYC,IAAWM,iBAAiBP,UAClC1F,EAAZ0F,EAAqBQ,KAAoBC,MACzCnG,EAASoG,GAAYV,MAQnBS,GAAQ,iBAAO,CACjB3G,KAAMnB,GAAWwG,QAGRqB,GAAQ,iBAAO,CACxB1G,KAAMnB,GAAWyG,QAGfiB,GAAgB,SAACF,EAAO3N,EAAQwD,GAAhB,MAA0B,CAC5C8D,KAAMnB,GAAWuG,KACjBiB,QACA3N,SACAwD,SAGA2K,GAAyB,EAEvBD,GAAc,eAACV,EAAD,sGAAuB,WAAO1F,EAAU2F,GAAjB,mBAAA1F,EAAA,0DACnCyF,EADmC,gBAGnC,IADIY,EAAY,CAACnD,WAAY,GACrBwC,IAAWM,iBAAiBpD,MAAMK,OAAS,GAAMoD,EAAUnD,WAC/DmD,EAAYX,IAAWM,iBAAiBpD,MAAM,GAC9C7C,EAASK,EAAciG,IACvBtG,EAASuG,MAEwC,IAA7CZ,IAAWM,iBAAiBpD,MAAMK,QAClClD,EAASwG,MATkB,iCAejCC,IAAoBJ,GAfa,YAiB/BV,IAAWM,iBAAiBpD,MAAMK,OAAS,GAAMyC,IAAWM,iBAAiBS,UAjB9C,oBAkBnCJ,EAAYX,IAAWM,iBAAiBpD,MAAM,GAC9C7C,EAASK,EAAciG,IACvBtG,EAASuG,QACJZ,IAAWM,iBAAiBpD,MAAMK,OAAS,IAAOoD,EAAUnD,UArB9B,kCAsBzBnF,EAAM2H,IAAWM,iBAAiBU,OAtBT,WAuB3BN,KAA2BI,EAvBA,0EA2BnCd,IAAWM,iBAAiBS,WAC5B1G,EAASkG,MACTlG,EAASwG,OA7B0B,4CAAvB,yDAiCdD,GAAe,iBAAO,CACxB/G,KAAMnB,GAAW0G,iBAGR6B,GAAa,iBAAO,CAC7BpH,KAAMnB,GAAW8G,cAGfqB,GAAiB,iBAAO,CAC3BhH,KAAMnB,GAAW+G,kBAGPyB,GAAkB,iBAAO,CAClCrH,KAAMnB,GAAWgH,mBAGfW,GAAoB,iBAAO,CAC9BxG,KAAMnB,GAAWiH,sBAGPwB,GAAqB,iBAAO,CACrCtH,KAAMnB,GAAWkH,uBC/MRwB,GAA6B,SAAC,GAAwB,IAG3DtL,EAHqCC,EAAqB,EAArBA,KAAMC,EAAe,EAAfA,SACzCC,EAASC,EAAqBH,EAAMC,GACpChC,EAAQ+B,EAAK/B,MAsBnB,OAnBI8B,EADAE,IAAaG,GAASC,aAElB,kBAAC,OAAD,CACIH,OAAQA,EAAOI,WACfpC,OAAQD,EACRD,KAAMC,EACNE,YAAa,EACboC,eAAgB,KAIpB,kBAAC,QAAD,CACIL,OAAQA,EAAOI,WACfpC,OAAQD,EACRD,KAAMC,EACNE,YAAa,EACboC,eAAgB,GAChBC,QAAS,KAGjBR,EAAKS,aAED,kBAAC,QAAD,KACKV,EACD,kBAAC,EAAD,CACIzE,EAAG4E,EAAOQ,YAAY,GACtBnF,EAAG2E,EAAOQ,YAAY,GACtBrC,KAAM2B,EAAKZ,UAIfW,GAGHK,GAAWtB,OAAOC,OAAO,CAAE+B,kBAAmB,EAAGC,kBAAmB,EAAGV,aAAc,EAAGW,KAAM,ICT9FkJ,IAZFoB,IAAWC,KAAKC,KAYF1M,OAAOC,OAAO,CACnClD,QAAS,EACT+G,WAAY,EACZC,SAAU,EACV4I,sBAAuB,EACvBC,iCAAkC,EAClCC,+BAAgC,KAGvBC,GAAb,WACI,WAAYzM,GAA0C,IAAhCwI,EAA+B,uDAApB,KAAMC,EAAc,uDAAN,KAC3C,GADiD,oBAC5CD,GAAamB,MAAM+C,QAAQlE,IAAcC,GAAUkB,MAAM+C,QAAQjE,GAM/D,CACH,IAAK,IAAIL,EAAI,EAAGA,EAAII,EAASH,SAAUD,EAAG,CACtC,GAAKI,EAASJ,GAAG9L,KAAO,GAAOkM,EAASJ,GAAG9L,KAAO,IAC9C,MAAM,IAAIqQ,MAAM,uBAEpB,IAAK,IAAI/C,EAAI,EAAGA,EAAIpB,EAASH,SAAUuB,EACnC,GAAKxB,IAAMwB,GAAOpB,EAASJ,GAAG9L,OAASkM,EAASoB,GAAGtN,KAC/C,MAAM,IAAIqQ,MAAM,iCAI5B,IAXG,eAWMvE,GACL,GAAIK,EAAML,GAAGnI,SAAYwI,EAAML,GAAGnI,OAAS,GAAOwI,EAAML,GAAGnI,OAAS,IAChE,MAAM,IAAI0M,MAAM,uBACpB,IAAgE,IAA5DnE,EAASoE,WAAU,SAAAvD,GAAC,OAAIA,EAAE/M,OAASmM,EAAML,GAAGtG,KAAKxF,QACjD,MAAM,IAAIqQ,MAAM,yBACpB,IAA8D,IAA1DnE,EAASoE,WAAU,SAAAvD,GAAC,OAAIA,EAAE/M,OAASmM,EAAML,GAAG5J,GAAGlC,QAC/C,MAAM,IAAIqQ,MAAM,uBAEpB,IAAK,IAAI/C,EAAI,EAAGA,EAAInB,EAAMJ,SAAUuB,EAChC,GAAIxB,IAAMwB,EACN,GAAI5J,GACA,GAAKyI,EAAML,GAAGtG,KAAKxF,OAASmM,EAAMmB,GAAG9H,KAAKxF,MAAUmM,EAAML,GAAG5J,GAAGlC,OAASmM,EAAMmB,GAAGpL,GAAGlC,KACjF,MAAM,IAAIqQ,MAAM,oCAEpB,GAAKlE,EAAML,GAAGtG,KAAKxF,OAASmM,EAAMmB,GAAG9H,KAAKxF,MAAUmM,EAAML,GAAG5J,GAAGlC,OAASmM,EAAMmB,GAAGpL,GAAGlC,MAC7EmM,EAAML,GAAG5J,GAAGlC,OAASmM,EAAMmB,GAAG9H,KAAKxF,MAAUmM,EAAML,GAAGtG,KAAKxF,OAASmM,EAAMmB,GAAGpL,GAAGlC,KACpF,MAAM,IAAIqQ,MAAM,gCAhB3BvE,EAAI,EAAGA,EAAIK,EAAMJ,SAAUD,EAAI,EAA/BA,GAuBT7L,KAAKsQ,UAAL,YAAqBrE,GACrBjM,KAAKuQ,OAAL,YAAkBrE,GAClBlM,KAAKwQ,oBAAsB,GAC3BxQ,KAAK8D,UAAYL,EACjBzD,KAAKyQ,aAAe7K,KAAK8K,IAAL,MAAA9K,KAAI,YAAQqG,EAASU,KAAI,SAAAG,GAAC,OAAIA,EAAE/M,UAAS,OA3C7DC,KAAKsQ,UAAY,GACjBtQ,KAAKuQ,OAAS,GACdvQ,KAAKwQ,oBAAsB,GAC3BxQ,KAAK8D,UAAYL,EACjBzD,KAAKyQ,aAAe,EAPhC,sDAkDc7Q,EAAGC,EAAGC,GACZ,IAAMgB,EAAS,IAAInB,EAAOC,EAAGC,EAAGC,EAAQE,KAAKyQ,gBAE7C,OADAzQ,KAAKsQ,UAAUlE,KAAKtL,GACbA,IArDf,mCAwDiBA,GACT,IAAMmM,EAAQjN,KAAKsQ,UAAUD,WAAU,SAAAvD,GAAC,OAAIA,IAAMhM,MACnC,IAAXmM,IACAjN,KAAKsQ,UAAUK,OAAO1D,EAAO,GAC7BjN,KAAKuQ,OAASvQ,KAAKuQ,OAAOK,QAAO,SAAAtM,GAAI,OAAKA,EAAKiB,KAAKxF,OAASe,EAAOf,MAAUuE,EAAKrC,GAAGlC,OAASe,EAAOf,WA5DlH,+BAgEawD,EAAYC,GACjB,OAAIxD,KAAK8D,UACE9D,KAAKuQ,OAAOF,WAAU,SAAAjP,GAAC,OAAKA,EAAEmE,OAAShC,GAAgBnC,EAAEa,KAAOuB,KAEhExD,KAAKuQ,OAAOF,WAAU,SAAAjP,GAAC,OAAKA,EAAEmE,OAAShC,GAAgBnC,EAAEa,KAAOuB,GAC/DpC,EAAEa,KAAOsB,GAAgBnC,EAAEmE,OAAS/B,OArExD,8BAwEYD,EAAYC,EAAUE,GAC1B,IAAMmI,EAAI7L,KAAK6Q,SAAStN,EAAYC,GACpC,IAAW,IAAPqI,EAAU,CACV,IAAMvH,EAAO,IAAIhB,EAAKC,EAAYC,EAAUxD,KAAK8D,UAAWJ,GAE5D,OADA1D,KAAKuQ,OAAOnE,KAAK9H,GACVA,EAGPtE,KAAKuQ,OAAO1E,GAAGnI,OAASA,IAhFpC,iCAoFeY,GACPtE,KAAKuQ,OAASvQ,KAAKuQ,OAAOK,QAAO,SAAAxP,GAAC,OAAIA,IAAMkD,OArFpD,uCAyFQtE,KAAKuQ,OAAS,KAzFtB,0CA4FyB,IAAD,OAEhB,GADAvQ,KAAK8D,WAAa9D,KAAK8D,UACnB9D,KAAK8D,UAAW,CAChB9D,KAAKuQ,OAAO5E,SAAQ,SAAArH,GAAI,OAAIA,EAAKwM,uBACnB,YAAO9Q,KAAKuQ,QACjB5E,SAAQ,SAAAvK,GAAC,OAAI,EAAK+G,QAAQ/G,EAAEa,GAAIb,EAAEmE,KAAMnE,EAAEsC,eAChD,CACH,IAAMqN,EAAW,GACjB/Q,KAAKuQ,OAAO5E,SAAQ,SAAArH,IAE0C,IADtDyM,EAASV,WAAU,SAAAjP,GAAC,OAAKA,EAAEmE,OAASjB,EAAKiB,MAAUnE,EAAEa,KAAOqC,EAAKrC,IAC7Db,EAAEa,KAAOqC,EAAKiB,MAAUnE,EAAEmE,OAASjB,EAAKrC,QAE5CqC,EAAKwM,oBACLC,EAAS3E,KAAK9H,OAGtBtE,KAAKuQ,OAASQ,KA5G1B,4CAgH0BxN,EAAYC,EAAUC,GACxC,OAAIA,EACOzD,KAAKwQ,oBAAoBH,WAAU,SAAAjP,GAAC,OAAKA,EAAEmE,OAAShC,GAAgBnC,EAAEa,KAAOuB,KAE7ExD,KAAKwQ,oBAAoBH,WAAU,SAAAjP,GAAC,OAAKA,EAAEmE,OAAShC,GAAgBnC,EAAEa,KAAOuB,GAC5EpC,EAAEa,KAAOsB,GAAgBnC,EAAEmE,OAAS/B,OArHxD,2CAwHyBD,EAAYC,EAAUC,EAAUC,GACjD1D,KAAKgR,kCAAkCzN,EAAYC,EAAUC,GAC7D,IAAMa,EAAO,IAAIhB,EAAKC,EAAYC,EAAUC,EAAUC,GAEtD,OADA1D,KAAKwQ,oBAAoBpE,KAAK9H,GACvBA,IA5Hf,8CA+H4BA,GACpBtE,KAAKwQ,oBAAsBxQ,KAAKwQ,oBAAoBI,QAAO,SAAAxP,GAAC,OAAIA,IAAMkD,OAhI9E,wDAmIsCf,EAAYC,EAAUC,GAEhDzD,KAAKwQ,oBADL/M,EAC2BzD,KAAKwQ,oBAAoBI,QAAO,SAAAxP,GAAC,OACvDA,EAAEmE,KAAKxF,OAASwD,EAAWxD,MAAUqB,EAAEa,GAAGlC,OAASyD,EAASzD,QAGtCC,KAAKwQ,oBAAoBI,QAAO,SAAAxP,GAAC,OACtDA,EAAEmE,KAAKxF,OAASwD,EAAWxD,MAAUqB,EAAEa,GAAGlC,OAASyD,EAASzD,QAC5DqB,EAAEa,GAAGlC,OAASwD,EAAWxD,MAAUqB,EAAEmE,KAAKxF,OAASyD,EAASzD,WA3I9E,mCAgJQC,KAAKsQ,UAAY,GACjBtQ,KAAKwQ,oBAAsB,GAC3BxQ,KAAKuQ,OAAS,GACdvQ,KAAKyQ,aAAe,IAnJ5B,mCAuKQ,OAAOzQ,KAAK8D,YAvKpB,+BAuJQ,OAAO9D,KAAKsQ,YAvJpB,4BA2JQ,OAAOtQ,KAAKuQ,SA3JpB,yCA+JQ,OAAOvQ,KAAKwQ,qBA/JpB,aAkK2BtE,GACnBlM,KAAKwQ,oBAAsBtE,MAnKnC,KA2KM+E,G,4MACFhR,MAAQ,CACJiR,mBAAenN,EACfoN,YAAa,IACbC,aAAc,K,EAWlBC,kBAAoB,SAACvQ,GACjB,OAAO,EAAKwQ,MAAM7C,MAAMxC,SAASoE,WAAU,SAAAvD,GAAC,OAAIA,IAAMhM,M,EAG1DyQ,sBAAwB,SAACnQ,EAAGN,GACxBM,EAAEoQ,cAAe,EAEjB,IAAM3F,EAAI,EAAKwF,kBAAkBvQ,GACjC,EAAK2Q,SAAS,CAAEP,eAAuB,IAAPrF,EAAWA,OAAI9H,K,EAGnD2N,oBAAsB,SAAC9R,EAAGC,GACtB,IAAMiB,EAAS,EAAKb,MAAMiR,mBACXnN,IAAXjD,GACA,EAAKwQ,MAAMK,qBAAqB7Q,EAAQlB,EAAGC,I,EAGnD+R,qBAAuB,SAAAxQ,GACnBA,EAAEoQ,cAAe,EAEjB,EAAKE,oBAAoBtQ,EAAEE,OAAO1B,IAAKwB,EAAEE,OAAOzB,M,EAGpDgS,oBAAsB,SAACzQ,EAAGN,GACtBM,EAAEoQ,cAAe,EAEjB,EAAKE,oBAAoBtQ,EAAEE,OAAO1B,IAAKwB,EAAEE,OAAOzB,KAChD,EAAK4R,SAAS,CAAEP,mBAAenN,K,EAGnC+N,YAAc,SAAAxN,GACV,IAAMf,EAAae,EAAKiB,KAAM/B,EAAWc,EAAKrC,GAE9C,OAAIuB,IAAaD,EACNmB,EAASY,KACVhB,EAAK+H,cAEsF,IAA3F,EAAKiF,MAAM7C,MAAMvC,MAAMmE,WAAU,SAAAjP,GAAC,OAAKA,EAAEmE,OAAS/B,GAAcpC,EAAEa,KAAOsB,OACoB,IAA3F,EAAK+N,MAAM7C,MAAMvC,MAAMmE,WAAU,SAAAjP,GAAC,OAAKA,EAAEa,KAAOuB,GAAcpC,EAAEmE,OAAShC,KAC1EmB,EAASW,kBAETX,EAASU,kBALTV,EAASC,c,EAQxBoN,kBAAoB,SAAA3Q,GAChB,IAAMxB,EAAIwB,EAAE4Q,IAAIC,QAAU,EAAKX,MAAMY,QAASrS,EAAIuB,EAAE4Q,IAAIG,QAAU,EAAKb,MAAMc,QAEzE,EAAKd,MAAM/I,YAAciG,GAAUtH,WACnC,EAAKoK,MAAMe,UAAUzS,EAAGC,EA7PR,IA8PX,EAAKyR,MAAM/I,YAAciG,GAAUrH,eACNpD,IAA9B,EAAKuN,MAAMgB,gBACX,EAAKhB,MAAMiB,kB,EAKvBC,kBAAoB,SAACpR,EAAGN,GAChB,EAAKwQ,MAAM/I,YAAciG,GAAUuB,uBACnC3O,EAAEoQ,cAAe,EACjB,EAAKF,MAAMmB,aAAa3R,IACjB,EAAKwQ,MAAM/I,YAAciG,GAAUrH,UAC1C/F,EAAEoQ,cAAe,OAEiBzN,IAA9B,EAAKuN,MAAMgB,eACX,EAAKhB,MAAMoB,aAAa5R,GAGxB,EAAKwQ,MAAM/H,qBACP,+FADJ,WAEQ,EAAK+H,MAAMgB,eAAevS,KAFlC,YAE0C,EAAKuR,MAAM7C,MAAMpC,aAAe,KAAO,MAFjF,YAE0FvL,EAAOf,KAFjG,KAGI,0SACA,qDACA,SAAC4S,GAEOA,EADU,KAAVA,OACQ5O,EAEA6O,OAAOD,GACnB,EAAKrB,MAAMnJ,QAAQ,EAAKmJ,MAAMgB,eAAgBxR,EAAQ6R,GACtD,EAAKrB,MAAMiB,mBAEf,KACA,eAGD,EAAKjB,MAAM/I,YAAciG,GAAUwB,mCAC1C5O,EAAEoQ,cAAe,EAEjB,EAAKF,MAAMuB,cAAc/R,EAAQ,Q,EAIzCgS,gBAAkB,SAAC1R,EAAGkD,GACd,EAAKgN,MAAM/I,YAAciG,GAAUuB,uBACnC3O,EAAEoQ,cAAe,EACjB,EAAKF,MAAMjJ,WAAW/D,IACf,EAAKgN,MAAM/I,YAAciG,GAAUyB,iCAC1C7O,EAAEoQ,cAAe,EACjB,EAAKF,MAAMuB,cAAc,KAAMvO,K,EAIvCyO,oBAAsB,SAAC3R,GACnB,EAAKkQ,MAAMlI,WAAWhI,EAAEE,OAAO1B,IAAKwB,EAAEE,OAAOzB,M,kEA9G5B,IAAD,OACVmT,EAAe,WACjB,EAAKvB,SAAS,CAAEN,YAAa8B,OAAOC,WAAY9B,aAAc6B,OAAOE,eAEzEF,OAAOG,SAAWJ,EAClBA,M,+BA4GM,IAAD,OACL,OACI,kBAAC,QAAD,CACIpT,EAAGI,KAAKsR,MAAMY,QACdrS,EAAGG,KAAKsR,MAAMc,QACdrR,UAAWf,KAAKsR,MAAM/I,YAAciG,GAAUrO,QAC9Cc,UAAWjB,KAAK+S,oBAChB5R,QAASnB,KAAK+R,kBACdjP,MAAO9C,KAAKC,MAAMkR,YAClBpO,OAAQ/C,KAAKC,MAAMmR,cACnB,kBAAC,QAAD,KACI,kBAAC,OAAD,CAAM9O,KAAM,QAAS1C,EAAG,EAAGC,EAAG,EAAGiD,MAAO9C,KAAKC,MAAMkR,YAAapO,OAAQ/C,KAAKC,MAAMmR,eAE/EpR,KAAKsR,MAAM7C,MAAMvC,MAAMS,KAAI,SAACrI,EAAM2I,GAAP,OACvB,kBAAC,EAAD,CACIoG,IAAKpG,EACL1J,WAAYe,EAAKiB,KACjB/B,SAAUc,EAAKrC,GACfqC,KAAMA,EACNC,SAAU,EAAKuN,YAAYxN,GAC3BnD,QAAS,SAACC,GAAD,OAAO,EAAK0R,gBAAgB1R,EAAGkD,SAIhDtE,KAAKsR,MAAM7C,MAAM6E,mBAAmB3G,KAAI,SAACrI,EAAM2I,GAAP,OACpC,kBAAC,GAAD,CACIoG,IAAKpG,EACL1J,WAAYe,EAAKiB,KACjB/B,SAAUc,EAAKrC,GACfqC,KAAMA,EACNC,SAAU,EAAKuN,YAAYxN,QAInCtE,KAAKsR,MAAM7C,MAAMxC,SAASU,KAAI,SAAC7L,EAAQmM,GAAT,OAC1B,kBAAC,EAAD,CACIoG,IAAKpG,EACLnM,OAAQA,EACRC,UAAW,EAAKuQ,MAAM/I,YAAciG,GAAUrO,QAC9CgB,QAAS,SAACC,GAAD,OAAO,EAAKoR,kBAAkBpR,EAAGN,IAC1CE,YAAa,SAAAI,GAAC,OAAI,EAAKmQ,sBAAsBnQ,EAAGN,IAChDG,UAAW,SAAAG,GAAC,OAAI,EAAKyQ,oBAAoBzQ,EAAGN,IAC5CI,WAAY,SAAAE,GAAC,OAAI,EAAKwQ,qBAAqBxQ,EAAGN,e,GAlKjDyS,IAAMC,WA0LpBC,gBAtXS,SAAAxT,GAAK,MAAK,CAC9BwO,MAAOxO,EAAMyO,aAAaD,MAC1BlG,UAAWtI,EAAMyO,aAAanG,UAC9B+J,eAAgBrS,EAAMyO,aAAa4D,eACnCJ,QAASjS,EAAMyO,aAAawD,QAC5BE,QAASnS,EAAMyO,aAAa0D,YAmWL,SAAAxJ,GAAQ,MAAK,CACpCyJ,UAAW,SAACzS,EAAGC,EAAGC,GAAP,OAAkB8I,EN5WR,SAAChJ,EAAGC,EAAGC,GAAP,MAAmB,CACxCsI,KAAMnB,EAAWC,WACjBtH,IACAC,IACAC,UMwWsCuS,CAAUzS,EAAGC,EAAGC,KACtDqI,QAAS,SAAC5E,EAAYC,EAAUE,GAAvB,OAAkCkF,EAAST,EAAQ5E,EAAYC,EAAUE,KAClF+O,aAAc,SAAC3R,GAAD,OAAY8H,ENhWF,SAAC9H,GAAD,MAAa,CACrCsH,KAAMnB,EAAWG,cACjBtG,UM8VmC2R,CAAa3R,KAChDuH,WAAY,SAAC/D,GAAD,OAAUsE,EAASP,EAAW/D,KAC1CqN,qBAAsB,SAAC+B,EAAa9T,EAAGC,GAAjB,OAAuB+I,ENrTb,SAAC8K,EAAa9T,EAAGC,GAAjB,MAAwB,CACxDuI,KAAMnB,EAAWU,uBACjB+L,cACA9T,IACAC,KMiTsD8R,CAAqB+B,EAAa9T,EAAGC,KAC3F6S,aAAc,SAAC5R,GAAD,OAAY8H,ENpVF,SAAC9H,GAAD,MAAa,CACrCsH,KAAMnB,EAAWM,cACjBzG,UMkVmC4R,CAAa5R,KAChDyR,eAAgB,SAACzR,GAAD,OAAY8H,ENhVF,SAAC9H,GAAD,MAAa,CACvCsH,KAAMnB,EAAWO,gBACjB1G,UM8UqCyR,CAAezR,KACpDyI,qBAAsB,SAACC,EAAO7G,EAAMvC,EAAMqJ,EAAkBC,EAAUiK,EAAS/J,GAAzD,OAClBhB,EAASW,EAAqBC,EAAO7G,EAAMvC,EAAMqJ,EAAkBC,EAAUiK,EAAS/J,KAC1FiJ,cAAe,SAAC/R,EAAQwD,GAAT,OAAkBsE,EAASvH,GAAKP,EAAQwD,KACvD8E,WAAY,SAACxJ,EAAGC,GAAJ,OAAU+I,EAASQ,EAAWxJ,EAAGC,QAGlC4T,CAA6CxC,I,oEC3YtD2C,GAAKhE,IAAWC,KAAKC,MAEd+D,GAAkB,SAAC,GAA0E,IAAxElR,EAAuE,EAAvEA,KAAuE,IAAjEyF,YAAiE,MAA1D,SAA0D,EAAhDjH,EAAgD,EAAhDA,QAAS2S,EAAuC,EAAvCA,UAAWC,EAA4B,EAA5BA,UAAWC,EAAiB,EAAjBA,WACpF,OACI,4BAAQ5L,KAAMA,EAAM2L,UAAWH,GAAG,SAAUG,EAAX,4BAAsCD,IAAa3S,QAASA,GACxFwB,EAAMqR,EAAa,0BAAMD,UAAWH,GAAG,SAApB,KAAgCI,EAAhC,KAAsD,K,oBCLhFJ,GAAKhE,IAAWC,KAAKC,MAEdmE,GAAkB,SAAC,GAA0C,IAAxCC,EAAuC,EAAvCA,MAAOvB,EAAgC,EAAhCA,MAAOwB,EAAyB,EAAzBA,IAAKzD,EAAoB,EAApBA,IAAK0D,EAAe,EAAfA,SACtD,OACI,yBAAKL,UAAWH,GAAG,mBACf,yBAAKG,UAAWH,GAAG,iBAAkBM,GACrC,2BACI9L,KAAM,QACN2L,UAAWH,GAAG,UACdjB,MAAOA,EACPwB,IAAKA,EACLzD,IAAKA,EACL0D,SAAUA,M,oBCZpBR,GAAKhE,IAAWC,KAAKC,MAEduE,GAAe,SAAC,GAAyB,IAAvBC,EAAsB,EAAtBA,MAAOF,EAAe,EAAfA,SAClC,OACI,4BAAQL,UAAWH,GAAG,kBAAmBQ,SAAUA,GAC9CE,EAAM3H,KAAI,SAAC4H,EAAMtH,GAAP,OAAiB,4BAAQoG,IAAKpG,EAAO0F,MAAO1F,GAAQsH,Q,oBCLrEX,GAAKhE,IAAWC,KAAKC,MAEd0E,GAAsB,SAAC,GAA8C,IAA5C7R,EAA2C,EAA3CA,KAAMyR,EAAqC,EAArCA,SAAUL,EAA2B,EAA3BA,UAAWU,EAAgB,EAAhBA,UAC7D,OACI,yBAAKV,UAAWH,GAAG,uBAAwBG,IACvC,2BAAOA,UAAWH,GAAG,iBACjB,2BAAOxL,KAAM,WAAYgM,SAAUA,EAAUM,QAASD,IACtD,0BAAMV,UAAWH,GAAG,aAExB,0BAAMG,UAAWH,GAAG,SAAUjR,KCbnC,SAASgS,GAAOC,GAOnB,IANA,IAGIjC,EACA9G,EAJAgJ,EAAa,GACbC,EAAQ,CAACF,GACTG,EAAQ,EAILD,EAAMhJ,QAGT,GAAqB,mBAFrB6G,EAAQmC,EAAME,OAGVD,GAAS,OACN,GAAqB,kBAAVpC,EACdoC,GAAwB,EAAfpC,EAAM7G,YACZ,GAAqB,kBAAV6G,EACdoC,GAAS,OACN,GAAqB,kBAAVpC,IACoB,IAA/BkC,EAAWI,QAAQtC,GAGtB,IAAK9G,KAFLgJ,EAAWzI,KAAKuG,GAENA,EACFA,EAAMuC,eAAerJ,IACrBiJ,EAAM1I,KAAKuG,EAAM9G,IAKjC,OAAOkJ,ECtBX,IAAII,GAAO,GACP1J,GAAQ,GACR2J,GAAa,EAmBF,IACXrV,KAAM,mFAENsV,QAASrK,GAAczD,cAEvB+N,SAAUnK,GAASF,QAEnB5J,KAAM,SAAC4K,EAAUC,EAAO6C,GACpB,IAAM5C,EAAgBH,GAAyBC,EAAUC,GACzDiJ,GAAO,GACPlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,GAAKrU,EAAOf,OAAQ,KAC/C0L,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OA/BjC,SAANC,EAAO5U,EAAQqL,GACjBgJ,GAAKrU,IAAU,EACf2K,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBACjF,IAAI5I,EAAK,EACTkK,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,GAAKlT,KACNwJ,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACpI2J,EAAIzT,EAAIkK,GACRV,GAAMW,KAAK,CAAE7G,KAAMtD,EAAIA,GAAInB,EAAQ2C,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,kBAGpHW,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAEhFuK,IAAcT,GAAO1S,GAmBjByT,CAAI3G,EAAMhP,KAAMoM,GAEhB,IACMjK,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOQ,IACPR,GAAOxI,GAEJ,CACHV,SACAqK,WAAY,CAAC,uJAAD,OACuB5T,EAAS6T,QAAQ,GADxC,mKAEsBvK,GAAmBC,KAFzC,gDAGG2J,GAHH,sCAKZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,8aASJ,8CACA,4BACI,qLACA,gMACA,0LACA,yNCpFPC,GAAb,WACI,aAAe,oBACXjW,KAAKkW,OAAS,GAFtB,sDAUQ,OAA8B,IAAvBlW,KAAKkW,OAAOpK,SAV3B,2BAaS6G,GACD3S,KAAKkW,OAAO9J,KAAKuG,KAdzB,4BAmBQ,OAAO3S,KAAKkW,OAAOC,UAnB3B,6BAuBQ,OAAOnW,KAAKkW,OAAO,KAvB3B,6BAMQ,OAAOlW,KAAKkW,OAAOpK,WAN3B,KCMIsJ,GAAa,EA0BF,IACXrV,KAAM,6EAENsV,QAASrK,GAAczD,cAEvB+N,SAAUnK,GAASF,QAEnB5J,KAAM,SAAC4K,EAAUC,EAAO6C,GACpB,IAAM5C,EAAgBH,GAAyBC,EAAUC,GACrDiJ,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAC/C,IAAI0L,EAAQ,GACZ2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OAtCjC,SAAC1G,EAAO5C,EAAegJ,EAAM1J,GACrC0J,EAAKpG,IAAS,EACd,IAAMqH,EAAQ,IAAIH,GAClBG,EAAMhK,KAAK2C,GACXtD,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO4G,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBAExF,IADA,IAAI/J,EAAS,EAAGmB,EAAK,GACbmU,EAAMC,WACVvV,EAASsV,EAAMpB,MACfvJ,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,gBAClFsB,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,EAAKlT,KACNwJ,EAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACpIoJ,EAAKlT,IAAM,EACXmU,EAAMhK,KAAKnK,GACXwJ,EAAMW,KAAK,CAAEtL,OAAQmB,EAAI0T,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,oBAG7FY,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAGpFuK,IAAcT,GAAOyB,GAASzB,GAAO7T,GAAU6T,GAAO1S,GAmBlDqU,CAAIvH,EAAMhP,KAAMoM,EAAegJ,EAAM1J,GAErC,IACMvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOQ,GACPR,GAAOxI,GAEJ,CACHV,QACAqK,WAAY,CAAC,uJAAD,OACuB5T,EAAS6T,QAAQ,GADxC,mKAEsBvK,GAAmBC,IAFzC,gDAGG2J,GAHH,sCAKZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,ulCAYJ,8CACA,4BACI,qLACA,gOACA,0LACA,sMACA,yNCjFhBZ,GAAa,EAsDF,IACXrV,KAAM,iOAENsV,QAASrK,GAAczD,cAEvB+N,SAAUnK,GAASC,SAEnB/J,KAAM,SAAC4K,EAAUC,EAAO6C,GACpB,IAAM5C,EAAgBH,GAAyBC,EAAUC,GACrDiJ,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAC/C,IAAI0L,EAAQ,GACZ2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OAlE5B,SAAC1G,EAAO9C,EAAUE,EAAegJ,EAAM1J,GACpD,IAAM8K,EAAI,GACJC,EAAI,GACVvK,EAASN,SAAQ,SAAAmB,GACTA,IAAMiC,IAEVwH,EAAEzJ,GAAK8F,OAAO6D,iBACdD,EAAE1J,GAAK,KACPrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,SAAKuV,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,QAEpIwK,EAAExH,GAAS,EACXtD,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO3O,KAAM,IAAKuV,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,qBAXvC,eAarDc,GACL,IAAIiB,GAAK,EAQT,GANAsI,IAAcT,GAAO7H,GAErBb,EAASN,SAAQ,SAAA0B,IACR8H,EAAK9H,MAAe,IAAPP,GAAcyJ,EAAElJ,GAAKkJ,EAAEzJ,MACrCA,EAAIO,MAERkJ,EAAEzJ,KAAO8F,OAAO6D,iBAChB,cAEJtB,EAAKrI,IAAK,EACVrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,gBA1B3B,oBA4B3BsB,EAAcW,IA5Ba,IA4B1D,2BAAiD,CAAC,IAAD,UAAjC7K,EAAiC,EAAvClC,KAAU2D,EAA6B,EAA7BA,OACZyR,EAAKlT,KAETyB,EAASkP,OAAOlP,GAEhB+H,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,UAAU,EAAMC,SAAQiS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,cAC5GyL,EAAEzJ,GAAKpJ,EAAS6S,EAAEtU,IACJ,OAAVuU,EAAEvU,IACFwJ,EAAMW,KAAK,CAAE7G,KAAMiR,EAAEvU,GAAKA,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,cAE/GyL,EAAEtU,GAAMsU,EAAEzJ,GAAKpJ,EACf8S,EAAEvU,GAAM6K,EACRrB,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,UAAU,EAAMC,SAAQiS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACnIN,EAAMW,KAAK,CAAEtL,OAAQmB,EAAI7B,KAAMmW,EAAEtU,GAAK0T,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBAEpGU,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,UAAU,EAAMC,SAAQiS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,gBA3C7D,8BA8C1DW,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,iBAjCvF,IAAK,IAAIgB,KAAKI,EAAU,kBAUhB,MA0BRmJ,IAAcT,GAAO4B,GAmBjBG,CAAS3H,EAAMhP,KAAMkM,EAASU,KAAI,SAAAG,GAAC,OAAIA,EAAE/M,QAAOoM,EAAegJ,EAAM1J,GAErE,IACMvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOQ,GACPR,GAAOxI,GAEJ,CACHV,QACAqK,WAAY,CAAC,uJAAD,OACuB5T,EAAS6T,QAAQ,GADxC,mKAEsBvK,GAAmBC,IAFzC,gDAGG2J,GAHH,sCAKZY,cAAe,CACX,wKACA,4BACI,2IAGA,iOAIJ,0DACA,6BACI,muCAkBJ,8CACA,4BACI,qLACA,0LACA,sMACA,sOACA,qRC1HhBZ,GAAa,EAgEF,IACXrV,KAAM,uOAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASE,UAAYF,GAASC,SAAWD,GAASxG,aAE5DtD,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACrDiJ,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAC/C,IAAI0L,EAAQ,GACZ2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAE/B1G,EAAQ9C,EAASrG,KAAK+Q,MAAM/Q,KAAKgR,SAAW3K,EAASH,SACrD+K,EAlFD,SAAC9H,EAAO9C,EAAUC,EAAOC,EAAegJ,EAAM1J,GACvDS,EAAMP,SAAQ,SAAAvK,GACVqK,EAAMW,KAAK,CAAE7G,KAAMnE,EAAEmE,KAAKxF,KAAMkC,GAAIb,EAAEa,GAAGlC,KAAM0D,UAAU,EAAOC,OAAQtC,EAAEsC,OAAQiS,OAAQnL,EAAWE,OAAQkL,WAAYhL,EAAoBE,YAAaiB,WAAW,OAGzK,IAAMwK,EAAI,GACJO,EAAM,GACZ7K,EAASN,SAAQ,SAAAmB,GACTA,IAAMiC,IAEVwH,EAAEzJ,GAAK8F,OAAO6D,iBACdhL,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,SAAKuV,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAChI+K,EAAIhK,GAAK,SAEbyJ,EAAExH,GAAS,EACXtD,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO3O,KAAM,IAAKuV,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,qBAfpC,eAiBxDc,GACL,IAAIiB,GAAK,EAQT,GANAsI,IAAcT,GAAO7H,GAErBb,EAASN,SAAQ,SAAA0B,IACR8H,EAAK9H,MAAe,IAAPP,GAAcyJ,EAAElJ,GAAKkJ,EAAEzJ,MACrCA,EAAIO,MAERkJ,EAAEzJ,KAAO8F,OAAO6D,iBAChB,cAEJtB,EAAKrI,IAAK,EACVrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,gBA9BxB,oBAgC9BsB,EAAcW,IAhCgB,IAgC7D,2BAAiD,CAAC,IAAD,UAAjC7K,EAAiC,EAAvClC,KAAU2D,EAA6B,EAA7BA,OACZyR,EAAKlT,KAETyB,EAASkP,OAAOlP,GAEhB+H,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,UAAU,EAAOC,SAAQiS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,cAC7GpH,EAAS6S,EAAEtU,IACK,OAAZ6U,EAAI7U,IACJwJ,EAAMW,KAAK,CAAE7G,KAAMuR,EAAI7U,GAAKA,KAAIwB,UAAU,EAAOC,OAAQ6S,EAAEtU,GAAK0T,OAAQnL,EAAWE,OAAQkL,WAAYhL,EAAoBE,YAAaiB,WAAW,IAEvJwK,EAAEtU,GAAMyB,EACRoT,EAAI7U,GAAM6K,EACVrB,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,UAAU,EAAOC,SAAQiS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACpIN,EAAMW,KAAK,CAAEtL,OAAQmB,EAAI7B,KAAMmW,EAAEtU,GAAK0T,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBAEpGU,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,UAAU,EAAOC,SAAQiS,OAAQnL,EAAWE,OAAQkL,WAAYhL,EAAoBE,gBA/CzD,8BAkD7DW,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,iBAjCvF,IAAK,IAAIgB,KAAKI,EAAU,kBAUhB,MA0BR,IAAI4K,EAAY,EAChB,IAAK,IAAM/J,KAAKyJ,EACZM,GAAaN,EAAEzJ,GAInB,OAFAsI,IAAcT,GAAO4B,GAAK5B,GAAOmC,GAE1BD,EAuBeE,CAAKhI,EAAMhP,KAAMkM,EAASU,KAAI,SAAAG,GAAC,OAAIA,EAAE/M,QAAOmM,EAAOC,EAAegJ,EAAM1J,GAGpFvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAQ3B,OANAH,IACIT,GAAOQ,GACPR,GAAOxI,GACPwI,GAAO5F,GACP4F,GAAOkC,GAEJ,CACHpL,QACAqK,WAAY,CAAC,2IAAD,OACqBe,GADrB,8JAEuB3U,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,IAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,2IAGA,iOAIJ,0DACA,6BACI,y1DAsBJ,8CACA,4BACI,uOACA,sMACA,gOACA,gMACA,qLACA,gQC7JPgB,GAAb,WACI,aAAe,oBACXhX,KAAKiX,OAAS,GACdjX,KAAKkX,KAAO,GAHpB,oDAMYtX,GACJI,KAAKiX,OAAOrX,GAAKA,EACjBI,KAAKkX,KAAKtX,GAAK,IARvB,2BAWSA,GACD,OAAIA,IAAMI,KAAKiX,OAAOrX,GACXA,GACXI,KAAKiX,OAAOrX,GAAKI,KAAKmX,KAAKnX,KAAKiX,OAAOrX,IAChCI,KAAKiX,OAAOrX,MAf3B,4BAkBUA,EAAGC,GAGL,IAFAD,EAAII,KAAKmX,KAAKvX,OACdC,EAAIG,KAAKmX,KAAKtX,KAENG,KAAKkX,KAAKtX,GAAKI,KAAKkX,KAAKrX,GAA7B,OACa,CAACA,EAAGD,GAAZA,EADL,KACQC,EADR,KAEAG,KAAKiX,OAAOpX,GAAKD,EACjBI,KAAKkX,KAAKtX,IAAMI,KAAKkX,KAAKrX,OAzBtC,KCKIuV,GAAa,EAqCF,IACXrV,KAAM,yPAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASE,UAAYF,GAASC,SAAWD,GAASxG,aAE5DtD,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAIrK,EAAQ,GACZ2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAE/BoB,EAnDE,SAAC5K,EAAUC,EAAOT,GAC9B,IAAM2L,EAAM,IAAIJ,GAChB/K,EAASN,SAAQ,SAAAmB,GAAC,OAAIsK,EAAIC,QAAQvK,EAAE/M,SACpCmM,EAAMM,MAAK,SAAC3D,EAAG4D,GAAJ,OAAU5D,EAAEnF,OAAS+I,EAAE/I,UAElCwI,EAAMP,SAAQ,SAAAvK,GACVqK,EAAMW,KAAK,CAAE7G,KAAMnE,EAAEmE,KAAKxF,KAAMkC,GAAIb,EAAEa,GAAGlC,KAAM0D,UAAU,EAAOC,OAAQtC,EAAEsC,OAAQiS,OAAQnL,EAAWE,OAAQkL,WAAYhL,EAAoBE,YAAaiB,WAAW,OAGzK,IAAI8K,EAAY,EACZtR,EAAO,EAAGtD,EAAK,EAAGyB,EAAS,EAsB/B,OArBAwI,EAAMP,SAAQ,SAAAvK,GACVmE,EAAOnE,EAAEmE,KAAKxF,KACdkC,EAAKb,EAAEa,GAAGlC,KACV2D,EAASkP,OAAOxR,EAAEsC,QAClB+H,EAAMW,KAAK,CAAE7G,OAAMtD,KAAIwB,UAAU,EAAOC,SAAQiS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,cAC1GsM,EAAID,KAAK5R,KAAU6R,EAAID,KAAKlV,IAC5B4U,GAAanT,EACb0T,EAAIE,MAAM/R,EAAMtD,GAChBwJ,EAAMW,KAAK,CAAE7G,OAAMtD,KAAIwB,UAAU,EAAOC,SAAQiS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,eAEzGW,EAAMW,KAAK,CAAE7G,OAAMtD,KAAIwB,UAAU,EAAOC,SAAQiS,OAAQnL,EAAWE,OAAQkL,WAAYhL,EAAoBE,iBAInHsK,IACIT,GAAOyC,GACPzC,GAAOkC,GACPlC,GAAOpP,GACPoP,GAAO1S,GACP0S,GAAOjR,GAEJmT,EAmBeU,CAAQtL,EAAUC,EAAOT,GAGrCvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAE3B,MAAO,CACH9J,QACAqK,WAAY,CAAC,2IAAD,OACqBe,GADrB,8JAEuB3U,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,IAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,0IAIJ,0DACA,6BACI,owBASJ,8CACA,4BACI,gMACA,0LCtFhBZ,GAAa,EA+BF,IACXrV,KAAM,uHAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASxG,aAEnBtD,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACrDiJ,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAC/C,IAAI0L,EAAQ,GACZ2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAG/B+B,EAjDF,SAACzI,EAAO9C,EAAUE,EAAegJ,EAAM1J,GAC/C0J,EAAKpG,IAAS,EACd,IAAMqH,EAAQ,IAAIH,GAClBG,EAAMhK,KAAK2C,GACXtD,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO4G,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBAExF,IADA,IAAI/J,EAAS,EAAGmB,EAAK,GACbmU,EAAMC,WACVvV,EAASsV,EAAMpB,MACfvJ,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,gBAClFsB,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,EAAKlT,KACNwJ,EAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAOkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,cAC7GqK,EAAKlT,IAAM,EACXmU,EAAMhK,KAAKnK,GACXwJ,EAAMW,KAAK,CAAEtL,OAAQmB,EAAI0T,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,oBAG7FY,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAGpFuK,IAAcT,GAAOyB,GAASzB,GAAO7T,GAAU6T,GAAO1S,GArBG,oBAsBpCgK,GAtBoC,IAsBzD,2BAA+B,CAAC,IAArBnL,EAAoB,QAC3B,IAAKqU,EAAKrU,EAAOf,MACb,OAAO,GAxB0C,8BA0BzD,OAAO,EAuBiBuW,CADNrK,EAASrG,KAAK+Q,MAAM/Q,KAAKgR,SAAW3K,EAASH,SAC7B/L,KAAMkM,EAAUE,EAAegJ,EAAM1J,GAG7DvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAO3B,OALAH,IACIT,GAAO6C,GACP7C,GAAOQ,GACPR,GAAOxI,GAEJ,CACHV,QACAqK,WAAY,CAAC,4BAAD,OACA0B,EAAc,6CAAY,0DAD1B,8JAEuBtV,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,IAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,u0BASJ,8CACA,4BACI,qLACA,gOACA,0LACA,sMACA,yNCjGhBb,GAAO,GACP1J,GAAQ,GACR2J,GAAa,EAEXM,GAAM,SAANA,EAAO5U,EAAQqL,GAA2C,IAGxDlK,EAH4BgV,EAA2B,wDAAjB,EAAG1U,EAAc,uDAAN,EACrD4S,GAAKrU,GAAUyB,EACfkJ,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAkB,IAAVpT,EAAcuH,EAAanJ,QAAUmJ,EAAalJ,QAASgV,WAAYhL,EAAoBC,gBAF7D,oBAIpCsB,EAAcrL,IAJsB,IAI3D,2BAA8C,CAAC,IAApC+U,EAAmC,QAE1C,GADA5T,EAAK4T,EAAS9V,KACToV,GAAKlT,IAKH,GAAKgV,IAAWhV,GAAQkT,GAAKlT,KAAQM,EAExC,OADAkJ,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,eAC1G,MAPI,CAEX,GADAW,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,eACvG4K,EAAIzT,EAAIkK,EAAerL,EAAQ,EAAIyB,GACpC,OAAO,EACXkJ,GAAMW,KAAK,CAAE7G,KAAMtD,EAAIA,GAAInB,EAAQ2C,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,gBAVzD,8BAgB3D,OAAO,GAGI,IACX/K,KAAM,yIAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASxG,aAEnBtD,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACzDiJ,GAAO,GACPlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,GAAKrU,EAAOf,MAAQ,KAC/C0L,GAAQ,GACR2J,GAAa,EAEb,IAVuB,EAUjBG,EAAYtC,OAAOuC,YAAYC,MAEjCgC,GAAc,EAZK,cAaMxL,GAbN,IAavB,2BAAuC,CAAC,IAAtBnL,EAAqB,QAA3Bf,KACR,IAAKoV,GAAKrU,MACN2W,GAAe/B,GAAI5U,EAAQqL,IAEvB,OAjBW,8BAqBvB,IACMjK,EADU+Q,OAAOuC,YAAYC,MACRF,EAO3B,OALAH,IACIT,GAAO8C,GACP9C,GAAOQ,IACPR,GAAOxI,GAEJ,CACHV,SACAqK,WAAY,CAAC,4BAAD,OACA2B,EAAc,+DAAe,4EAD7B,8JAEuBvV,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,KAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,8wCAkBJ,8CACA,4BACI,qLACA,sOACA,yNC5FhBZ,GAAa,EAEXkB,GAAM,SAACvH,EAAO9C,EAAUE,EAAegJ,EAAM1J,GAC/C,IAAM8K,EAAI,GAAIC,EAAI,GAClBvK,EAASN,SAAQ,SAAA7K,GACbyV,EAAEzV,EAAOf,MAAQ6S,OAAO6D,iBACxBD,EAAE1V,EAAOf,OAAS,KAEtBoV,EAAKpG,IAAS,EACd,IAAMqH,EAAQ,IAAIH,GAClBG,EAAMhK,KAAK,CAAEtL,OAAQiO,EAAO2I,MAAO,IACnCjM,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO4G,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBAGxF,IADA,IAAI/J,EAAS,EAAG4W,EAAQ,EAAGzV,EAAK,GACxBmU,EAAMC,WACVvV,EAASsV,EAAMuB,OAAO7W,OACtB4W,EAAQtB,EAAMpB,MAAM0C,MACpBnB,EAAEzV,GAAU4W,EACZvL,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,EAAKlT,KACNkT,EAAKlT,IAAM,EACXmU,EAAMhK,KAAK,CAAEtL,OAAQmB,EAAIyV,MAAOA,EAAQ,IACxClB,EAAEvU,GAAMnB,MAKpB,MAAsB,IAAf0V,EAAE1V,IACL2K,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC5GN,EAAMW,KAAK,CAAE7G,KAAMiR,EAAE1V,GAASmB,GAAInB,EAAQ2C,UAAU,EAAOkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACjJjL,EAAS0V,EAAE1V,GAaf,OAXA2K,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC5GN,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO3O,KAAMsX,EAAO/B,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,qBAE7GqK,IACIT,GAAO4B,GACP5B,GAAO6B,GACP7B,GAAOyB,GACPzB,GAAO7T,GACP6T,GAAO+C,GACP/C,GAAO1S,GAEJyV,GAiCI,IACX3X,KAAM,4GAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASxG,aAAewG,GAASE,UAE3ChK,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAMrK,EAAQ,GACRU,EAAgBH,GAAyBC,EAAUC,GACzDkJ,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAE/B3V,EA/CK,SAACmM,EAAUC,EAAOC,EAAeV,GAChD,IAAI0J,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAE/C,IAJ0D,EAItD6X,EAAiB,GACjB9X,EAAS8S,OAAO6D,iBALsC,cAM9BxK,GAN8B,IAM1D,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACRkM,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAC/C6X,EAAe7I,GAASuH,GAAIvH,EAAO9C,EAAUE,EAAegJ,EAAM1J,GAClEA,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO3O,KAAMwX,EAAe7I,GAAQ4G,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAEtJN,EAAMW,KAAK,CAAEuJ,OAAQ7L,EAAaK,qBAAsByL,WAAYhL,EAAoBC,cAAekB,WAAW,IAClHN,EAAMW,KAAK,CAAEuJ,OAAQnL,EAAWL,qBAAsByL,WAAYhL,EAAoBE,YAAaiB,WAAW,IAE9GjM,EAAS8F,KAAKuO,IAAIrU,EAAQ8X,EAAe7I,KAda,kDAiBlC9C,GAjBkC,IAiB1D,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACJ6X,EAAe9K,KAAOhN,GACtB2L,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,KAnB7D,8BA2B1D,OALAqJ,IACIT,GAAOQ,GACPR,GAAOiD,GACPjD,GAAO7U,GAEJA,EAoBY+X,CAAW5L,EAAUC,EAAOC,EAAeV,GAGpDvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOxI,GACPwI,GAAO7U,GAEJ,CACH2L,QACAqK,WAAY,CAAC,wEAAD,OACShW,GADT,8JAEuBoC,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,IAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,iJAGA,4IAIJ,0DACA,6BACI,k3CAWJ,8CACA,4BACI,gMACA,uWACA,gMACA,wNAEJ,oNC7IZZ,GAAa,EAEXkB,GAAM,SAACvH,EAAO9C,EAAUE,EAAegJ,EAAM1J,GAC/C,IAAM8K,EAAI,GAAIC,EAAI,GAClBvK,EAASN,SAAQ,SAAA7K,GACbyV,EAAEzV,EAAOf,MAAQ6S,OAAO6D,iBACxBD,EAAE1V,EAAOf,OAAS,KAEtBoV,EAAKpG,IAAS,EACd,IAAMqH,EAAQ,IAAIH,GAClBG,EAAMhK,KAAK,CAAEtL,OAAQiO,EAAO2I,MAAO,IACnCjM,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO4G,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBAGxF,IADA,IAAI/J,EAAS,EAAG4W,EAAQ,EAAGzV,EAAK,GACxBmU,EAAMC,WACVvV,EAASsV,EAAMuB,OAAO7W,OACtB4W,EAAQtB,EAAMpB,MAAM0C,MACpBnB,EAAEzV,GAAU4W,EACZvL,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,EAAKlT,KACNkT,EAAKlT,IAAM,EACXmU,EAAMhK,KAAK,CAAEtL,OAAQmB,EAAIyV,MAAOA,EAAQ,IACxClB,EAAEvU,GAAMnB,MAKpB,MAAsB,IAAf0V,EAAE1V,IACL2K,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC5GN,EAAMW,KAAK,CAAE7G,KAAMiR,EAAE1V,GAASmB,GAAInB,EAAQ2C,UAAU,EAAOkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACjJjL,EAAS0V,EAAE1V,GAaf,OAXA2K,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC5GN,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO3O,KAAMsX,EAAO/B,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,qBAE7GqK,IACIT,GAAOyB,GACPzB,GAAO4B,GACP5B,GAAO6B,GACP7B,GAAO7T,GACP6T,GAAO+C,GACP/C,GAAO1S,GAEJyV,GAiCI,IACX3X,KAAM,uMAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASxG,aAAewG,GAASE,UAE3ChK,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAMrK,EAAQ,GACRU,EAAgBH,GAAyBC,EAAUC,GACzDkJ,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAE/BqC,EA/CO,SAAC7L,EAAUC,EAAOC,EAAeV,GAClD,IAAI0J,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAE/C,IAJ4D,EAIxD6X,EAAiB,GACjBE,EAAW,EAL6C,cAMhC7L,GANgC,IAM5D,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACRkM,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,KAC/C6X,EAAe7I,GAASuH,GAAIvH,EAAO9C,EAAUE,EAAegJ,EAAM1J,GAClEA,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO3O,KAAMwX,EAAe7I,GAAQ4G,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAEtJN,EAAMW,KAAK,CAAEuJ,OAAQ7L,EAAaK,qBAAsByL,WAAYhL,EAAoBC,cAAekB,WAAW,IAClHN,EAAMW,KAAK,CAAEuJ,OAAQnL,EAAWL,qBAAsByL,WAAYhL,EAAoBE,YAAaiB,WAAW,IAE9G+L,EAAWlS,KAAK8K,IAAIoH,EAAUF,EAAe7I,KAdW,kDAiBpC9C,GAjBoC,IAiB5D,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACJ6X,EAAe9K,KAAOgL,GACtBrM,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,KAnB3D,8BA2B5D,OALAqJ,IACIT,GAAOQ,GACPR,GAAOiD,GACPjD,GAAOmD,GAEJA,EAoBcC,CAAa9L,EAAUC,EAAOC,EAAeV,GAGxDvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOxI,GACPwI,GAAOmD,GAEJ,CACHrM,QACAqK,WAAY,CAAC,8EAAD,OACUgC,GADV,8JAEuB5V,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,IAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,iJAGA,4IAIJ,0DACA,6BACI,47CAWJ,8CACA,4BACI,gMACA,uWACA,gMACA,6SAEJ,oNC9IZb,GAAO,GACP1J,GAAQ,GACRuM,GAAc,GACdC,GAAgB,EAChBC,GAAiB,EACjB9C,GAAa,EAEXM,GAAM,SAANA,EAAO5U,EAAQqL,GACjBgJ,GAAKrU,IAAU,EACf2K,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBACjF,IAAI5I,EAAK,EACTkK,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,GAAKlT,KACNwJ,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACpI2J,EAAIzT,EAAIkK,GACRV,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,YAAaiB,WAAW,QAGhJN,GAAMW,KAAK,CAAEtL,SAAQV,KAAM6X,KAAiBtC,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC/IN,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAChFmN,GAAY5L,KAAKtL,GAEjBsU,IAAcT,GAAO1S,IAsBV,IACXlC,KAAM,oJAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASG,SAAWH,GAASI,QAEvClK,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACzDT,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OAlC7B,SAACxJ,EAAUC,EAAOC,EAAeV,GAC7C0J,GAAO,GACP6C,GAAc,GACd/L,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,GAAKrU,EAAOf,OAAQ,KAC/CkY,GAAgB,EAChBC,GAAiB,EALsC,oBAO3BjM,GAP2B,IAOvD,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACHoV,GAAKpG,IACN2G,GAAI3G,EAAO5C,IAToC,kDAavC6L,GAAYG,WAb2B,IAavD,2BAAuC,CAAC,IAA7BrL,EAA4B,QACnCrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM8X,KAAkBvC,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC7IN,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaE,SAAU4L,WAAYhL,EAAoBC,iBAfpC,+BAoCnDuN,CAAQnM,EAAUC,EAAOC,EAAeV,IAExC,IACMvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAS3B,OAPAH,IACIT,GAAOxI,GACPwI,GAAOQ,IACPR,GAAOqD,IACPrD,GAAOsD,IACPtD,GAAOuD,IAEJ,CACHzM,SACAqK,WAAY,CAAC,uJAAD,OACuB5T,EAAS6T,QAAQ,GADxC,mKAEsBvK,GAAmBC,KAFzC,gDAGG2J,GAHH,sCAKZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,s1CAuBJ,8CACA,4BACI,qLACA,gMACA,0LACA,+KACA,mKACA,yNC3HhBb,GAAO,GACP1J,GAAQ,GACR4M,GAAQ,EACRC,GAAM,GAAIC,GAAO,GACjBC,GAAe,EACfpD,GAAa,EAEXM,GAAM,SAANA,EAAO5U,EAAQqL,GAAgC,IAAjB8K,EAAgB,wDAAN,EAC1C9B,GAAKrU,IAAU,EACfwX,GAAIxX,GAAUyX,GAAKzX,GAAUuX,KAC7B5M,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC3GN,GAAMW,KAAK,CAAEtL,SAAQV,KAAMkY,GAAIxX,GAAU,IAAMyX,GAAKzX,GAAS6U,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,qBAJ3E,oBAMvBoB,EAAcrL,IANS,IAMhD,2BAAgD,CAAC,IAA/BmB,EAA8B,QAApClC,KACJkC,IAAOgV,IAEN9B,GAAKlT,IAWNwJ,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,cAC5GyN,GAAKzX,GAAU8E,KAAKuO,IAAIoE,GAAKzX,GAASwX,GAAIrW,IAC1CwJ,GAAMW,KAAK,CAAEtL,SAAQV,KAAMkY,GAAIxX,GAAU,IAAMyX,GAAKzX,GAAS6U,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC1JN,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,gBAbhHW,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,cAC5G4K,EAAIzT,EAAIkK,EAAerL,GACvByX,GAAKzX,GAAU8E,KAAKuO,IAAIoE,GAAKzX,GAASyX,GAAKtW,IAC3CwJ,GAAMW,KAAK,CAAEtL,SAAQV,KAAMkY,GAAIxX,GAAU,IAAMyX,GAAKzX,GAAS6U,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC1JN,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,cAC5GyN,GAAKtW,GAAMqW,GAAIxX,OACb0X,GACF/M,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,KAAIwB,UAAU,EAAOkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,kBAjB1E,8BA2BhDW,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,iBAiBrE,IACX9K,KAAM,sEAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASxG,aAEnBtD,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACzDT,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OA7BzB,SAACxJ,EAAUC,EAAOC,GAClCgJ,GAAO,GACPlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,GAAKrU,EAAOf,OAAQ,KAC/CsY,GAAQ,EACRC,GAAM,GACNC,GAAO,GACPC,GAAe,EANqC,oBAQxBvM,GARwB,IAQpD,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACHoV,GAAKpG,IACN2G,GAAI3G,EAAO5C,IAViC,+BA+BhDsM,CAAYxM,EAAUC,EAAOC,GAE7B,IACMjK,EADU+Q,OAAOuC,YAAYC,MACRF,EAU3B,OARAH,IACIT,GAAOQ,IACPR,GAAOxI,GACPwI,GAAO0D,IACP1D,GAAO2D,IACP3D,GAAO4D,IACP5D,GAAO6D,IAEJ,CACH/M,SACAqK,WAAY,CAAC,sGAAD,OACc0C,IADd,8JAEuBtW,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,KAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,20CAwBJ,8CACA,4BACI,qLACA,gMACA,0LACA,+KACA,oIACA,+NCpIhBb,GAAO,GACP1J,GAAQ,GACR4M,GAAQ,EACRC,GAAM,GAAIC,GAAO,GACjBG,GAA0B,EAC1BC,GAAsB,GACtBvD,GAAa,EAEXM,GAAM,SAANA,EAAO5U,EAAQqL,GAAgC,IAAjB8K,EAAgB,wDAAN,EAC1C9B,GAAKrU,IAAU,EACfwX,GAAIxX,GAAUyX,GAAKzX,GAAUuX,KAC7B5M,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC3GN,GAAMW,KAAK,CAAEtL,SAAQV,KAAMkY,GAAIxX,GAAU,IAAMyX,GAAKzX,GAAS6U,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,qBAC3H,IALgD,EAK5C6N,EAAW,EALiC,cAOvBzM,EAAcrL,IAPS,IAOhD,2BAAgD,CAAC,IAA/BmB,EAA8B,QAApClC,KACJkC,IAAOgV,IAEN9B,GAAKlT,IAaNwJ,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,cAC5GyN,GAAKzX,GAAU8E,KAAKuO,IAAIoE,GAAKzX,GAASwX,GAAIrW,IAC1CwJ,GAAMW,KAAK,CAAEtL,SAAQV,KAAMkY,GAAIxX,GAAU,IAAMyX,GAAKzX,GAAS6U,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC1JN,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,gBAfhHW,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,cAC5G4K,EAAIzT,EAAIkK,EAAerL,GACvByX,GAAKzX,GAAU8E,KAAKuO,IAAIoE,GAAKzX,GAASyX,GAAKtW,IAC3CwJ,GAAMW,KAAK,CAAEtL,SAAQV,KAAMkY,GAAIxX,GAAU,IAAMyX,GAAKzX,GAAS6U,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC1JN,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,GAAIA,EAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,cAC3GyN,GAAKtW,IAAOqW,GAAIxX,KAAyB,IAAZmW,IAAmB0B,GAAoB7X,OACnE4X,GACFC,GAAoB7X,IAAU,EAC9B2K,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,mBAEpF+N,KArBsC,8BA8B3CD,GAAoB7X,KACrB2K,GAAMW,KAAK,CAACtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,iBAE9D,IAAZoM,GAAmB2B,EAAW,MAC7BF,GACFjN,GAAMW,KAAK,CAACtL,SAAQ6U,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,kBAIzFuK,IAAcT,GAAOiE,IAoBV,IACX7Y,KAAM,6HAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASxG,aAEnBtD,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACzDT,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OAhCd,SAACxJ,EAAUC,EAAOC,GAC7CgJ,GAAO,GACPlJ,EAASN,SAAQ,SAAA7K,GACbqU,GAAKrU,EAAOf,OAAQ,EACpB4Y,GAAoB7X,EAAOf,OAAQ,KAEvCsY,GAAQ,EACRC,GAAM,GACNC,GAAO,GACPG,GAA0B,EATqC,oBAWnCzM,GAXmC,IAW/D,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACHoV,GAAKpG,IACN2G,GAAI3G,EAAO5C,IAb4C,+BAkC3D0M,CAAuB5M,EAAUC,EAAOC,GAExC,IACMjK,EADU+Q,OAAOuC,YAAYC,MACRF,EAW3B,OATAH,IACIT,GAAOQ,IACPR,GAAOxI,GACPwI,GAAO0D,IACP1D,GAAO2D,IACP3D,GAAO4D,IACP5D,GAAO+D,IACP/D,GAAOgE,IAEJ,CACHlN,SACAqK,WAAY,CAAC,6JAAD,OACwB4C,IADxB,8JAEuBxW,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,KAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,smDA4BJ,8CACA,4BACI,qLACA,gMACA,0LACA,6MACA,+KACA,+NCzJhBb,GAAO,GACP1J,GAAQ,GACRuM,GAAc,GACdC,GAAgB,EAChBC,GAAiB,EACjB9C,GAAa,EAEXM,GAAM,SAANA,EAAO5U,EAAQqL,GACjBgJ,GAAKrU,IAAU,EACf2K,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBACjF,IAAI5I,EAAK,EACTkK,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,GAAKlT,KACNwJ,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IAChI2J,EAAIzT,EAAIkK,GACRV,GAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,YAAaiB,WAAW,QAG5IN,GAAMW,KAAK,CAAEtL,SAAQV,KAAM6X,KAAiBtC,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IAC/IN,GAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAChFmN,GAAY5L,KAAKtL,GAEjBsU,IAAcT,GAAO1S,IAqEV,IACXlC,KAAM,8RAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASG,SAEnBjK,KAAM,SAAC4K,EAAUC,GACb,GAAwB,IAApBD,EAASH,OACT,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GACnD4M,EAAwBpM,GAAiCT,EAAUC,GAEzET,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,OAnF7B,SAACxJ,EAAUC,EAAOC,EAAeV,GAC7C0J,GAAO,GACP6C,GAAc,GACd/L,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,GAAKrU,EAAOf,OAAQ,KAC/CkY,GAAgB,EAChBC,GAAiB,EALsC,oBAO3BjM,GAP2B,IAOvD,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACHoV,GAAKpG,IACN2G,GAAI3G,EAAO5C,IAToC,kDAavC6L,GAAYG,WAb2B,IAavD,2BAAuC,CAAC,IAA7BrL,EAA4B,QACnCrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM8X,KAAkBvC,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,mBAAoBgB,WAAW,IACnJN,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaE,SAAU4L,WAAYhL,EAAoBC,iBAfpC,+BAqFnDuN,CAAQnM,EAAUC,EAAOC,EAAeV,IACxC,IAAMsN,EAnES,SAAC9M,EAAUC,EAAOC,EAAeV,GAAW,IAAD,gBACrCS,GADqC,IAC9D,2BAAgC,CAAC,IAAD,UAApB3G,EAAoB,EAApBA,KAAMtD,EAAc,EAAdA,GACdwJ,EAAMW,KAAK,CAAE7G,KAAMA,EAAKxF,KAAMkC,GAAIA,EAAGlC,KAAM0D,UAAU,EAAMkS,OAAQnL,EAAWG,KAAMiL,WAAYhL,EAAoBE,YAAaiB,WAAW,KAFlF,8BAI1DG,EAAMJ,OAAS,IACfL,EAAMA,EAAMK,OAAS,GAAGC,WAAY,GAExCE,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,GAAKrU,EAAOf,OAAQ,KAE/C,IAT8D,EAS1DgZ,EAAmB,EAEjBC,EAAgB,SAAhBA,EAAiBlY,GACnBqU,GAAKrU,IAAU,EACf2K,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC3GN,EAAMW,KAAK,CAAEtL,SAAQV,KAAM2Y,EAAkBpD,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,qBAE3G,IAAI9I,EAAK,EACTkK,EAAcrL,GAAQ6K,SAAQ,SAAAkK,GAC1B5T,EAAK4T,EAAS9V,KACToV,GAAKlT,KACNwJ,EAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IAChIiN,EAAc/W,GACdwJ,EAAMW,KAAK,CAAE7G,KAAMzE,EAAQmB,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWR,SAAU4L,WAAYhL,EAAoBE,YAAaiB,WAAW,QAI5IN,EAAMW,KAAK,CAAEtL,SAAQ6U,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAEhFuK,IAAcT,GAAO1S,IA5BqC,cA+B9C+V,IA/B8C,IA+B9D,2BAA6B,CAAC,IAAnBlL,EAAkB,QACpBqI,GAAKrI,KACNkM,EAAclM,KACZiM,IAlCoD,kDAsCrC7M,GAtCqC,IAsC9D,2BAAgC,CAAC,IAAD,UAApB3G,EAAoB,EAApBA,KAAMtD,EAAc,EAAdA,GACdwJ,EAAMW,KAAK,CAAE7G,KAAMA,EAAKxF,KAAMkC,GAAIA,EAAGlC,KAAM0D,UAAU,EAAMkS,OAAQnL,EAAWG,KAAMiL,WAAYhL,EAAoBE,YAAaiB,WAAW,KAvClF,8BA4C9D,OAFAqJ,IAAcT,GAAOoE,GAEdA,EAuBsBE,CAAehN,EAAUC,EAAO4M,EAAuBrN,IAG1EvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAW3B,OATAH,IACIT,GAAOxI,GACPwI,GAAOmE,GACPnE,GAAOoE,GACPpE,GAAOQ,IACPR,GAAOqD,IACPrD,GAAOsD,IACPtD,GAAOuD,IAEJ,CACHzM,SACAqK,WAAY,CAAC,0NAAD,OACmCiD,GADnC,8JAEuB7W,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,KAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,yIAGA,4IAIJ,0DACA,6BACI,06CAoBJ,8CACA,4BACI,qLACA,gMACA,0LACA,+KACA,6NACA,kWACA,kKC9KhBvK,GAAQ,GACR2J,GAAa,EA8JF,IACXrV,KAAM,sEAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASF,QAEnB5J,KAAM,SAAC4K,EAAUC,GACb,GAAqB,IAAjBA,EAAMJ,OACN,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GAEzDT,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAEjCyD,EA9KU,SAACjN,EAAUC,EAAOC,EAAeV,GACnD,IAAIhI,EAAWyI,EAAM,GAAGG,aAClByM,EAAwBpM,GAAiCT,EAAUC,GAIzE,GAFAkJ,IAAcT,GAAOlR,GAAYkR,GAAOmE,GAEnCrV,EAsBE,CACH,IAAI0V,EAAiB,EACjBC,EAAgB,EAChBC,EAAS,EACbjE,IAAcT,GAAOwE,GAAkBxE,GAAOyE,GAAiBzE,GAAO0E,GAJnE,oBAMqBpN,GANrB,IAMH,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KAER,GAAe,KADfsZ,EAASP,EAAsBhM,GAAGhB,OAASK,EAAcW,GAAGhB,QAC1C,CAEd,KADEqN,EACmB,EAEjB,OADA1N,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAMiZ,EAAQ1D,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBAC7F,EAEPU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAMiZ,EAAQ1D,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,0BAC3G,IAAgB,IAAZsO,EAAe,CAEtB,KADED,EACED,EAAiB,EAEjB,OADA1N,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAMiZ,EAAQ1D,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBAC7F,EAEPU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAMiZ,EAAQ1D,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,yBAC3G,IAAe,IAAXsO,EAEP,OADA5N,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAMiZ,EAAQ1D,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBAC7F,EAEPU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,uBA1B1G,mCAtBQ,qBAGakB,GAHb,yBAGOa,EAHP,QAGC/M,KACRoM,EAAcW,GAAKX,EAAcW,GAAG8D,QAAO,SAAAiF,GAAQ,OAAIA,EAAS9V,OAAS+M,MAD7E,2BAAmC,IAHxB,8BAOX,IAAIwM,EAAc,EAClBlE,IAAcT,GAAO2E,GARV,oBAUarN,GAVb,IAUX,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACR,GAAIoM,EAAcW,GAAGhB,OAAS,IAAM,EAAG,CAEnC,KADEwN,EACgB,EAEd,OADA7N,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBACxF,EAEPU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,0BAEzGU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,sBAnBlG,+BAqDf,IAAMoK,EAAO,GACblJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,MACnC,SAAN2V,EAAO5I,GACTqI,EAAKrI,IAAK,EACVrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBAFrE,oBAGUsB,EAAcW,IAHxB,IAGf,2BAA2C,CAAC,IAA1B7K,EAAyB,QAA/BlC,KACHoV,EAAKlT,KACNwJ,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,WAAUkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACrH2J,EAAIzT,KANG,8BASf,GAAIwB,EAAU,CAAC,IAAD,gBACiBqV,EAAsBhM,IADvC,IACV,2BAAqD,CAAC,IAApCvH,EAAmC,QAAzCxF,KACHoV,EAAK5P,KACNkG,EAAMW,KAAK,CAAE7G,OAAMtD,GAAI6K,EAAGrJ,WAAUkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACrH2J,EAAInQ,KAJF,+BAQdkG,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAGvF6K,CAAIzJ,EAAS,GAAGlM,MAChBqV,IAAcT,GAAOQ,GAlFwC,oBAoFrClJ,GApFqC,IAoF7D,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACR,IAAKoV,EAAKrI,GAAI,CACV,GAAIX,EAAcW,GAAGhB,OAAS,EAG1B,OAFAL,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC/GN,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,GAAIkK,EAAcW,GAAG,GAAG/M,KAAM0D,WAAUkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,eACrH,EAEPW,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,kBA3FlC,8BAgG7D,OAAO,EA8EW0O,CAActN,EAAUC,EAAO9I,OAAOoW,OAAO,GAAIrN,GAAgBV,IAC3EyN,IACAzN,GAAMW,KAAK,CAAEuJ,OAAQ7L,EAAaK,qBAAsByL,WAAYhL,EAAoBC,cAAekB,WAAW,IAClHN,GAAMW,KAAK,CAAEuJ,OAAQnL,EAAWL,qBAAsByL,WAAYhL,EAAoBE,YAAaiB,WAAW,IA9EpG,SAACE,EAAUC,EAAOC,EAAeV,GACnD,IAD6D,EACvDhI,EAAWyI,EAAM,GAAGG,aACpByM,EAAwBpM,GAAiCT,EAAUC,GAErE6C,EAAQ9C,EAAS,GAAGlM,KAJqC,cAKrCkM,GALqC,IAK7D,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACR,GAAK0D,GAMD,GAAIqV,EAAsBhM,GAAGhB,OAASK,EAAcW,GAAGhB,SAAW,EAAG,CACjEiD,EAAQjC,EACR,YAPJ,GAAIX,EAAcW,GAAGhB,OAAS,IAAM,EAAG,CACnCiD,EAAQjC,EACR,QATiD,8BAkB7DrB,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO4G,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,gBAErFpH,IACA0I,EAAgB2M,GAEpB,IAGIW,EAHEC,EAAkB,GACpBC,EAAU,EAGd,IAFAD,EAAgBtN,KAAK2C,GAEd2K,EAAgB5N,OAAS,GAE5B,GAAIK,EADJsN,EAAMC,EAAgBA,EAAgB5N,OAAS,IACxBA,OAAS,EAAG,CAC/B4N,EAAgBtN,KAAKD,EAAcsN,GAAK,GAAG1Z,MAC3C,IAAMkC,EAAKkK,EAAcsN,GAAKtD,QAAQpW,KACjC0D,IACD0I,EAAclK,GAAMkK,EAAclK,GAAI2O,QAAO,SAAAxP,GAAC,OAAIA,EAAErB,OAAS0Z,MAEjEhO,EAAMW,KAAK,CAAE7G,KAAMkU,EAAKxX,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,cAE1GsK,IAAcT,GAAO1S,QAErByX,EAAgB1E,MACZ0E,EAAgB5N,OAAS,IACT,IAAZ6N,GACAlO,EAAMW,KAAK,CAAEtL,OAAQ2Y,EAAK9D,OAAQ7L,EAAanJ,QAASiV,WAAYhL,EAAoBC,cAAekB,WAAW,IACtHN,EAAMW,KAAK,CAAE7G,KAAMkU,EAAKxX,GAAIyX,EAAgBA,EAAgB5N,OAAS,GAAIrI,UAAU,EAAMC,SAAUiW,EAAShE,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,eAKjLsK,IACIT,GAAOlR,GACPkR,GAAOmE,GACPnE,GAAO5F,GACP4F,GAAO+E,GACP/E,GAAOgF,GACPhF,GAAO8E,GAyBHG,CAAc3N,EAAUC,EAAOC,EAAeV,KAGlD,IACMvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOxI,GACPwI,GAAOuE,GAEJ,CACHzN,SACAqK,WAAY,CAAC,uEAAD,OACQoD,EAAU,GAAK,eADvB,+NAEuBhX,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,KAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,qMAIJ,0DACA,6BACI,m1JAoCJ,8CACA,4BACI,qLACA,gMACA,0LACA,yOACA,qXACA,4TACA,oCACA,kOACA,6QACA,4PACA,yNChQhBvK,GAAQ,GACR2J,GAAa,EA0HF,IACXrV,KAAM,sEAENsV,QAASrK,GAAcC,QAEvBqK,SAAUnK,GAASF,QAEnB5J,KAAM,SAAC4K,EAAUC,GACb,GAAqB,IAAjBA,EAAMJ,OACN,MAAO,CAACL,MAAO,GAAIqK,WAAY,IAEnC,IAAM3J,EAAgBH,GAAyBC,EAAUC,GAEzDT,GAAQ,GACR2J,GAAa,EAEb,IAAMG,EAAYtC,OAAOuC,YAAYC,MAEjCyD,EA1IU,SAACjN,EAAUC,EAAOC,EAAeV,GACnD,IAAIhI,EAAWyI,EAAM,GAAGG,aAClByM,EAAwBpM,GAAiCT,EAAUC,GAIzE,GAFAkJ,IAAcT,GAAOlR,GAAYkR,GAAOmE,GAEnCrV,EAeE,CACH,IAAI4V,EAAS,EACbjE,IAAcT,GAAO0E,GAFlB,oBAIqBpN,GAJrB,IAIH,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KAER,GAAe,KADfsZ,EAASP,EAAsBhM,GAAGhB,OAASK,EAAcW,GAAGhB,QAGxD,OADAL,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAMiZ,EAAQ1D,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBAC7F,EAEPU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,sBAV1G,mCAfQ,qBAGakB,GAHb,yBAGOa,EAHP,QAGC/M,KACRoM,EAAcW,GAAKX,EAAcW,GAAG8D,QAAO,SAAAiF,GAAQ,OAAIA,EAAS9V,OAAS+M,MAD7E,2BAAmC,IAHxB,kDAOab,GAPb,IAOX,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACR,GAAIoM,EAAcW,GAAGhB,OAAS,IAAM,EAEhC,OADAL,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBE,IAAKsL,WAAYhL,EAAoBG,sBACxF,EAEPU,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG1M,KAAM,EAAGuV,OAAQvL,EAAiBG,UAAWqL,WAAYhL,EAAoBG,sBAZlG,+BA8Bf,IAAMoK,EAAO,GACblJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,MACnC,SAAN2V,EAAO5I,GACTqI,EAAKrI,IAAK,EACVrB,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaG,MAAO2L,WAAYhL,EAAoBC,gBAFrE,oBAGUsB,EAAcW,IAHxB,IAGf,2BAA2C,CAAC,IAA1B7K,EAAyB,QAA/BlC,KACHoV,EAAKlT,KACNwJ,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,KAAIwB,WAAUkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACrH2J,EAAIzT,KANG,8BASf,GAAIwB,EAAU,CAAC,IAAD,gBACiBqV,EAAsBhM,IADvC,IACV,2BAAqD,CAAC,IAApCvH,EAAmC,QAAzCxF,KACHoV,EAAK5P,KACNkG,EAAMW,KAAK,CAAE7G,OAAMtD,GAAI6K,EAAGrJ,WAAUkS,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,YAAaiB,WAAW,IACrH2J,EAAInQ,KAJF,+BAQdkG,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,gBAGvF6K,CAAIzJ,EAAS,GAAGlM,MAChBqV,IAAcT,GAAOQ,GA3DwC,oBA6DrClJ,GA7DqC,IA6D7D,2BAAkC,CAAC,IAAjBa,EAAgB,QAAtB/M,KACR,IAAKoV,EAAKrI,GAAI,CACV,GAAIX,EAAcW,GAAGhB,OAAS,EAG1B,OAFAL,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,cAAekB,WAAW,IAC/GN,EAAMW,KAAK,CAAE7G,KAAMuH,EAAG7K,GAAIkK,EAAcW,GAAG,GAAG/M,KAAM0D,WAAUkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,eACrH,EAEPW,EAAMW,KAAK,CAAEtL,OAAQgM,EAAG6I,OAAQ7L,EAAaI,KAAM0L,WAAYhL,EAAoBC,kBApElC,8BAyE7D,OAAO,EAiEW0O,CAActN,EAAUC,EAAO9I,OAAOoW,OAAO,GAAIrN,GAAgBV,IAC3EyN,IACAzN,GAAMW,KAAK,CAAEuJ,OAAQ7L,EAAaK,qBAAsByL,WAAYhL,EAAoBC,cAAekB,WAAW,IAClHN,GAAMW,KAAK,CAAEuJ,OAAQnL,EAAWL,qBAAsByL,WAAYhL,EAAoBE,YAAaiB,WAAW,IAjEnG,SAACE,EAAUC,EAAOC,EAAeV,GACpD,IAAMhI,EAAWyI,EAAM,GAAGG,aACpByM,EAAwBpM,GAAiCT,EAAUC,GAErE6C,EAAQ9C,EAAS,GAAGlM,KACxB0L,EAAMW,KAAK,CAAEtL,OAAQiO,EAAO4G,OAAQ7L,EAAaC,OAAQ6L,WAAYhL,EAAoBC,gBAErFpH,IACA0I,EAAgB2M,GAEpB,IAAMY,EAAkB,GACpBC,EAAU,EACdD,EAAgBtN,KAAK2C,GAErB,IADA,IAAI0K,EAAM,EACHC,EAAgB5N,OAAS,GAE5B,GAAIK,EADJsN,EAAMC,EAAgBA,EAAgB5N,OAAS,IACxBA,OAAS,EAAG,CAC/B4N,EAAgBtN,KAAKD,EAAcsN,GAAK,GAAG1Z,MAC3C,IAAMkC,EAAKkK,EAAcsN,GAAKtD,QAAQpW,KACjC0D,IACD0I,EAAclK,GAAMkK,EAAclK,GAAI2O,QAAO,SAAAxP,GAAC,OAAIA,EAAErB,OAAS0Z,MAEjEhO,EAAMW,KAAK,CAAE7G,KAAMkU,EAAKxX,KAAIwB,UAAU,EAAMkS,OAAQnL,EAAWD,UAAWqL,WAAYhL,EAAoBE,cAE1GsK,IAAcT,GAAO1S,QAErByX,EAAgB1E,MACZ0E,EAAgB5N,OAAS,IACT,IAAZ6N,GACAlO,EAAMW,KAAK,CAAEtL,OAAQ2Y,EAAK9D,OAAQ7L,EAAanJ,QAASiV,WAAYhL,EAAoBC,cAAekB,WAAW,IACtHN,EAAMW,KAAK,CAAE7G,KAAMkU,EAAKxX,GAAIyX,EAAgBA,EAAgB5N,OAAS,GAAIrI,UAAU,EAAMC,SAAUiW,EAAShE,OAAQnL,EAAWC,KAAMmL,WAAYhL,EAAoBE,eAKjLsK,IACIT,GAAOlR,GACPkR,GAAOmE,GACPnE,GAAO5F,GACP4F,GAAO+E,GACP/E,GAAOgF,GACPhF,GAAO8E,GAyBHI,CAAe5N,EAAUC,EAAOC,EAAeV,KAGnD,IACMvJ,EADU+Q,OAAOuC,YAAYC,MACRF,EAM3B,OAJAH,IACIT,GAAOxI,GACPwI,GAAOuE,GAEJ,CACHzN,SACAqK,WAAY,CAAC,uEAAD,OACQoD,EAAU,GAAK,eADvB,+NAEuBhX,EAAS6T,QAAQ,GAFxC,mKAGsBvK,GAAmBC,KAHzC,gDAIG2J,GAJH,sCAMZY,cAAe,CACX,wKACA,4BACI,qMAIJ,0DACA,6BACI,+nGA0BJ,8CACA,4BACI,qLACA,gMACA,0LACA,yOACA,qXACA,4TACA,oCACA,kOACA,mRACA,kQACA,+NC/NP/O,GAAa7D,OAAOC,OAAO,CACpCyW,+BAAgC,iCAChCC,oBAAqB,wBAOnBC,GAAoB,iBAAO,CAC9B5R,KAAMnB,GAAW8S,sBCsCdnG,GAAKhE,IAAWC,KAAKC,MAerBmK,G,4MACFha,MAAQ,CACJia,WAAY,CACRC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,IAEJC,QAAQ,G,EA0BZC,sBAAwB,SAAA/Z,GACpB,EAAKga,qBACL,EAAK9J,MAAMhJ,gBAAgBkG,GAAUrO,SACrC,EAAKmR,MAAMtI,eAEX,EAAKsI,MAAM+J,aAAa,EAAKpb,MAAMia,WAAW9Y,EAAEE,OAAOqR,S,EAG3D2I,mBAAqB,WAC0B,IAAvC,EAAKhK,MAAMiK,yBACX,EAAKH,qBACL,EAAK9J,MAAM+D,WACJ,EAAK/D,MAAMkK,sBAClB,EAAKlK,MAAMxC,QAEX,EAAKwC,MAAMmK,Y,EAInBC,kBAAoB,WAC2B,IAAvC,EAAKpK,MAAMiK,yBACX,EAAKH,qBACL,EAAK9J,MAAM+D,SAAQ,IAEnB,EAAK/D,MAAMmK,UAAS,I,EAI5BE,kBAAoB,WAChB,EAAKP,qBACL,EAAK9J,MAAMtI,eACX,EAAKsI,MAAMhJ,gBAAgBkG,GAAUrO,U,EAGzCyb,2BAA6B,SAAAxa,GACzB,EAAKkQ,MAAMuK,SA5FO,IA4FsBza,EAAEE,OAAOqR,Q,EAGrDmJ,aAAe,SAACpT,EAASH,GACrB,EAAK6S,qBAEL,EAAK9J,MAAM7I,YAAYC,GACvB,EAAK4I,MAAMhJ,gBAAgBC,I,EAG/BS,aAAe,WACX,EAAKsI,MAAMhJ,gBAAgBkG,GAAUrO,SACrC,EAAKmR,MAAMtI,gB,EAGf8H,kBAAoB,WAChB,EAAKsK,qBAEL,EAAK9J,MAAMR,qB,EAGfsK,mBAAqB,WACjB,EAAK9J,MAAMxC,QACX,EAAKwC,MAAMnI,uBACX,EAAKmI,MAAM9B,aACX,EAAK8B,MAAM7B,kBACX,EAAK6B,MAAM5B,sB,EAGfqM,YAAc,WACV,EAAKX,qBACL,EAAK9J,MAAMhJ,gBAAgBkG,GAAUrO,SAErC,IAAM6b,EAAOC,KAAKC,UAAU,CACxBjQ,SAAU,EAAKqF,MAAM7C,MAAMxC,SAASU,KAAI,SAAAG,GAAC,MAAK,CAC1ClN,EAAGkN,EAAElN,EACLC,EAAGiN,EAAEjN,EACLE,KAAM+M,EAAE/M,SAEZmM,MAAO,EAAKoF,MAAM7C,MAAMvC,MAAMS,KAAI,SAAAvL,GAAC,MAAK,CACpCmE,KAAMnE,EAAEmE,KAAKxF,KACbkC,GAAIb,EAAEa,GAAGlC,KACT2D,OAAQtC,EAAEsC,WAEdD,SAAU,EAAK6N,MAAMjF,aAGnB8P,EAAa,gCAAkCC,OAAOJ,GACtDK,EAAgBC,SAASC,eAAe,YAC9CF,EAAcG,aAAa,OAAQL,GACnCE,EAAcG,aAAa,WAAY,cACvCH,EAAcI,S,EAGlBC,gBAAkB,WACd,EAAKtB,qBACL,EAAK9J,MAAMhJ,gBAAgBkG,GAAUrO,SAErCmc,SAASC,eAAe,YAAYE,S,EAGxCE,aAAe,SAACvb,GACZ,IAAMwb,EAAS,IAAIC,WACbC,EAAO1b,EAAEE,OAAOyb,MAAM,GAE5BH,EAAOI,OAAS,SAAC5b,GACb,IACI,IAAM4a,EAAOC,KAAKgB,MAAM7b,EAAEE,OAAO4b,QAE3BzZ,EAAWuY,EAAKvY,SAChBwI,EAAW+P,EAAK/P,SAASU,KAAI,SAAAG,GAC/B,GAAIqQ,MAAMvK,OAAO9F,EAAE/M,OACf,MAAM,IAAIqQ,MAAM,qCACpB,GAAI+M,MAAMvK,OAAO9F,EAAElN,KAAOud,MAAMvK,OAAO9F,EAAEjN,IACrC,MAAM,IAAIuQ,MAAM,2CACpB,OAAO,IAAIzQ,EAAOiT,OAAO9F,EAAElN,GAAIgT,OAAO9F,EAAEjN,GxBnMhC,GwBmMkD+S,OAAO9F,EAAE/M,UAEjEmM,EAAQ8P,EAAK9P,MAAMS,KAAI,SAAAvL,GACrB,OAAO,IAAIkC,EACP2I,EAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAAS6S,OAAOxR,EAAEmE,SACvC0G,EAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAAS6S,OAAOxR,EAAEa,OACvCwB,EACA0Z,MAAMvK,OAAOxR,EAAEsC,cAAWK,EAAY6O,OAAOxR,EAAEsC,YAKrD+K,EAAQ,IAAIyB,GAAMzM,EAAUwI,EAAUC,GAExCzI,IAAa,EAAK6N,MAAMjF,YACxB,EAAKyE,oBACT,EAAKQ,MAAM8L,SAAS3O,GACpB,EAAK6C,MAAM+L,sBACb,MAAOjc,GACL,EAAKkQ,MAAM7I,YAAY,gJAA6B,KAI5DmU,EAAOU,WAAWR,GAClBR,SAASC,eAAe,YAAY5J,MAAQ,M,EAGhD4K,oBAAsB,WAClB,EAAKjM,MAAMkM,qB,EAGfC,SAAW,WACP,EAAKhM,SAAS,CAAEyJ,QAAS,EAAKjb,MAAMib,U,kEApKpClb,KAAKsR,MAAM+J,aAAarb,KAAKC,MAAMia,WAAW,IAC9Cla,KAAKsR,MAAMuK,SAAS,O,4CAGF6B,EAAWC,EAAWC,GACxC,OAAIF,EAAUnV,YAAcvI,KAAKsR,MAAM/I,YAEnCmV,EAAUrR,aAAerM,KAAKsR,MAAMjF,aAEpCqR,EAAUlC,wBAA0Bxb,KAAKsR,MAAMkK,wBAE/CkC,EAAUG,qBAAuB7d,KAAKsR,MAAMuM,qBAE5CH,EAAUI,oBAAsB9d,KAAKsR,MAAMwM,oBAE3CJ,EAAUnC,0BAA4Bvb,KAAKsR,MAAMiK,yBAEjDoC,IAAc3d,KAAKC,a,+BAuJjB,IAAD,OACL,OACI,kBAAC,KAAD,CAAW8d,KAAM,CAAC,EAAG,GAAIC,OAAQ,OAAQC,OAAQ,CAAC,SAAU,QAAS,WACjE,yBAAKlK,UAAWH,GAAG,OAAD,8BAA2B5T,KAAKC,MAAMib,UACpD,yBACInH,UAAWH,GAAG,mBACdzS,QAAS,kBAAM,EAAKsc,aAFxB,UAKA,yBAAK1J,UAAWH,GAAG,aACf,yBAAKG,UAAWH,GAAG,0BACf,kBAAC,GAAD,CACIjR,KAAM,wFACNxB,QAAS,kBAAM,EAAK6H,gBACpB8K,UAAW9T,KAAKsR,MAAM/I,YAAciG,GAAUrO,QAC9C6T,WAAY,MAChB,kBAAC,GAAD,CACIrR,KAAM,8FACNxB,QAAS,kBAAM,EAAK2a,aAAa,6MAAyCtN,GAAUtH,aACpF4M,UAAW9T,KAAKsR,MAAM/I,YAAciG,GAAUtH,WAC9C8M,WAAY,MAChB,kBAAC,GAAD,CACIrR,KAAM,kFACNxB,QAAS,kBAAM,EAAK2a,aAAa,qQAAoDtN,GAAUrH,WAC/F2M,UAAW9T,KAAKsR,MAAM/I,YAAciG,GAAUrH,SAC9C6M,WAAY,MAChB,kBAAC,GAAD,CACIrR,KAAM,uHACNxB,QAAS,kBAAM,EAAK2a,aAAa,4JAAgCtN,GAAUuB,wBAC3E+D,UAAW9T,KAAKsR,MAAM/I,YAAciG,GAAUuB,sBAC9CiE,WAAY,OAEpB,kBAAC,GAAD,CACID,UAAWH,GAAG,UACdjR,KAAM,8FACNyR,SAAU,kBAAM,EAAKtD,qBACrB2D,UAAWzU,KAAKsR,MAAMjF,cAE9B,yBAAK0H,UAAWH,GAAG,aACf,yBAAKG,UAAWH,GAAG,oBACf,kBAAC,GAAD,CACIU,MAAOtU,KAAKC,MAAMia,WAAWvN,KAAI,SAAA9D,GAAC,OAAIA,EAAE9I,QACxCqU,SAAUpU,KAAKmb,yBAEvB,yBAAKpH,UAAWH,GAAG,WACf,kBAAC,GAAD,CACIM,MAAO,oGACPvB,MA1PN,IA0PiC3S,KAAKsR,MAAMuM,mBACtC1J,IA5PN,EA6PMzD,IA5PN,IA6PM0D,SAAUpU,KAAK4b,8BAEvB,yBAAK7H,UAAWH,GAAG,kCACf,kBAAC,GAAD,CACIjR,KAAM3C,KAAKsR,MAAMkK,sBAAwB,iCAAU,iCACnDra,QAASnB,KAAKsb,qBAClB,kBAAC,GAAD,CAAiB3Y,KAAM,qBAAOxB,QAASnB,KAAK0b,oBAC5C,kBAAC,GAAD,CAAiB/Y,KAAM,2BAAQxB,QAASnB,KAAK2b,sBAGrD,yBAAK5H,UAAWH,GAAG,aACf,yBAAKG,UAAWH,GAAG,yBACf,kBAAC,GAAD,CACIjR,KAAM,yDACNxB,QAAS,kBAAM,EAAK4a,eACpBjI,WAAW,IACf,uBAAGoK,GAAG,WAAWC,MAAO,CAAC,QAAW,QAASC,eAAa,EAAMC,KAAK,MAArE,cAEA,kBAAC,GAAD,CACI1b,KAAM,yDACNxB,QAAS,kBAAM,EAAKub,mBACpB5I,WAAW,IACf,2BAAOoK,GAAG,WAAW9V,KAAK,OAAOkW,OAAO,QAAQH,MAAO,CAAC,QAAW,QAAS/J,SAAU,SAAChT,GAAD,OAAO,EAAKub,aAAavb,QAGvH,yBAAK2S,UAAWH,GAAG,aACf,yBAAKG,UAAWH,GAAG,2BACf,kBAAC,GAAD,CACIjR,KAAM,oGACNxB,QAAS,kBAAM,EAAKoc,uBACpBzJ,WAAW,Y,GA/QfP,IAAMC,WA4SnBC,gBAtTS,SAAAxT,GAAK,MAAK,CAC9BsI,UAAWtI,EAAMyO,aAAanG,UAC9B8D,WAAYpM,EAAMyO,aAAaD,MAAMpC,aACrCmP,sBAAuBvb,EAAM4O,iBAAiBS,SAC9CuO,mBAAoB5d,EAAM4O,iBAAiBU,MAC3CuO,kBAAmB7d,EAAM4O,iBAAiB0P,UAC1ChD,wBAAyBtb,EAAM4O,iBAAiBpD,MAAMK,OACtD2C,MAAOxO,EAAMyO,aAAaD,UA2RH,SAAA7F,GAAQ,MAAK,CACpCN,gBAAiB,SAACC,GAAD,OAAeK,EAASN,EAAgBC,KACzDE,YAAa,SAACC,EAASC,GAAV,OAAsBC,EAASH,EAAYC,EAASC,KACjEK,aAAc,kBAAMJ,EAASI,MAC7B8H,kBAAmB,kBAAMlI,E9BnQW,CACpCR,KAAMnB,EAAWW,sB8BmQjByT,aAAc,SAACkD,GAAD,OAAe3V,E1B3OL,SAAC2V,GAAD,MAAgB,CACxCnW,KAAMnB,GAAW2G,cACjB2Q,a0ByOsClD,CAAakD,KACnD1C,SAAU,SAACtM,GAAD,OAAW3G,E1BjPD,SAAC2G,GAAD,MAAY,CAChCnH,KAAMnB,GAAW4G,UACjB0B,S0B+O8BsM,CAAStM,KACvC8F,QAAS,SAAC/G,GAAD,OAAe1F,E1BvUL,eAAC0F,EAAD,+DAAuB,SAAC1F,EAAU2F,GACrD3F,EAASyF,GAAaC,IAEtB,IAAMG,EAAQF,IAAWG,aAAaD,MAChCxC,EAAWwC,EAAMxC,SACjBC,EAAQuC,EAAMvC,MACdC,EAAgBH,GAAyBC,EAAUC,GAEnDoJ,EAAW/G,IAAWM,iBAAiB0P,UAAUjJ,SACvD,GAAIA,EAAWnK,GAASC,SAAU,CAAC,IAAD,gBACXc,GADW,IAC9B,2BAA0B,CACtB,IADsB,QACZnH,aAEN,YADA6D,EAASH,EAAY,wJAAgC,KAH/B,+BAQlC,GAAK6M,EAAWnK,GAASxG,cAAiB8J,EAAMpC,aAC5CzD,EAASH,EAAY,kMAAuC,SAGhE,GAAK6M,EAAWnK,GAASG,WAAcmD,EAAMpC,aACzCzD,EAASH,EAAY,sLAAqC,QAD9D,CAIA,GAAK6M,EAAWnK,GAASE,WAAeY,EAASH,OAAS,EAAI,CAC1D,IAAIqJ,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,OAAQ,MACnC,SAAN2V,EAAO5I,GAET,IAAI7K,EADJkT,EAAKrI,IAAK,EAEVX,EAAcW,GAAGnB,SAAQ,SAAAkK,GACrB5T,EAAK4T,EAAS9V,KACToV,EAAKlT,IACNyT,EAAIzT,MAIhByT,CAAIzJ,EAAS,GAAGlM,MAb0C,oBAe1CkM,GAf0C,IAe1D,2BAA0B,CAAC,IAAhBa,EAAe,QACtB,IAAKqI,EAAKrI,EAAE/M,MAER,YADA6I,EAASH,EAAY,sIAA6B,KAjBA,+BAsB9D,GAAK6M,EAAWnK,GAASI,SAAaU,EAASH,OAAS,EAAI,CACxD,IAAIqJ,EAAO,GACXlJ,EAASN,SAAQ,SAAA7K,GAAM,OAAIqU,EAAKrU,EAAOf,MAAQ,KAC/C,IAHwD,EAGlD2V,EAAM,SAANA,EAAO5I,GAET,IAAI7K,EADJkT,EAAKrI,GAAK,EADK,oBAGQX,EAAcW,IAHtB,IAGf,2BAAyC,CAErC,GADA7K,EADqC,QACvBlC,KACToV,EAAKlT,IAGH,GAAiB,IAAbkT,EAAKlT,GACZ,OAAO,OAHP,IAAKyT,EAAIzT,GACL,OAAO,GAPJ,8BAaf,OADAkT,EAAKrI,GAAK,GACH,GAhB6C,cAkB5Bb,GAlB4B,IAkBxD,2BAAsC,CAAC,IAArB8C,EAAoB,QAA1BhP,KACR,IAAKoV,EAAKpG,KAAW2G,EAAI3G,GAErB,YADAnG,EAASH,EAAY,wJAAgC,KApBL,+BA0B5D,IAAM4M,EAAU9G,IAAWM,iBAAiB0P,UAAUlJ,QAClDA,IAAYrK,GAAczD,eAC1BqB,EAASN,EAAgBkG,GAAUwB,mCACnCpH,EAASH,EAAY,iGACd4M,IAAYrK,GAAcE,aACjCtC,EAASN,EAAgBkG,GAAUyB,iCACnCrH,EAASH,EAAY,qFACd4M,IAAYrK,GAAcC,SACjCrC,EAASvH,Q0BsPoBgU,CAAQ/G,KACzCjN,KAAM,kBAAMuH,EAASvH,OACrByN,MAAO,kBAAMlG,EAASkG,OACtB2M,SAAU,SAACnN,GAAD,OAAe1F,E1B1ND,eAAC0F,EAAD,+DAAuB,SAAC1F,GACpCA,EAAZ0F,EAAqBQ,KAAoBC,MACzCnG,EAASoG,GAAYV,K0BwNakQ,CAAalQ,KAC/CnF,qBAAsB,kBAAMP,EAASO,MACrCqG,WAAY,kBAAM5G,EAAS4G,OAC3BC,gBAAiB,kBAAM7G,EAAS6G,OAChCC,mBAAoB,kBAAM9G,EAAS8G,OACnC0N,SAAU,SAAC3O,GAAD,OAAW7F,E9BjQD,SAAC6F,GAAD,MAAY,CAChCrG,KAAMnB,EAAWc,UACjB0G,S8B+P8B2O,CAAS3O,KACvC+O,kBAAmB,kBAAM5U,EDlWoB,CAC7CR,KAAMnB,GAAW6S,kCCkWjBuD,oBAAqB,kBAAMzU,EAASQ,EAAW,EAAG,QAGvCqK,CAA6CwG,I,oBCtWtDrG,GAAKhE,IAAWC,KAAKC,MAeZ2D,gBAbS,SAAAxT,GAAK,MAAK,CAC9ByI,QAASzI,EAAMyO,aAAahG,QAC5BC,QAAS1I,EAAMyO,aAAa/F,WAWjB8K,EARI,SAAC,GAA0B,IAAxB/K,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QAC3B,OACI,yBAAKoL,UAAWH,GAAG,cAAD,iCAA4C7P,IAAZ2E,GAAhC,wBAAoEC,KACjFD,M,4DCXPkL,GAAKhE,IAAWC,KAAKC,MAEd2O,GAAqB,SAAC,GAA6E,IAA3E9L,EAA0E,EAA1EA,MAAO+L,EAAmE,EAAnEA,YAAatK,EAAsD,EAAtDA,SAAUxK,EAA4C,EAA5CA,QAASmK,EAAmC,EAAnCA,UAAmC,IAAxB4K,iBAAwB,SAC3G,OACI,2BACI5K,UAAWH,GAAG,aAAcG,GAC5B3L,KAAK,OACLwB,QAASA,EACT+I,MAAOA,EACPyB,SAAUA,EACVsK,YAAaA,EACbC,UAAWA,KCNjB/K,GAAKhE,IAAWC,KAAKC,MAErB8O,GAAe,CACjBC,QAAS,CAACC,OAAQ,MAchBC,G,4MACF9e,MAAQ,CACJ0S,MAAO,I,EAGXqM,aAAe,SAAC5d,GACRA,EAAEE,OAAO2d,SAASC,OAClB,EAAKzN,SAAS,CAAEkB,MAAOvR,EAAEE,OAAOqR,S,EAGxCwM,OAAS,SAAC/d,GACNA,EAAEge,iBACF,EAAK3N,SAAS,CAAEkB,MAAO,KACvB,EAAKrB,MAAM+N,aAAa,EAAK/N,MAAM5H,SAAU,EAAKzJ,MAAM0S,Q,EAG5DsL,OAAS,WACL,EAAKxM,SAAS,CAAEkB,MAAO,KACvB,EAAKrB,MAAMgO,aAAa,EAAKhO,MAAM3H,W,uDAG7B,IAAD,OACL,OACI,kBAAC,KAAD,CACI4V,OAAQvf,KAAKsR,MAAMiO,OACnBC,eAAgB,WACZ,EAAK/N,SAAS,CAAEkB,MAAO,KACvB,EAAKrB,MAAMgO,aAAa,EAAKhO,MAAM3H,WAEvC8V,aAAa,EACb1L,UAAWH,GAAG,gBACduK,MAAOS,IAEP,4BAAK5e,KAAKsR,MAAM9H,OAChB,yBAAKuK,UAAWH,GAAG,SAAU5T,KAAKsR,MAAM3O,MACxC,0BAAM+G,SAAU,SAACtI,GAAD,OAAO,EAAK+d,OAAO/d,KAC/B,kBAAC,GAAD,CACIud,WAAW,EACX5K,UAAWH,GAAG,cACd8K,YAAa1e,KAAKsR,MAAM7H,iBACxBG,QAAS5J,KAAKsR,MAAM1H,QACpBwK,SAAUpU,KAAKgf,aACfrM,MAAO3S,KAAKC,MAAM0S,QAEtB,kBAAC,GAAD,CACIvK,KAAM,SACN2L,UAAWH,GAAG,UACdjR,KAAM,eACNxB,QAAS,SAACC,GAAD,OAAO,EAAK+d,OAAO/d,MAChC,kBAAC,GAAD,CACI2S,UAAWH,GAAG,UACdjR,KAAM,uCACNxB,QAAS,kBAAM,EAAK8c,aAG5B,yBAAKlK,UAAWH,GAAG,SAAU5T,KAAKsR,MAAMlR,W,GAvD9BmT,IAAMC,WAkEjBC,gBA7ES,SAAAxT,GAAK,MAAK,CAC9Bsf,OAAQtf,EAAMyf,cAAcH,OAC5B/V,MAAOvJ,EAAMyf,cAAclW,MAC3B7G,KAAM1C,EAAMyf,cAAc/c,KAC1BvC,KAAMH,EAAMyf,cAActf,KAC1BqJ,iBAAkBxJ,EAAMyf,cAAcjW,iBACtCG,QAAS3J,EAAMyf,cAAc9V,QAC7BF,SAAUzJ,EAAMyf,cAAchW,SAC9BC,SAAU1J,EAAMyf,cAAc/V,aAgEP,SAAAf,GAAQ,MAAK,CACpCyW,aAAc,SAAC3V,EAAUwT,GAAX,OAAsBtU,EhC9DZ,SAACc,EAAUwT,GAAX,OAAsB,SAACtU,GAC3Cc,GACAA,EAASwT,GACbtU,EAASiB,MgC2DoCwV,CAAa3V,EAAUwT,KACpEoC,aAAc,SAAC3V,GAAD,OAAcf,EhCrEJ,SAACe,GAAD,OAAc,SAACf,GACnCe,GACAA,IACJf,EAASiB,MgCkE4ByV,CAAa3V,QAGvC8J,CAA6CsL,I,oBCtFtDnL,GAAKhE,IAAWC,KAAKC,MAmCZ2D,gBAjCS,SAAAxT,GAAK,MAAK,CAC9B0f,MAAO1f,EAAM4O,iBAAiBiH,WAC9B8J,UAAW3f,EAAM4O,iBAAiBgR,qBA+BvBpM,EA5BC,SAAC,GAA0B,IAAxBkM,EAAuB,EAAvBA,MAAOC,EAAgB,EAAhBA,UAStB,OACI,yBAAK7L,UAAWH,GAAG,WAAD,8BAA+BgM,GAAaxS,MAAM+C,QAAQwP,IAAUA,EAAM7T,WACvF6T,EAAMhT,KAAI,SAACmT,EAAM7S,GAAP,OAAiB,yBAAK8G,UAAWH,GAAG,QAASP,IAAKpG,GAAQ6S,MACrE,yBAAK/L,UAAWH,GAAG,eAAgBzS,QAAS,kBAXhC,SAACwe,GACjB,IAAMxD,EAAa,iCAAmCwD,EAAMhT,KAAI,SAAAmT,GAAI,OAAIA,EAAO,QAAMC,QAAO,SAACC,EAAKvG,GAAN,OAAcuG,EAAMvG,IAAK,IAC/G4C,EAAgBC,SAASC,eAAe,YAC9CF,EAAcG,aAAa,OAAQL,GACnCE,EAAcG,aAAa,WAAY,cACvCH,EAAcI,QAMwCV,CAAY4D,KAA9D,0DACA,uBAAGzB,GAAG,WAAWC,MAAO,CAAC,QAAW,QAASC,eAAa,EAAMC,KAAK,MAArE,mB,wCCrBNzK,GAAKhE,IAAWC,KAAKC,MAErBmQ,GAAa,SAAC,GAAmE,IAAjE/S,EAAgE,EAAhEA,KAAMgT,EAA0D,EAA1DA,QAASC,EAAiD,EAAjDA,SAAUC,EAAuC,EAAvCA,WAAYC,EAA2B,EAA3BA,YAAalf,EAAc,EAAdA,QACpE,OACI,yBAAK4S,UAAWH,GAAG,cAAD,yBAA6B1G,GAA7B,+BACKA,IAASA,EAAKI,UADnB,gCAEM4S,GAFN,iCAGOC,GAHP,mCAISC,GAJT,oCAKUC,IACxBlf,QAASA,EACTmf,cAAenf,GACd+L,EAAQA,EAAKI,SAAWJ,EAAKxJ,OAAS,IAAO,MAKpD6c,GAAY,SAAC,GAAqD,IAAnDC,EAAkD,EAAlDA,IAAKC,EAA6C,EAA7CA,MAAOC,EAAsC,EAAtCA,KAAMC,EAAgC,EAAhCA,aAAcC,EAAkB,EAAlBA,YACjD,OACI,yBAAK7M,UAAWH,GAAG,eACf,yBAAKG,UAAWH,GAAG,eAAgB+M,GAClCH,EAAI7T,KAAI,SAACO,EAAMD,GAAP,OACL,kBAAC,GAAD,CACIoG,IAAKpG,EACLC,KAAMA,EACNgT,QAAoB,IAAVjT,GAAgBwT,EAC1BN,SAAWlT,EAAQ,IAAMuT,EAAI1U,QAAW2U,EACxCL,WAAuB,IAAVnT,GAAgByT,EAC7BL,YAAcpT,EAAQ,IAAMuT,EAAI1U,QAAW4U,EAC3Cvf,QAAS,SAACC,GAAD,OAAOwf,EAAYxf,EAAG6L,WAyBpC4T,GAnBS,SAAC,GAA4B,IAA1BpS,EAAyB,EAAzBA,MAAOmS,EAAkB,EAAlBA,YAAkB,EACLhU,GAA2B6B,EAAMxC,SAAUwC,EAAMvC,OAArFiB,EADyC,EACzCA,gBAAiBN,EADwB,EACxBA,gBACxB,OACI,yBAAKkH,UAAWH,GAAG,WACf,yBAAKG,UAAWH,GAAG,eAAgB,KAClC/G,EAAgBF,KAAI,SAAAG,GAAC,OAAI,yBAAKuG,IAAKvG,EAAGiH,UAAWH,GAAG,eAAgB9G,MACpEK,EAAgBR,KAAI,SAAC6T,EAAKvT,GAAN,OACjB,kBAAC,GAAD,CACIoG,IAAKpG,EACLuT,IAAKA,EACLC,MAAiB,IAAVxT,EACPyT,KAAMzT,EAAQ,IAAMwB,EAAMxC,SAASH,OACnC6U,aAAc9T,EAAgBI,GAC9B2T,YAAa,SAACxf,EAAG0f,GAAJ,OAAeF,EAAYxf,EAAGyL,EAAgBI,GAAQJ,EAAgBiU,YCzCjGlN,GAAKhE,IAAWC,KAAKC,MAErB8O,GAAe,CACjBC,QAAS,CAACC,OAAQ,QAQhBiC,G,4MAQFhF,YAAc,WACV,GAAyC,IAArC,EAAKzK,MAAM7C,MAAMxC,SAASH,OAA9B,CADgB,IAIXqB,EAAmBP,GAA2B,EAAK0E,MAAM7C,MAAMxC,SAAU,EAAKqF,MAAM7C,MAAMvC,OAA1FiB,gBAGLA,GADAA,EAAkBA,EAAgBR,KAAI,SAAA6T,GAAG,OAAIA,EAAI7T,KAAI,SAAAO,GAAI,OAAIA,EAAQA,EAAKI,SAAWJ,EAAKxJ,OAAS,IAAO,WACxEqc,QAAO,SAACiB,EAAMC,GAAP,OAAeD,EAAOC,EAAIlB,QAAO,SAACD,EAAM5S,GAAP,OAAgB4S,EAAO5S,EAAO,MAAK,IAAM,OAAM,IAEzH,IAAMiP,EAAa,iCAAmCC,OAAOjP,GACvDkP,EAAgBC,SAASC,eAAe,YAC9CF,EAAcG,aAAa,OAAQL,GACnCE,EAAcG,aAAa,WAAY,uBACvCH,EAAcI,U,EAGlBwB,OAAS,WACL,EAAK3M,MAAMgO,aAAa,O,EAG5B4B,gBAAkB,SAAC9f,EAAGmE,EAAMtD,GACxB,IAAMsB,EAAa,EAAK+N,MAAM7C,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASwF,KAC5D/B,EAAW,EAAK8N,MAAM7C,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASkC,KAEhE,GAAe,UAAXb,EAAEgH,KACE7E,GAAcC,GACd,EAAK8N,MAAM/H,qBACP,+FADJ,WAEQhE,EAFR,YAEgB,EAAK+L,MAAM7C,MAAMpC,aAAe,KAAO,MAFvD,YAEgEpK,EAFhE,KAGI,0SACA,qDACA,SAAC0Q,GACiB,KAAVA,IACAA,OAAQ5O,GACZ,EAAKuN,MAAMnJ,QAAQ5E,EAAYC,EAAUmP,KAE7C,KACA,mBAGL,GAAe,gBAAXvR,EAAEgH,KAAwB,CACjChH,EAAEge,iBAEF,IAAM+B,EAAY,EAAK7P,MAAM7C,MAAMoC,SAAStN,EAAYC,IACrC,IAAf2d,GACA,EAAK7P,MAAMjJ,WAAW,EAAKiJ,MAAM7C,MAAMvC,MAAMiV,M,oEAnDnCzD,EAAWC,EAAWC,GACxC,SAAK5d,KAAKsR,MAAMiO,SAAW7B,EAAU6B,U,+BAsD/B,IAAD,OACL,OACI,kBAAC,KAAD,CACIA,OAAQvf,KAAKsR,MAAMiO,OACnBC,eAAgB,kBAAM,EAAKvB,UAC3BwB,aAAa,EACb1L,UAAWH,GAAG,iBACduK,MAAOS,IAGH5e,KAAKsR,MAAM7C,MAAMxC,SAASH,OAAS,EAC/B,6BACI,kBAAC,GAAD,CAAiB2C,MAAOzO,KAAKsR,MAAM7C,MAAOmS,YAAa5gB,KAAKkhB,kBAC5D,sOAGJ,yBAAK/C,MAAO,CAAC,OAAU,OAAQ,YAAa,UAA5C,8JAGR,kBAAC,GAAD,CACI/V,KAAM,SACN2L,UAAWH,GAAG,SAAD,qCAAyE,IAArC5T,KAAKsR,MAAM7C,MAAMxC,SAASH,SAC3EnJ,KAAM,yFACNxB,QAAS,kBAAM,EAAK4a,iBACxB,uBAAGmC,GAAG,WAAWC,MAAO,CAAC,QAAW,QAASC,eAAa,EAAMC,KAAK,MAArE,eAEA,kBAAC,GAAD,CACItK,UAAWH,GAAG,UACdjR,KAAM,6CACNxB,QAAS,kBAAM,EAAK8c,iB,GAtFb1K,IAAMC,WAqGlBC,gBA1GS,SAAAxT,GAAK,MAAK,CAC9Bsf,OAAQtf,EAAMmhB,oBAAoB7B,OAClC9Q,MAAOxO,EAAMyO,aAAaD,UA+FH,SAAA7F,GAAQ,MAAK,CACpCyW,aAAc,SAAC3V,EAAUwT,GAAX,OAAsBtU,EPjGN,SAACc,EAAUwT,GAAX,OAAsB,SAACtU,GACjDc,GACAA,EAASwT,GACbtU,EAASoR,OO8FoCqH,CAAmB3X,EAAUwT,KAC1EoC,aAAc,SAAC3V,GAAD,OAAcf,EPxGE,SAACe,GAAD,OAAc,SAACf,GACzCe,GACAA,IACJf,EAASoR,OOqG4BsH,CAAmB3X,KACxDxB,QAAS,SAAC5E,EAAYC,EAAUE,GAAvB,OAAkCkF,EAAST,EAAQ5E,EAAYC,EAAUE,KAClF2E,WAAY,SAAC/D,GAAD,OAAUsE,EAASP,EAAW/D,KAC1CiF,qBAAsB,SAACC,EAAO7G,EAAMvC,EAAMqJ,EAAkBC,EAAUiK,EAAS/J,GAAzD,OAClBhB,EAASW,EAAqBC,EAAO7G,EAAMvC,EAAMqJ,EAAkBC,EAAUiK,EAAS/J,QAG/E6J,CAA6CsN,I,6BCvHtDnN,GAAKhE,IAAWC,KAAKC,MAyCZyR,G,4MAtCXthB,MAAQ,CACJib,QAAQ,G,EAGZuC,SAAW,WACP,EAAKhM,SAAS,CAAEyJ,QAAS,EAAKjb,MAAMib,U,uDAI9B,IAAD,OACL,OACI,kBAAC,KAAD,CAAW6C,KAAM,CAAC,EAAG,GAAIC,OAAQ,QAC7B,yBAAKjK,UAAWH,GAAG,WAAD,kCAAmC5T,KAAKC,MAAMib,UAC5D,yBACInH,UAAWH,GAAG,gBACdzS,QAAS,kBAAM,EAAKsc,aAFxB,UAKA,yBAAK1J,UAAWH,GAAG,SACf,qHAGA,4BACI,+MACA,8GACA,kRACA,sPAEJ,uBAAGG,UAAWH,GAAG,SAAjB,yY,GA7BFL,IAAMC,W,oBCDtBI,GAAKhE,IAAWC,KAAKC,MA0BZ2D,gBAxBS,SAAAxT,GAAK,MAAK,CAC9B0f,MAAO1f,EAAM4O,iBAAiBmH,cAC9B4J,UAAW3f,EAAM4O,iBAAiB2S,qBAClCC,YAAaxhB,EAAM4O,iBAAiB6S,4BAqBzBjO,EAlBU,SAAC,GAAuC,IAArCkM,EAAoC,EAApCA,MAAOC,EAA6B,EAA7BA,UAAW6B,EAAkB,EAAlBA,YAC1C,OACI,yBAAK1N,UAAWH,GAAG,qBAAD,4BAAuC6N,KAAiB7B,GAAaxS,MAAM+C,QAAQwP,IAAUA,EAAM7T,WAChHsB,MAAM+C,QAAQwP,GACXA,EAAMhT,KAAI,SAACmT,EAAM7S,GAAP,OAAiB,yBAAK8G,UAAWH,GAAG,QAASP,IAAKpG,GAAQ6S,MAEpE,OCSVlM,GAAKhE,IAAWC,KAAKC,KA4FZ2D,eAAQ,MAhBI,SAAA7K,GAAQ,MAAK,CACpC+Y,cAAe,kBAAM/Y,EvCMW,CAChCR,KAAMnB,EAAWgB,kBuCNjB2Z,WAAY,kBAAMhZ,EvCSW,CAC9BR,KAAMnB,EAAWiB,euCThByT,kBAAmB,WACf/S,EAASkG,MACTlG,EAASO,KACTP,EAAS4G,MACT5G,EAAS6G,MACT7G,EAAS8G,OAEbmS,6BAA8B,kBAAMjZ,EnCmGW,CAC/CR,KAAMnB,GAAWmH,mCmCnGjB9F,gBAAiB,SAACC,GAAD,OAAeK,EAASN,EAAgBC,KACzDE,YAAa,SAACC,GAAD,OAAaE,EAASH,EAAYC,KAC/CM,aAAc,kBAAMJ,EAASI,SAGlByK,EA1FH,SAAC,GAQN,IAPHkI,EAOE,EAPFA,kBACAgG,EAME,EANFA,cACAC,EAKE,EALFA,WACAC,EAIE,EAJFA,6BACApZ,EAGE,EAHFA,YACAO,EAEE,EAFFA,aACAV,EACE,EADFA,gBASMwZ,EAAW,CACbC,SAAU,SAAC3gB,GACPA,EAAEge,iBACFzD,IACAgG,KAEJphB,MAAO,SAACa,GACJA,EAAEge,iBACFzD,IACAiG,KAEJI,wBAAyB,SAAC5gB,GACtBA,EAAEge,iBACFyC,KAEJva,kBAAmB,SAAClG,GAEhB,OADAA,EAAEge,iBACMhe,EAAEiS,KACN,IAAK,IACDrK,IACAV,EAAgBkG,GAAUrO,SAC1B,MACJ,IAAK,IACDwb,IACAlT,EAAY,8MACZH,EAAgBkG,GAAUtH,YAC1B,MACJ,IAAK,IACDyU,IACAlT,EAAY,sQACZH,EAAgBkG,GAAUrH,UAC1B,MACJ,IAAK,IACDwU,IACAlT,EAAY,6JACZH,EAAgBkG,GAAUuB,0BAO1C,OACI,yBAAKgE,UAAWH,GAAG,QACf,kBAAC,iBAAD,CAAeqO,OAnDR,CACXF,SAAU,CAAC,SAAU,eACrBxhB,MAAO,CAAC,aAAc,mBACtByhB,wBAAyB,CAAC,IAAK,UAC/B1a,kBAAmB,CAAC,IAAK,IAAK,IAAK,MA+CAwa,SAAUA,IACzC,kBAACI,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,UCvFQC,QACW,cAA7BlP,OAAOmP,SAASC,UAEe,UAA7BpP,OAAOmP,SAASC,UAEhBpP,OAAOmP,SAASC,SAASC,MACvB,2D,qBCfAC,GAAe,CACjBhD,QAAQ,EACR/V,MAAO,GACP7G,KAAM,GACNvC,KAAM,GACNqJ,iBAAkB,GAClBC,SAAU,KACViK,QAAS,KACT/J,QAAS,MAoCE4Y,GAjCA,WAAmC,IAC1CC,EADQxiB,EAAiC,uDAAzBsiB,GAAc5M,EAAW,uCAE7C,OAAQA,EAAOvN,MACX,KAAKnB,EAAWoC,wBAsBZ,OArBAoZ,EAAQ,gBACDxiB,EADC,CAEJsf,QAAQ,EACR/V,MAAOmM,EAAOnM,MACd7G,KAAMgT,EAAOhT,KACbvC,KAAMuV,EAAOvV,KACbqJ,iBAAkBkM,EAAOlM,iBACzBG,QAAS+L,EAAO/L,WAGXF,SAAW,SAACiJ,GACjB,IAAMjJ,EAAWiM,EAAOjM,SACpBA,GACAA,EAASiJ,IAEjB8P,EAAS9Y,SAAW,WAChB,IAAMA,EAAWgM,EAAOhM,SACpBA,GACAA,KAGD8Y,EACX,KAAKxb,EAAWqC,aACZ,OAAOiZ,GACX,QACI,OAAOtiB,ICvCbsiB,GAAe,CACjB9W,MAAO,GACP6D,UAAU,EACViP,UAAW,KACXhP,MAAO,IACPjB,WAAW,EACXwH,WAAY,GACZ+J,mBAAmB,EACnB7J,cAAe,GACfwL,sBAAsB,EACtBE,0BAA0B,GAkGfnD,GA/FG,WAAmC,IAC7CkE,EADWxiB,EAAiC,uDAAzBsiB,GAAc5M,EAAW,uCAEhD,OAAQA,EAAOvN,MACX,KAAKnB,GAAWuG,KACZiV,EAAQ,gBACDxiB,GAGP,IAGIid,EAHE7H,EAAUpV,EAAMse,UAAUlJ,QAC1BpJ,EAAW0J,EAAOlH,MAAMxC,SACxBC,EAAQyJ,EAAOlH,MAAMvC,MAa3B,OAXImJ,IAAYrK,GAAczD,cAC1B2V,EAASjd,EAAMse,UAAUld,KAAK4K,EAAUC,EAAOyJ,EAAO7U,QAC/CuU,IAAYrK,GAAcE,YACjCgS,EAASjd,EAAMse,UAAUld,KAAK4K,EAAUC,EAAOyJ,EAAOrR,MAC/C+Q,IAAYrK,GAAcC,UACjCiS,EAASjd,EAAMse,UAAUld,KAAK4K,EAAUC,IAE5CuW,EAAShX,MAAQyR,EAAOzR,MACxBgX,EAAS3M,WAAaoH,EAAOpH,WAC7B2M,EAASzM,cAAgBkH,EAAOlH,cAEzByM,EACX,KAAKxb,GAAW0G,eAQZ,OAPA8U,EAAQ,gBACDxiB,EADC,CAEJwL,MAAM,YAAKxL,EAAMwL,UAGZA,MAAM0K,QAERsM,EACX,KAAKxb,GAAWwG,MACZ,OAAO,gBACAxN,EADP,CAEIqP,UAAU,IAElB,KAAKrI,GAAWyG,MACZ,OAAO,gBACAzN,EADP,CAEIqP,UAAU,IAElB,KAAKrI,GAAW2G,cACZ,OAAO,gBACA3N,EADP,CAEIse,UAAW5I,EAAO4I,YAE1B,KAAKtX,GAAW4G,UACZ,OAAO,gBACA5N,EADP,CAEIsP,MAAOoG,EAAOpG,QAEtB,KAAKtI,GAAW6G,gBACZ,OAAO,gBACA7N,EADP,CAEIqO,UAAWqH,EAAOrH,YAE1B,KAAKrH,GAAW8G,YACZ,OAAO,gBACA9N,EADP,CAEIwL,MAAO,KAEf,KAAKxE,GAAW+G,gBACZ,OAAO,gBACA/N,EADP,CAEI4f,mBAAmB,IAE3B,KAAK5Y,GAAWgH,iBACZ,OAAO,gBACAhO,EADP,CAEI6V,WAAY,GACZ+J,mBAAmB,IAE3B,KAAK5Y,GAAWiH,oBACZ,OAAO,gBACAjO,EADP,CAEIuhB,sBAAsB,IAE9B,KAAKva,GAAWkH,qBACZ,OAAO,gBACAlO,EADP,CAEI+V,cAAe,GACfwL,sBAAsB,IAE9B,KAAKva,GAAWmH,gCACZ,OAAO,gBACAnO,EADP,CAEIyhB,0BAA2BzhB,EAAMyhB,2BAEzC,QACI,OAAOzhB,ICzGbsiB,GAAe,CACjBhD,QAAQ,GAiBGmD,GAdM,WAAmC,IAAlCziB,EAAiC,uDAAzBsiB,GAAc5M,EAAW,uCACnD,OAAQA,EAAOvN,MACX,KAAKnB,GAAW6S,+BACZ,OAAO,gBACA7Z,EADP,CAEIsf,QAAQ,IAEhB,KAAKtY,GAAW8S,oBACZ,OAAOwI,GACX,QACI,OAAOtiB,ICPbsiB,GAAe,CACjB9T,MAAO,IAAIyB,IAAM,GACjBxH,aAAS3E,EACT4E,SAAS,EACTJ,UAAWiG,GAAUrO,QACrBmS,oBAAgBvO,EAChBmO,QAAS,EACTE,QAAS,GAGPuQ,GAAQ,SAAA/N,GACV,OAAOxR,OAAOoW,OAAQpW,OAAOwf,OAAQxf,OAAOyf,eAAejO,IAAUA,IAGnEkO,GAAyB,SAAC7iB,GAC5B,QAA6B8D,IAAzB9D,EAAMqS,eAA8B,CACpC,IAAMzG,EAAI5L,EAAMwO,MAAMxC,SAASoE,WAAU,SAAAvD,GAAC,OAAIA,IAAM7M,EAAMqS,mBAC/C,IAAPzG,IACA5L,EAAMwO,MAAMxC,SAASJ,GAAG5L,MAAQC,EAAYC,SAChDF,EAAMqS,oBAAiBvO,IAIzBgf,GAAuB,SAACjiB,EAAQ6U,GAClC,OAAQA,GACJ,KAAK7L,EAAaC,OACdjJ,EAAOb,MAAQC,EAAYM,YAC3B,MACJ,KAAKsJ,EAAaG,MACdnJ,EAAOb,MAAQC,EAAYO,cAC3B,MACJ,KAAKqJ,EAAaI,KACdpJ,EAAOb,MAAQC,EAAYQ,UAC3B,MACJ,KAAKoJ,EAAaE,SACdlJ,EAAOb,MAAQC,EAAYC,QAC3B,MACJ,KAAK2J,EAAanJ,QACdG,EAAOb,MAAQC,EAAYS,QAC3B,MACJ,KAAKmJ,EAAalJ,QACdE,EAAOb,MAAQC,EAAYU,UAMjCoiB,GAAqB,SAAC1e,EAAMqR,GAC9B,OAAQA,GACJ,KAAKnL,EAAWC,KACZnG,EAAKrE,MAAQ4D,EAAUI,OACvB,MACJ,KAAKuG,EAAWD,UACZjG,EAAKrE,MAAQ4D,EAAUrD,YACvB,MACJ,KAAKgK,EAAWE,OACZpG,EAAKrE,MAAQ4D,EAAUM,WAM7B8e,GAA2B,SAACniB,EAAQ6U,GACtC,OAAQA,GACJ,KAAKvL,EAAiBC,OAClBvJ,EAAOT,UAAYC,EAAgBC,MACnC,MACJ,KAAK6J,EAAiBE,IAClBxJ,EAAOT,UAAYC,EAAgBH,QACnC,MACJ,KAAKiK,EAAiBG,UAClBzJ,EAAOT,UAAYC,EAAgBE,cAMzC2I,GAAuB,SAAClJ,GAC1BA,EAAMwO,MAAMxC,SAASN,SAAQ,SAAAmB,GACzBA,EAAE7M,MAAQC,EAAYC,QACtB2M,EAAEzM,UAAYC,EAAgBC,MAC9BuM,EAAE1M,KAAO,MAEbH,EAAMwO,MAAMvC,MAAMP,SAAQ,SAAAvK,GAAC,OAAIA,EAAEnB,MAAQ4D,EAAU1D,WACnDF,EAAMwO,MAAM6E,mBAAqB,GACjCrT,EAAMqS,oBAAiBvO,GAsNZmf,gBAAgB,CAC3BxU,aApNY,WAAmC,IAC3C+T,EACA5W,EAFS5L,EAAiC,uDAAzBsiB,GAAc5M,EAAW,uCAG9C,OAAQA,EAAOvN,MACX,KAAKnB,EAAWC,WAQZ,OAPAub,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAM4D,UAAUsD,EAAO/V,EAAG+V,EAAO9V,EAAG8V,EAAO7V,QAE7C2iB,EACX,KAAKxb,EAAWE,SAQZ,OAPAsb,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAMtG,QAAQwN,EAAOpS,WAAYoS,EAAOnS,SAAUmS,EAAOjS,QAE3D+e,EACX,KAAKxb,EAAWG,cAQZ,OAPAqb,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAMgE,aAAakD,EAAO7U,QAE5B2hB,EACX,KAAKxb,EAAWI,YAQZ,OAPAob,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAMpG,WAAWsN,EAAOrR,MAE1Bme,EACX,KAAKxb,EAAWU,uBASZ,OARA8a,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAMxC,SAAS0J,EAAOjC,aAAa9T,EAAI+V,EAAO/V,EACvD6iB,EAAShU,MAAMxC,SAAS0J,EAAOjC,aAAa7T,EAAI8V,EAAO9V,EAEhD4iB,EACX,KAAKxb,EAAWK,kBAYZ,OAXAmb,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,SAGnBkH,EAAOpN,YAAcka,EAASla,YAC9Bka,EAASla,UAAYoN,EAAOpN,UAE5Bua,GAAuBL,IAGpBA,EACX,KAAKxb,EAAWM,cAcZ,OAbAkb,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,SAGvBqU,GAAuBL,IAGZ,KADX5W,EAAI4W,EAAShU,MAAMxC,SAASoE,WAAU,SAAAvD,GAAC,OAAIA,IAAM6I,EAAO7U,aAEpD2hB,EAAShU,MAAMxC,SAASJ,GAAG5L,MAAQC,EAAYM,YAC/CiiB,EAASnQ,eAAiBqD,EAAO7U,QAG9B2hB,EACX,KAAKxb,EAAWO,gBAQZ,OAPAib,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,SAGvBqU,GAAuBL,GAEhBA,EACX,KAAKxb,EAAWQ,aACZ,OAAO,gBACAxH,EADP,CAEIyI,QAASiN,EAAOjN,QAChBC,QAASgN,EAAOhN,UAExB,KAAK1B,EAAWS,cACZ,OAAO,gBACAzH,EADP,CAEIyI,aAAS3E,EACT4E,SAAS,IAEjB,KAAK1B,EAAWW,mBAQZ,OAPA6a,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAMqC,oBAER2R,EACX,KAAKxb,EAAWY,eACZ4a,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,SAGvB,IAAMvF,EAAOyM,EAAOzM,KACpB,GAAIA,EAAK0M,aAAehL,EAAoBC,cACxC,GAAI3B,EAAKyM,SAAW7L,EAAaK,qBAC7BsY,EAAShU,MAAMxC,SAASN,SAAQ,SAAAmB,GAAC,OAAIA,EAAE7M,MAAQC,EAAYC,eACxD,CACH,IAAMW,EAAS2hB,EAAShU,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASmJ,EAAKpI,UAC7DA,GACAiiB,GAAqBjiB,EAAQoI,EAAKyM,aAEvC,GAAIzM,EAAK0M,aAAehL,EAAoBE,YAC/C,GAAI5B,EAAKyM,SAAWnL,EAAWL,qBAC3BsY,EAAShU,MAAM6E,mBAAqB,QACjC,GAAIpK,EAAKyM,SAAWnL,EAAWG,KAAM,CACxC,IAAMpH,EAAakf,EAAShU,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASmJ,EAAK3D,QAC/D/B,EAAWif,EAAShU,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASmJ,EAAKjH,MAC7DqC,EAAOme,EAAShU,MAAMoC,SAAStN,EAAYC,IACnC,IAAVc,IACIme,EAAShU,MAAMvC,MAAM5H,GAAMrE,QAAU4D,EAAUG,QAC/Cye,EAAShU,MAAMvC,MAAM5H,GAAMrE,MAAQ4D,EAAU1D,QAE7CsiB,EAAShU,MAAMvC,MAAM5H,GAAMrE,MAAQ4D,EAAUG,aAElD,CACH,IAAMT,EAAakf,EAAShU,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASmJ,EAAK3D,QAC/D/B,EAAWif,EAAShU,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASmJ,EAAKjH,MACnE,GAAIiH,EAAKyM,SAAWnL,EAAWR,SAC3ByY,EAAShU,MAAMuC,kCAAkCzN,EAAYC,EAAU0F,EAAKzF,cACzE,CACH,IAAMa,EAAOme,EAAShU,MAAM0U,qBAAqB5f,EAAYC,EAAU0F,EAAKzF,SAAUyF,EAAKxF,QAC3Fsf,GAAmB1e,EAAM4E,EAAKyM,cAGnC,GAAIzM,EAAK0M,aAAehL,EAAoBG,mBAAoB,CACnE,IAAMjK,EAAS2hB,EAAShU,MAAMxC,SAASkL,MAAK,SAAArK,GAAC,OAAIA,EAAE/M,OAASmJ,EAAKpI,UAC7DA,IACIoI,EAAKyM,SAAWvL,EAAiBC,OACjCvJ,EAAOV,KAAO,GAEdU,EAAOV,KAAO8I,EAAK9I,KACvB6iB,GAAyBniB,EAAQoI,EAAKyM,SAI9C,OAAO8M,EACX,KAAKxb,EAAWa,uBAQZ,OAPA2a,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,SAGvBtF,GAAqBsZ,GAEdA,EACX,KAAKxb,EAAWc,UACZ,OAAO,gBACA9H,EADP,CAEIwO,MAAOkH,EAAOlH,QAEtB,KAAKxH,EAAWe,YACZ,OAAO,gBACA/H,EADP,CAEIiS,QAASyD,EAAO/V,EAChBwS,QAASuD,EAAO9V,IAExB,KAAKoH,EAAWgB,eAkBZ,OAjBAwa,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAM2U,iBACfX,EAAShU,MAAMxC,SAASN,SAAQ,SAAApI,GAG5B,IAFA,IAAI8f,EAAc,EAAIzd,KAAK8K,IAAI,EAAG9K,KAAK+Q,MAAM/Q,KAAKgR,SAAWhR,KAAK+Q,MAAM/Q,KAAK0d,KAAKb,EAAShU,MAAMxC,SAASH,QAAU,KAE7GuX,KAAe,CAClB,IAAM7f,EAAWif,EAAShU,MAAMxC,SAASrG,KAAK+Q,MAAM/Q,KAAKgR,SAAWhR,KAAK+Q,MAAM8L,EAAShU,MAAMxC,SAASH,UACjGpI,EAASkC,KAAK+Q,MAAM/Q,KAAKgR,SAAWhR,KAAK+Q,MAAM,MAErD8L,EAAShU,MAAMtG,QAAQ5E,EAAYC,EAAUE,OAI9C+e,EACX,KAAKxb,EAAWiB,YAQZ,OAPAua,EAAQ,gBACDxiB,EADC,CAEJwO,MAAOkU,GAAM1iB,EAAMwO,UAGdA,MAAMmT,aAERa,EACX,QACI,OAAOxiB,IAMfyf,cAAe8C,GACf3T,iBAAkB0P,GAClB6C,oBAAqBsB,K,SC/SnBa,GAAQC,aAAYC,GAAaC,aAAgBC,OAEvDC,IAASC,OACL,kBAAC,IAAD,CAAUN,MAAOA,IACb,kBAAC,GAAD,OAEJjH,SAASC,eAAe,SLmHtB,kBAAmBuH,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAM3b,a,mBMxI5B6b,EAAOC,QAAU,CAAC,IAAM,mB,wCCAxBD,EAAOC,QAAU,CAAC,KAAO,mBAAmB,WAAW,uBAAuB,wBAAwB,oCAAoC,OAAS,qBAAqB,gCAAgC,4CAA4C,uBAAuB,mCAAmC,kBAAkB,8BAA8B,OAAS,qBAAqB,yBAAyB,qCAAqC,kBAAkB,8BAA8B,cAAc,4B,mBCAxfD,EAAOC,QAAU,CAAC,OAAS,wBAAwB,KAAO,sBAAsB,UAAY,6B,mBCA5FD,EAAOC,QAAU,CAAC,iBAAiB,gCAAgC,eAAe,8BAA8B,OAAS,0B,mBCAzHD,EAAOC,QAAU,CAAC,iBAAiB,wC,mBCAnCD,EAAOC,QAAU,CAAC,uBAAuB,6CAA6C,eAAe,qCAAqC,OAAS,+BAA+B,KAAO,+B,mBCAzLD,EAAOC,QAAU,CAAC,cAAc,gCAAgC,UAAY,8BAA8B,MAAQ,4B,mBCAlHD,EAAOC,QAAU,CAAC,eAAe,kCAAkC,aAAa,gCAAgC,OAAS,4BAA4B,KAAO,0BAA0B,KAAO,4B,mBCA7LD,EAAOC,QAAU,CAAC,aAAa,iC,mBCA/BD,EAAOC,QAAU,CAAC,WAAW,0BAA0B,KAAO,sBAAsB,cAAc,6BAA6B,UAAY,6B,mBCA3ID,EAAOC,QAAU,CAAC,gBAAgB,oCAAoC,OAAS,6BAA6B,qBAAqB,2C,mBCAjID,EAAOC,QAAU,CAAC,OAAS,gCAAgC,aAAa,oCAAoC,gBAAgB,uCAAuC,iBAAiB,wCAAwC,mBAAmB,0CAA0C,oBAAoB,2CAA2C,cAAc,qCAAqC,aAAa,oCAAoC,MAAQ,iC,mBCApcD,EAAOC,QAAU,CAAC,WAAW,0BAA0B,eAAe,8BAA8B,KAAO,sBAAsB,kBAAkB,iCAAiC,KAAO,sBAAsB,UAAY,6B,mBCA7ND,EAAOC,QAAU,CAAC,qBAAqB,6CAA6C,KAAO,+BAA+B,UAAY,sC","file":"static/js/main.3cd6fd6e.chunk.js","sourcesContent":["import { Circle, Group, Text } from \"react-konva\";\nimport React from \"react\";\n\nexport class Vertex {\n    constructor(x, y, radius, name) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.state = VertexState.DEFAULT;\n        this.name = name;\n        this.hint = \"\";\n        this.hintState = VertexHintState.CLEAR;\n    }\n\n    get color() {\n        switch (this.state) {\n            case VertexState.DEFAULT:\n                return 'white';\n            case VertexState.HIGHLIGHTED:\n                return 'yellow';\n            case VertexState.PRE_COMPLETED:\n                return '#CCCCCC';\n            case VertexState.COMPLETED:\n                return '#444444';\n            case VertexState.COLOR_1:\n                return '#ff0000';\n            case VertexState.COLOR_2:\n                return '#0000ff';\n            default:\n                return 'white';\n        }\n    }\n\n    get textColor() {\n        switch (this.state) {\n            case VertexState.DEFAULT:\n                return 'black';\n            case VertexState.HIGHLIGHTED:\n                return 'black';\n            case VertexState.PRE_COMPLETED:\n                return 'black';\n            case VertexState.COMPLETED:\n                return 'white';\n            case VertexState.COLOR_1:\n                return 'white';\n            case VertexState.COLOR_2:\n                return 'white';\n            default:\n                return 'black';\n        }\n    }\n\n    get hintColor() {\n        switch (this.hintState) {\n            case VertexHintState.CLEAR:\n                return '#00000000';\n            case VertexHintState.DEFAULT:\n                return '#ff5f3c';\n            case VertexHintState.HIGHLIGHTED:\n                return '#2c99c3';\n            default:\n                return '#00000000';\n        }\n    }\n}\n\nconst handleDragStart = (e, call) => {\n    e.target.getChildren()[0].setAttrs({\n        scaleX: 1.1,\n        scaleY: 1.1,\n        shadowColor: 'black',\n        shadowBlur: 10,\n        shadowOffset: { x: 10, y: 10 },\n        shadowOpacity: 0.5\n    });\n    e.target.moveToTop();\n\n    call(e);\n};\n\nconst handleDragEnd = (e, call) => {\n    e.target.getChildren()[0].to({\n        duration: 0.25,\n        scaleX: 1,\n        scaleY: 1,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0\n    });\n\n    call(e);\n};\n\nexport const VertexComponent = ({ vertex, draggable, onDragStart, onDragEnd, onDragMove, onClick }) => {\n    const labelWidth = 40, labelHeight = 20;\n    return (\n        <Group\n            draggable={draggable}\n            onDragStart={e => handleDragStart(e, onDragStart)}\n            onDragEnd={e => handleDragEnd(e, onDragEnd)}\n            onDragMove={onDragMove}\n            onClick={onClick}\n            x={vertex.x}\n            y={vertex.y}>\n            <Circle\n                x={0}\n                y={0}\n                radius={vertex.radius}\n                fill={vertex.color}\n                stroke={'black'}\n                shadowBlur={0}\n                strokeWidth={vertexBorderWidth}\n                shadowOpacity={0.5}/>\n            <Text\n                text={vertex.name}\n                x={-labelWidth / 2.}\n                y={-labelHeight / 2.}\n                fontSize={20}\n                fill={vertex.textColor}\n                width={labelWidth}\n                height={labelHeight}\n                align={'center'}\n                verticalAlign={'middle'}/>\n\n            <Text\n                text={vertex.hint}\n                x={-2 * vertex.radius}\n                y={-2 * vertex.radius}\n                fontSize={25}\n                fill={vertex.hintColor}\n                stroke={vertex.hintColor}\n                width={labelWidth * 2}\n                height={labelHeight}\n                align={'center'}\n                verticalAlign={'middle'}/>\n        </Group>);\n};\n\nexport const vertexBorderWidth = 2;\n\nexport const VertexState = Object.freeze({ DEFAULT: 0, HIGHLIGHTED: 1, PRE_COMPLETED: 2, COMPLETED: 3, COLOR_1: 4, COLOR_2: 5 });\nexport const VertexHintState = Object.freeze({ CLEAR: 0, DEFAULT: 1, HIGHLIGHTED: 2 });","import { vertexBorderWidth } from \"../Vertex/Vertex\";\nimport { Arrow, Circle, Group, Line, Text } from \"react-konva\";\nimport React from \"react\";\n\nexport class Edge {\n    constructor(vertexFrom, vertexTo, oriented, weight) {\n        this._from = vertexFrom;\n        this._to = vertexTo;\n        this.weight = weight;\n        this.state = EdgeState.DEFAULT;\n        this._oriented = oriented;\n    }\n\n    get from() {\n        return this._from;\n    }\n\n    get to() {\n        return this._to;\n    }\n\n    get color() {\n        switch (this.state) {\n            case EdgeState.DEFAULT:\n                return 'black';\n            case EdgeState.HIGHLIGHTED:\n                return '#f7ff00';\n            case EdgeState.WALKED:\n                return '#ff5f3c';\n            case EdgeState.ERASED:\n                return '#ffffff00';\n            case EdgeState.SHADOWED:\n                return '#dddddd';\n            case EdgeState.FLIPPED:\n                return 'black';\n            default:\n                return 'black';\n        }\n    }\n\n    isWeighted() {\n        return (this.weight !== undefined) && (this.weight !== null);\n    }\n\n    isOriented() {\n        return this._oriented;\n    }\n\n    isFlipped() {\n        return this.state === EdgeState.FLIPPED;\n    }\n\n    invertOrientation() {\n        this._oriented = !this._oriented;\n    }\n}\n\nexport const EdgeComponent = ({ edge, edgeType, onClick }) => {\n    const points = getEdgePointsForType(edge, edgeType);\n    const color = edge.color;\n\n    let edgeComponent;\n    if (edgeType === EdgeType.NOT_ORIENTED)\n        edgeComponent = (\n            <Line\n                points={points.linePoints}\n                onClick={onClick}\n                stroke={color}\n                fill={color}\n                strokeWidth={2}\n                hitStrokeWidth={15}/>\n        );\n    else\n        edgeComponent = (\n            <Arrow\n                points={points.linePoints}\n                onClick={onClick}\n                stroke={color}\n                fill={color}\n                strokeWidth={2}\n                hitStrokeWidth={15}\n                tension={0.5}/>\n        );\n\n    if (edge.isWeighted())\n        return (\n            <Group onClick={onClick}>\n                {edgeComponent}\n                <EdgeLabel\n                    x={points.labelPoints[0]}\n                    y={points.labelPoints[1]}\n                    text={edge.weight}/>\n            </Group>\n        );\n    else\n        return (edgeComponent);\n};\n\nexport const EdgeLabel = ({ x, y, text }) => {\n    const labelRadius = 15;\n    const labelHorizontalPadding = 1, labelVerticalPadding = 5;\n    const labelBorderWidth = 0;\n    return (\n        <Group\n            x={x - labelRadius - labelHorizontalPadding - labelBorderWidth}\n            y={y - labelRadius - labelVerticalPadding - labelBorderWidth}\n            width={labelRadius * 2. + 2. * (labelHorizontalPadding + labelBorderWidth)}\n            height={labelRadius * 2. + 2. * (labelVerticalPadding + labelBorderWidth)}>\n            <Circle\n                x={labelRadius + labelHorizontalPadding + labelBorderWidth}\n                y={labelRadius + labelVerticalPadding + labelBorderWidth}\n                radius={labelRadius}\n                fill={'white'}\n                stroke={'black'}\n                strokeWidth={labelBorderWidth}/>\n            <Text\n                x={labelBorderWidth + labelHorizontalPadding}\n                y={labelBorderWidth + labelVerticalPadding}\n                text={text}\n                fontSize={20}\n                width={labelRadius * 2.}\n                height={labelRadius * 2.}\n                align={'center'}\n                verticalAlign={'middle'}/>\n        </Group>\n    );\n};\n\nexport const EdgeType = Object.freeze({ ONE_SIDE_ORIENTED: 0, TWO_SIDE_ORIENTED: 1, NOT_ORIENTED: 2, LOOP: 3 });\nexport const EdgeState = Object.freeze({ DEFAULT: 0, HIGHLIGHTED: 1, ERASED: 2, WALKED: 3, SHADOWED: 4, FLIPPED: 5 });\n\nexport const getEdgePointsForType = (edge, edgeType) => {\n    let vertexFrom = edge.from;\n    let vertexTo = edge.to;\n    if (edge.isFlipped())\n        [vertexFrom, vertexTo] = [vertexTo, vertexFrom];\n\n    const dx = vertexTo.x - vertexFrom.x;\n    const dy = vertexFrom.y - vertexTo.y;\n    const angle = Math.atan2(dy, dx);\n    const vertexFromOffset = vertexFrom.radius + vertexBorderWidth / 2.;\n    const vertexToOffset = vertexTo.radius + vertexBorderWidth / 2.;\n\n    if ((edgeType === EdgeType.ONE_SIDE_ORIENTED) || (edgeType === EdgeType.NOT_ORIENTED)) {\n        const xFrom = vertexFrom.x + vertexFromOffset * Math.cos(angle);\n        const yFrom = vertexFrom.y - vertexFromOffset * Math.sin(angle);\n        const xTo = vertexTo.x - vertexToOffset * Math.cos(angle);\n        const yTo = vertexTo.y + vertexToOffset * Math.sin(angle);\n\n        return {\n            linePoints: [\n                xFrom, yFrom,\n                xTo, yTo\n            ],\n            labelPoints: [\n                (xFrom + xTo) / 2.,\n                (yFrom + yTo) / 2.\n            ]\n        };\n    } else if (edgeType === EdgeType.TWO_SIDE_ORIENTED) {\n        const angleOffset = 0.25;\n        const xFrom = vertexFrom.x + vertexFromOffset * Math.cos(angle + angleOffset);\n        const yFrom = vertexFrom.y - vertexFromOffset * Math.sin(angle + angleOffset);\n        const xTo = vertexTo.x - vertexToOffset * Math.cos(angle - angleOffset);\n        const yTo = vertexTo.y + vertexToOffset * Math.sin(angle - angleOffset);\n\n        const middlePointHeightCoefficient = 1. / 15.;\n        const xMiddle = (xFrom + xTo) / 2. - (yFrom - yTo) * middlePointHeightCoefficient;\n        const yMiddle = (yFrom + yTo) / 2. + (xFrom - xTo) * middlePointHeightCoefficient;\n\n        return {\n            linePoints: [\n                xFrom, yFrom,\n                xMiddle, yMiddle,\n                xTo, yTo\n            ],\n            labelPoints: [\n                xMiddle,\n                yMiddle\n            ]\n        };\n    } else if (edgeType === EdgeType.LOOP) {\n        const xFrom = vertexFrom.x - vertexFromOffset;\n        const yFrom = vertexFrom.y;\n        const xTo = vertexFrom.x - vertexFromOffset;\n        const yTo = vertexFrom.y;\n\n        const anchorDx = 3. * vertexFromOffset / Math.sqrt(2.);\n        const anchorDy = 1.5 * vertexFromOffset / Math.sqrt(2.);\n        const xMiddleFirst = xFrom - anchorDx;\n        const yMiddleFirst = yFrom - anchorDy;\n        const xMiddle = xMiddleFirst - vertexFromOffset;\n        const yMiddle = yFrom;\n        const xMiddleSecond = xTo - anchorDx;\n        const yMiddleSecond = yTo + anchorDy;\n\n        return {\n            linePoints: [\n                xFrom, yFrom,\n                xMiddleFirst, yMiddleFirst,\n                xMiddle, yMiddle,\n                xMiddleSecond, yMiddleSecond,\n                xTo, yTo\n            ],\n            labelPoints: [\n                xMiddle, yMiddle\n            ]\n        };\n    }\n};","export function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}","import { sleep } from \"../utils/sleep\";\n\nexport const ActionType = Object.freeze({\n    ADD_VERTEX: 'ADD_VERTEX',\n    ADD_EDGE: 'ADD_EDGE',\n    REMOVE_VERTEX: 'REMOVE_VERTEX',\n    REMOVE_EDGE: 'REMOVE_EDGE',\n    CHANGE_GRAPH_MODE: 'CHANGE_GRAPH_MODE',\n    SELECT_VERTEX: 'SELECT_VERTEX',\n    UNSELECT_VERTEX: 'UNSELECT_VERTEX',\n    SHOW_MESSAGE: 'SHOW_MESSAGE',\n    CLOSE_MESSAGE: 'CLOSE_MESSAGE',\n    UPDATE_VERTEX_POSITION: 'UPDATE_VERTEX_POSITION',\n    INVERT_ORIENTATION: 'INVERT_ORIENTATION',\n    ALGORITHM_STEP: 'ALGORITHM_STEP',\n    CLEAN_GRAPH_SELECTIONS: 'CLEAN_GRAPH_SELECTIONS',\n    SET_GRAPH: 'SET_GRAPH',\n    MOVE_CANVAS: 'MOVE_CANVAS',\n    GENERATE_GRAPH: 'GENERATE_GRAPH',\n    CLEAR_GRAPH: 'CLEAR_GRAPH'\n});\n\nexport const addVertex = (x, y, radius) => ({\n    type: ActionType.ADD_VERTEX,\n    x,\n    y,\n    radius\n});\n\nexport const addEdge = (vertexFrom, vertexTo, weight) => ({\n    type: ActionType.ADD_EDGE,\n    vertexFrom,\n    vertexTo,\n    weight\n});\n\nexport const removeVertex = (vertex) => ({\n    type: ActionType.REMOVE_VERTEX,\n    vertex\n});\n\nexport const removeEdge = (edge) => ({\n    type: ActionType.REMOVE_EDGE,\n    edge\n});\n\nexport const changeGraphMode = (graphMode) => ({\n    type: ActionType.CHANGE_GRAPH_MODE,\n    graphMode\n});\n\nexport const selectVertex = (vertex) => ({\n    type: ActionType.SELECT_VERTEX,\n    vertex\n});\n\nexport const unselectVertex = (vertex) => ({\n    type: ActionType.UNSELECT_VERTEX,\n    vertex\n});\n\nlet currentMessageId = 0;\n\nexport const showMessage = (message, isAlert = false) => async (dispatch) => {\n    const messageId = ++currentMessageId;\n    dispatch(showMessageConnector(message, isAlert));\n    await sleep(2000);\n    if (messageId === currentMessageId)\n        dispatch(closeMessage());\n};\n\nconst showMessageConnector = (message, isAlert = false) => ({\n    type: ActionType.SHOW_MESSAGE,\n    message,\n    isAlert\n});\n\nexport const closeMessage = () => ({\n    type: ActionType.CLOSE_MESSAGE\n});\n\nexport const updateVertexPosition = (vertexIndex, x, y) => ({\n    type: ActionType.UPDATE_VERTEX_POSITION,\n    vertexIndex,\n    x,\n    y\n});\n\nexport const invertOrientation = () => ({\n    type: ActionType.INVERT_ORIENTATION\n});\n\nexport const algorithmStep = (step) => ({\n    type: ActionType.ALGORITHM_STEP,\n    step\n});\n\nexport const cleanGraphSelections = () => ({\n    type: ActionType.CLEAN_GRAPH_SELECTIONS\n});\n\nexport const setGraph = (graph) => ({\n    type: ActionType.SET_GRAPH,\n    graph\n});\n\nexport const moveCanvas = (x, y) => ({\n    type: ActionType.MOVE_CANVAS,\n    x,\n    y\n});\n\nexport const generateGraph = () => ({\n    type: ActionType.GENERATE_GRAPH\n});\n\nexport const clearGraph = () => ({\n   type: ActionType.CLEAR_GRAPH\n});","export const ActionType = Object.freeze({\n    START_DIALOG_FOR_RESULT: 'START_DIALOG_FOR_RESULT',\n    CLOSE_DIALOG: 'CLOSE_DIALOG'\n});\n\nexport const startDialogForResult = (title, text, hint, inputPlaceholder, onSubmit, onCancel, pattern = \".*\") => ({\n    type: ActionType.START_DIALOG_FOR_RESULT,\n    title,\n    text,\n    hint,\n    inputPlaceholder,\n    onSubmit,\n    onCancel,\n    pattern\n});\n\nconst closeDialog = () => ({\n   type: ActionType.CLOSE_DIALOG\n});\n\nexport const cancelDialog = (onCancel) => (dispatch) => {\n    if (onCancel)\n        onCancel();\n    dispatch(closeDialog());\n};\n\nexport const submitDialog = (onSubmit, result) => (dispatch) => {\n    if (onSubmit)\n        onSubmit(result);\n    dispatch(closeDialog());\n};","export const VertexAction = Object.freeze({\n    SELECT: 0,\n    UNSELECT: 1,\n    ENTER: 2,\n    EXIT: 3,\n    COLOR_1: 4,\n    COLOR_2: 5,\n    CLEAR_ALL_SELECTIONS: 6\n});\n\nexport const VertexHintAction = Object.freeze({\n    REMOVE: 0,\n    SET: 1,\n    HIGHLIGHT: 2\n});\n\nexport const EdgeAction = Object.freeze({\n    WALK: 0,\n    HIGHLIGHT: 1,\n    UNSELECT: 2,\n    SHADOW: 3,\n    CLEAR_ALL_SELECTIONS: 4,\n    FLIP: 5\n});\n\nexport const AlgorithmActionType = Object.freeze({\n    VERTEX_ACTION: 0,\n    EDGE_ACTION: 1,\n    VERTEX_HINT_ACTION: 2\n});\n\nexport const PreCallAction = Object.freeze({\n    NOTHING: 0,\n    SELECT_VERTEX: 1,\n    SELECT_EDGE: 2\n});\n\nexport const Criteria = Object.freeze({\n    NOTHING: 0,\n    WEIGHTED: 0b1,\n    CONNECTED: 0b10,\n    NOT_ORIENTED: 0b100,\n    ORIENTED: 0b1000,\n    ACYCLIC: 0b10000\n});\n\nexport const getOperationsCount = (trace) => {\n    let operationsCount = 0;\n    trace.forEach((t, i) => {\n        if ((i + 1 === trace.length) || !t.isChained)\n            ++operationsCount;\n    });\n    return operationsCount;\n};","import { Edge } from \"../components/Graph/Edge/Edge\";\n\nexport const edgesListToAdjacencyList = (vertices, edges) => {\n    const adjacencyList = {};\n    vertices.forEach(vertex => adjacencyList[vertex.name] = []);\n    edges.forEach(edge => {\n        adjacencyList[edge.from.name].push({name: edge.to.name, weight: edge.weight});\n        if (!edge.isOriented() && (edge.from !== edge.to))\n            adjacencyList[edge.to.name].push({name: edge.from.name, weight: edge.weight});\n    });\n    for (let [, verticesList] of Object.entries(adjacencyList))\n        verticesList = verticesList.sort((a, b) => a.name - b.name);\n    return adjacencyList;\n};\n\nexport const edgesListToReversedAdjacencyList = (vertices, edges) => {\n    return edgesListToAdjacencyList(vertices, edges.map(e =>\n        new Edge(e.to, e.from, e.isOriented(), e.weight))\n    );\n};\n\nexport const edgesListToAdjacencyMatrix = (vertices, edges) => {\n    const verticesNumbers = [];\n    vertices.forEach(v => verticesNumbers.push(v.name));\n    verticesNumbers.sort((a, b) => a - b);\n    const nameToIndex = {};\n    verticesNumbers.forEach((number, index) => nameToIndex[number] = index);\n\n    const adjacencyMatrix = new Array(vertices.length);\n    for (let i = 0; i < vertices.length; ++i) {\n        adjacencyMatrix[i] = new Array(vertices.length);\n        for (let j = 0; j < vertices.length; ++j)\n            adjacencyMatrix[i][j] = null;\n    }\n\n    let from, to, cell;\n    edges.forEach(e => {\n        from = nameToIndex[e.from.name];\n        to = nameToIndex[e.to.name];\n        cell = e.weight ? { weighted: true, weight: e.weight } : { weighted : false };\n        adjacencyMatrix[from][to] = cell;\n        if (!e.isOriented())\n            adjacencyMatrix[to][from] = cell;\n    });\n\n    return {adjacencyMatrix, verticesNumbers};\n};","import { algorithmStep, changeGraphMode, closeMessage, showMessage } from \"./index\";\nimport { GraphMode } from \"../components/Graph/Graph\";\nimport { Criteria, PreCallAction } from \"../algorithms/graph\";\nimport { sleep } from \"../utils/sleep\";\nimport { edgesListToAdjacencyList } from \"../utils/graphConverter\";\n\nexport const ActionType = Object.freeze({\n    PRE_CALL: 'PRE_CALL',\n    CALL: 'CALL',\n    START: 'START',\n    PAUSE: 'PAUSE',\n    POP_TRACE_STEP: 'POP_TRACE_STEP',\n    SET_ALGORITHM: 'SET_ALGORITHM',\n    SET_SPEED: 'SET_SPEED',\n    SET_IS_ONE_STEP: 'SET_IS_ONE_STEP',\n    CLEAR_TRACE: 'CLEAR_TRACE',\n    SHOW_STATISTICS: 'SHOW_STATISTICS',\n    CLEAR_STATISTICS: 'CLEAR_STATISTICS',\n    SHOW_ALGORITHM_INFO: 'SHOW_ALGORITHM_INFO',\n    CLEAR_ALGORITHM_INFO: 'CLEAR_ALGORITHM_INFO',\n    INVERT_ALGORITHM_INFO_COLLAPSED: 'INVERT_ALGORITHM_INFO_COLLAPSED'\n});\n\nexport const preCall = (isOneStep = false) => (dispatch, getState) => {\n    dispatch(setIsOneStep(isOneStep));\n\n    const graph = getState().graphReducer.graph;\n    const vertices = graph.vertices;\n    const edges = graph.edges;\n    const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n\n    const criteria = getState().algorithmReducer.algorithm.criteria;\n    if (criteria & Criteria.WEIGHTED) {\n        for (const edge of edges) {\n            if (!edge.isWeighted()) {\n                dispatch(showMessage(\"Граф должен быть взвешенным!\", true));\n                return;\n            }\n        }\n    }\n    if ((criteria & Criteria.NOT_ORIENTED) && graph.isOriented()) {\n        dispatch(showMessage(\"Граф должен быть неориентированным!\", true));\n        return;\n    }\n    if ((criteria & Criteria.ORIENTED) && !graph.isOriented()) {\n        dispatch(showMessage(\"Граф должен быть ориентированным!\", true));\n        return;\n    }\n    if ((criteria & Criteria.CONNECTED) && (vertices.length > 0)) {\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        const dfs = (v) => {\n            used[v] = true;\n            let to;\n            adjacencyList[v].forEach(toVertex => {\n                to = toVertex.name;\n                if (!used[to]) {\n                    dfs(to);\n                }\n            });\n        };\n        dfs(vertices[0].name);\n\n        for (const v of vertices) {\n            if (!used[v.name]) {\n                dispatch(showMessage(\"Граф должен быть связным!\", true));\n                return;\n            }\n        }\n    }\n    if ((criteria & Criteria.ACYCLIC) && (vertices.length > 0)) {\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = 0);\n        const dfs = (v) => {\n            used[v] = 1;\n            let to;\n            for (const toVertex of adjacencyList[v]) {\n                to = toVertex.name;\n                if (!used[to]) {\n                    if (!dfs(to))\n                        return false;\n                } else if (used[to] === 1) {\n                    return false;\n                }\n            }\n            used[v] = 2;\n            return true;\n        };\n        for (const {name: start} of vertices) {\n            if (!used[start] && !dfs(start)) {\n                dispatch(showMessage(\"Граф должен быть ацикличным!\", true));\n                return;\n            }\n        }\n    }\n\n    const preCall = getState().algorithmReducer.algorithm.preCall;\n    if (preCall === PreCallAction.SELECT_VERTEX) {\n        dispatch(changeGraphMode(GraphMode.ALGORITHM_PRE_CALL_SELECT_VERTEX));\n        dispatch(showMessage(\"Выберите вершину\"));\n    } else if (preCall === PreCallAction.SELECT_EDGE) {\n        dispatch(changeGraphMode(GraphMode.ALGORITHM_PRE_CALL_SELECT_EDGE));\n        dispatch(showMessage(\"Выберите ребро\"));\n    } else if (preCall === PreCallAction.NOTHING) {\n        dispatch(call());\n    }\n};\n\nexport const setSpeed = (speed) => ({\n    type: ActionType.SET_SPEED,\n    speed\n});\n\nexport const setAlgorithm = (algorithm) => ({\n    type: ActionType.SET_ALGORITHM,\n    algorithm\n});\n\nconst setIsOneStep = (isOneStep) => ({\n    type: ActionType.SET_IS_ONE_STEP,\n    isOneStep\n});\n\nexport const call = (vertex, edge) => (dispatch, getState) => {\n    dispatch(closeMessage());\n    dispatch(changeGraphMode(GraphMode.DEFAULT));\n    const graph = getState().graphReducer.graph;\n    dispatch(callConnector(graph, vertex, edge));\n    dispatch(showAlgorithmInfo());\n\n    const isOneStep = getState().algorithmReducer.isOneStep;\n    isOneStep ? dispatch(pause()) : dispatch(start());\n    dispatch(callSuccess(isOneStep));\n};\n\nexport const continueCall = (isOneStep = false) => (dispatch) => {\n    isOneStep ? dispatch(pause()) : dispatch(start());\n    dispatch(callSuccess(isOneStep));\n};\n\nconst start = () => ({\n    type: ActionType.START\n});\n\nexport const pause = () => ({\n    type: ActionType.PAUSE\n});\n\nconst callConnector = (graph, vertex, edge) => ({\n    type: ActionType.CALL,\n    graph,\n    vertex,\n    edge\n});\n\nlet currentVisualizationId = 0; // To prevent several visualization 'threads'\n\nconst callSuccess = (isOneStep = false) => async (dispatch, getState) => {\n    if (isOneStep) {\n        let traceStep = {isChained : true};\n        while ((getState().algorithmReducer.trace.length > 0) && traceStep.isChained) {\n            traceStep = getState().algorithmReducer.trace[0];\n            dispatch(algorithmStep(traceStep));\n            dispatch(popTraceStep());\n\n            if (getState().algorithmReducer.trace.length === 0) {\n                dispatch(showStatistics());\n            }\n        }\n        return;\n    }\n\n    const visualizationId = ++currentVisualizationId;\n    let traceStep;\n    while ((getState().algorithmReducer.trace.length > 0) && getState().algorithmReducer.isActive) {\n        traceStep = getState().algorithmReducer.trace[0];\n        dispatch(algorithmStep(traceStep));\n        dispatch(popTraceStep());\n        if ((getState().algorithmReducer.trace.length > 0) && !traceStep.isChained) {\n            await sleep(getState().algorithmReducer.speed);\n            if (currentVisualizationId !== visualizationId)\n                return;\n        }\n    }\n    if (getState().algorithmReducer.isActive) {\n        dispatch(pause());\n        dispatch(showStatistics());\n    }\n};\n\nconst popTraceStep = () => ({\n    type: ActionType.POP_TRACE_STEP\n});\n\nexport const clearTrace = () => ({\n    type: ActionType.CLEAR_TRACE\n});\n\nconst showStatistics = () => ({\n   type: ActionType.SHOW_STATISTICS\n});\n\nexport const clearStatistics = () => ({\n    type: ActionType.CLEAR_STATISTICS\n});\n\nconst showAlgorithmInfo = () => ({\n   type: ActionType.SHOW_ALGORITHM_INFO\n});\n\nexport const clearAlgorithmInfo = () => ({\n    type: ActionType.CLEAR_ALGORITHM_INFO\n});\n\nexport const invertAlgorithmInfoCollapsed = () => ({\n    type: ActionType.INVERT_ALGORITHM_INFO_COLLAPSED,\n});","import { Arrow, Group, Line } from \"react-konva\";\nimport React from \"react\";\nimport { EdgeLabel, getEdgePointsForType } from \"../Edge/Edge\";\n\nexport const VisualizationEdgeComponent = ({ edge, edgeType }) => {\n    const points = getEdgePointsForType(edge, edgeType);\n    const color = edge.color;\n    let edgeComponent;\n    if (edgeType === EdgeType.NOT_ORIENTED)\n        edgeComponent = (\n            <Line\n                points={points.linePoints}\n                stroke={color}\n                fill={color}\n                strokeWidth={3}\n                hitStrokeWidth={16}/>\n        );\n    else\n        edgeComponent = (\n            <Arrow\n                points={points.linePoints}\n                stroke={color}\n                fill={color}\n                strokeWidth={3}\n                hitStrokeWidth={16}\n                tension={0.5}/>\n        );\n\n    if (edge.isWeighted())\n        return (\n            <Group>\n                {edgeComponent}\n                <EdgeLabel\n                    x={points.labelPoints[0]}\n                    y={points.labelPoints[1]}\n                    text={edge.weight}/>\n            </Group>\n        );\n    else\n        return (edgeComponent);\n};\n\nexport const EdgeType = Object.freeze({ ONE_SIDE_ORIENTED: 0, TWO_SIDE_ORIENTED: 1, NOT_ORIENTED: 2, LOOP: 3 });","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./Graph.module.scss\";\nimport { Layer, Rect, Stage } from \"react-konva\";\nimport { Vertex, VertexComponent } from \"./Vertex/Vertex\";\nimport { Edge, EdgeComponent, EdgeType } from \"./Edge/Edge\";\nimport { connect } from \"react-redux\";\nimport {\n    addEdge,\n    addVertex,\n    moveCanvas,\n    removeEdge,\n    removeVertex,\n    selectVertex,\n    unselectVertex,\n    updateVertexPosition\n} from \"../../actions\";\nimport { startDialogForResult } from \"../../actions/dialog\";\nimport { call } from \"../../actions/algorithm\";\nimport { VisualizationEdgeComponent } from \"./VisualizationEdge/VisualizationEdge\";\n\nconst cx = classnames.bind(styles);\n\nexport const vertexRadius = 20;\n\nconst mapStateToProps = state => ({\n    graph: state.graphReducer.graph,\n    graphMode: state.graphReducer.graphMode,\n    selectedVertex: state.graphReducer.selectedVertex,\n    canvasX: state.graphReducer.canvasX,\n    canvasY: state.graphReducer.canvasY\n});\n\nexport const GraphMode = Object.freeze({\n    DEFAULT: 0,\n    ADD_VERTEX: 1,\n    ADD_EDGE: 2,\n    REMOVE_VERTEX_OR_EDGE: 3,\n    ALGORITHM_PRE_CALL_SELECT_VERTEX: 4,\n    ALGORITHM_PRE_CALL_SELECT_EDGE: 5\n});\n\nexport class Graph {\n    constructor(oriented, vertices = null, edges = null) {\n        if (!vertices || !Array.isArray(vertices) || !edges || !Array.isArray(edges)) {\n            this._vertices = [];\n            this._edges = [];\n            this._visualizationEdges = [];\n            this._oriented = oriented;\n            this._currentName = 0;\n        } else {\n            for (let i = 0; i < vertices.length; ++i) {\n                if ((vertices[i].name < 0) || (vertices[i].name > 999))\n                    throw new Error(\"Invalid vertex name\");\n\n                for (let j = 0; j < vertices.length; ++j) {\n                    if ((i !== j) && (vertices[i].name === vertices[j].name))\n                        throw new Error(\"Two vertices with equal names\");\n                }\n            }\n\n            for (let i = 0; i < edges.length; ++i) {\n                if (edges[i].weight && ((edges[i].weight < 0) || (edges[i].weight > 99)))\n                    throw new Error(\"Invalid edge weight\");\n                if (vertices.findIndex(v => v.name === edges[i].from.name) === -1)\n                    throw new Error(\"Invalid vertex 'from'\");\n                if (vertices.findIndex(v => v.name === edges[i].to.name) === -1)\n                    throw new Error(\"Invalid vertex 'to'\");\n\n                for (let j = 0; j < edges.length; ++j) {\n                    if (i !== j) {\n                        if (oriented) {\n                            if ((edges[i].from.name === edges[j].from.name) && (edges[i].to.name === edges[j].to.name))\n                                throw new Error(\"Multiedges aren't supported\");\n                        } else {\n                            if ((edges[i].from.name === edges[j].from.name) && (edges[i].to.name === edges[j].to.name)\n                                || (edges[i].to.name === edges[j].from.name) && (edges[i].from.name === edges[j].to.name)) {\n                                throw new Error(\"Multiedges aren't supported\");\n                            }\n                        }\n                    }\n                }\n            }\n\n            this._vertices = [...vertices];\n            this._edges = [...edges];\n            this._visualizationEdges = [];\n            this._oriented = oriented;\n            this._currentName = Math.max(...vertices.map(v => v.name)) + 1;\n        }\n    }\n\n    addVertex(x, y, radius) {\n        const vertex = new Vertex(x, y, radius, this._currentName++);\n        this._vertices.push(vertex);\n        return vertex;\n    }\n\n    removeVertex(vertex) {\n        const index = this._vertices.findIndex(v => v === vertex);\n        if (index !== -1) {\n            this._vertices.splice(index, 1);\n            this._edges = this._edges.filter(edge => (edge.from.name !== vertex.name) && (edge.to.name !== vertex.name));\n        }\n    }\n\n    findEdge(vertexFrom, vertexTo) {\n        if (this._oriented)\n            return this._edges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo));\n        else\n            return this._edges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo)\n                || (e.to === vertexFrom) && (e.from === vertexTo));\n    }\n\n    addEdge(vertexFrom, vertexTo, weight) {\n        const i = this.findEdge(vertexFrom, vertexTo);\n        if (i === -1) {\n            const edge = new Edge(vertexFrom, vertexTo, this._oriented, weight);\n            this._edges.push(edge);\n            return edge;\n        }\n        else {\n            this._edges[i].weight = weight;\n        }\n    }\n\n    removeEdge(edge) {\n        this._edges = this._edges.filter(e => e !== edge);\n    }\n\n    removeAllEdges() {\n        this._edges = [];\n    }\n\n    invertOrientation() {\n        this._oriented = !this._oriented;\n        if (this._oriented) {\n            this._edges.forEach(edge => edge.invertOrientation());\n            const oldEdges = [...this._edges];\n            oldEdges.forEach(e => this.addEdge(e.to, e.from, e.weight));\n        } else {\n            const newEdges = [];\n            this._edges.forEach(edge => {\n                if (newEdges.findIndex(e => (e.from === edge.from) && (e.to === edge.to)\n                    || (e.to === edge.from) && (e.from === edge.to)) === -1) {\n\n                    edge.invertOrientation();\n                    newEdges.push(edge);\n                }\n            });\n            this._edges = newEdges;\n        }\n    }\n\n    findVisualizationEdge(vertexFrom, vertexTo, oriented) {\n        if (oriented)\n            return this._visualizationEdges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo));\n        else\n            return this._visualizationEdges.findIndex(e => (e.from === vertexFrom) && (e.to === vertexTo)\n                || (e.to === vertexFrom) && (e.from === vertexTo));\n    }\n\n    addVisualizationEdge(vertexFrom, vertexTo, oriented, weight) {\n        this.removeVisualizationEdgeByVertices(vertexFrom, vertexTo, oriented);\n        const edge = new Edge(vertexFrom, vertexTo, oriented, weight);\n        this._visualizationEdges.push(edge);\n        return edge;\n    }\n\n    removeVisualizationEdge(edge) {\n        this._visualizationEdges = this._visualizationEdges.filter(e => e !== edge);\n    }\n\n    removeVisualizationEdgeByVertices(vertexFrom, vertexTo, oriented) {\n        if (oriented)\n            this._visualizationEdges = this._visualizationEdges.filter(e =>\n                (e.from.name !== vertexFrom.name) || (e.to.name !== vertexTo.name)\n            );\n        else\n            this._visualizationEdges = this._visualizationEdges.filter(e =>\n                ((e.from.name !== vertexFrom.name) || (e.to.name !== vertexTo.name)) &&\n                ((e.to.name !== vertexFrom.name) || (e.from.name !== vertexTo.name))\n            );\n    }\n\n    clearGraph() {\n        this._vertices = [];\n        this._visualizationEdges = [];\n        this._edges = [];\n        this._currentName = 0;\n    }\n\n    get vertices() {\n        return this._vertices;\n    }\n\n    get edges() {\n        return this._edges;\n    }\n\n    get visualizationEdges() {\n        return this._visualizationEdges;\n    }\n\n    set visualizationEdges(edges) {\n        this._visualizationEdges = edges;\n    }\n\n    isOriented() {\n        return this._oriented;\n    }\n}\n\nclass GraphComponent extends React.Component {\n    state = {\n        draggedVertex: undefined,\n        windowWidth: 700,\n        windowHeight: 700\n    };\n\n    componentDidMount() {\n        const handleResize = () => {\n            this.setState({ windowWidth: window.innerWidth, windowHeight: window.innerHeight });\n        };\n        window.onresize = handleResize;\n        handleResize();\n    }\n\n    findIndexOfVertex = (vertex) => {\n        return this.props.graph.vertices.findIndex(v => v === vertex);\n    };\n\n    handleVertexDragStart = (e, vertex) => {\n        e.cancelBubble = true;\n\n        const i = this.findIndexOfVertex(vertex);\n        this.setState({ draggedVertex: (i !== -1 ? i : undefined) });\n    };\n\n    updateDraggedVertex = (x, y) => {\n        const vertex = this.state.draggedVertex;\n        if (vertex !== undefined)\n            this.props.updateVertexPosition(vertex, x, y);\n    };\n\n    handleVertexDragMove = e => {\n        e.cancelBubble = true;\n\n        this.updateDraggedVertex(e.target.x(), e.target.y());\n    };\n\n    handleVertexDragEnd = (e, vertex) => {\n        e.cancelBubble = true;\n\n        this.updateDraggedVertex(e.target.x(), e.target.y());\n        this.setState({ draggedVertex: undefined });\n    };\n\n    getEdgeType = edge => {\n        const vertexFrom = edge.from, vertexTo = edge.to;\n\n        if (vertexTo === vertexFrom)\n            return EdgeType.LOOP;\n        else if (!edge.isOriented())\n            return EdgeType.NOT_ORIENTED;\n        else if ((this.props.graph.edges.findIndex(e => (e.from === vertexTo) && (e.to === vertexFrom)) !== -1)\n                && (this.props.graph.edges.findIndex(e => (e.to === vertexTo) && (e.from === vertexFrom)) !== -1))\n            return EdgeType.TWO_SIDE_ORIENTED;\n        else\n            return EdgeType.ONE_SIDE_ORIENTED;\n    };\n\n    handleCanvasClick = e => {\n        const x = e.evt.clientX - this.props.canvasX, y = e.evt.clientY - this.props.canvasY;\n\n        if (this.props.graphMode === GraphMode.ADD_VERTEX)\n            this.props.addVertex(x, y, vertexRadius);\n        else if (this.props.graphMode === GraphMode.ADD_EDGE) {\n            if (this.props.selectedVertex !== undefined) {\n                this.props.unselectVertex();\n            }\n        }\n    };\n\n    handleVertexClick = (e, vertex) => {\n        if (this.props.graphMode === GraphMode.REMOVE_VERTEX_OR_EDGE) {\n            e.cancelBubble = true;\n            this.props.removeVertex(vertex);\n        } else if (this.props.graphMode === GraphMode.ADD_EDGE) {\n            e.cancelBubble = true;\n\n            if (this.props.selectedVertex === undefined) {\n                this.props.selectVertex(vertex);\n            }\n            else {\n                this.props.startDialogForResult(\n                    \"Введите вес ребра\",\n                    `(${this.props.selectedVertex.name} ${this.props.graph.isOriented() ? '->' : '<->'} ${vertex.name})`,\n                    \"Оставьте поле пустым, чтобы добавить невзвешенное ребро\",\n                    \"Вес ребра\",\n                    (value) => {\n                        if (value === \"\")\n                            value = undefined;\n                        else\n                            value = Number(value);\n                        this.props.addEdge(this.props.selectedVertex, vertex, value);\n                        this.props.unselectVertex();\n                    },\n                    null,\n                    \"[0-9]{0,2}\"\n                );\n            }\n        } else if (this.props.graphMode === GraphMode.ALGORITHM_PRE_CALL_SELECT_VERTEX) {\n            e.cancelBubble = true;\n\n            this.props.callAlgorithm(vertex, null);\n        }\n    };\n\n    handleEdgeClick = (e, edge) => {\n        if (this.props.graphMode === GraphMode.REMOVE_VERTEX_OR_EDGE) {\n            e.cancelBubble = true;\n            this.props.removeEdge(edge);\n        } else if (this.props.graphMode === GraphMode.ALGORITHM_PRE_CALL_SELECT_EDGE) {\n            e.cancelBubble = true;\n            this.props.callAlgorithm(null, edge);\n        }\n    };\n\n    handleCanvasDragEnd = (e) => {\n        this.props.moveCanvas(e.target.x(), e.target.y());\n    };\n\n    render() {\n        return (\n            <Stage\n                x={this.props.canvasX}\n                y={this.props.canvasY}\n                draggable={this.props.graphMode === GraphMode.DEFAULT}\n                onDragEnd={this.handleCanvasDragEnd}\n                onClick={this.handleCanvasClick}\n                width={this.state.windowWidth}\n                height={this.state.windowHeight}>\n                <Layer>\n                    <Rect fill={'white'} x={0} y={0} width={this.state.windowWidth} height={this.state.windowHeight}/>\n                    {\n                        this.props.graph.edges.map((edge, index) =>\n                            <EdgeComponent\n                                key={index}\n                                vertexFrom={edge.from}\n                                vertexTo={edge.to}\n                                edge={edge}\n                                edgeType={this.getEdgeType(edge)}\n                                onClick={(e) => this.handleEdgeClick(e, edge)}/>\n                        )\n                    }\n                    {\n                        this.props.graph.visualizationEdges.map((edge, index) =>\n                            <VisualizationEdgeComponent\n                                key={index}\n                                vertexFrom={edge.from}\n                                vertexTo={edge.to}\n                                edge={edge}\n                                edgeType={this.getEdgeType(edge)}/>\n                        )\n                    }\n                    {\n                        this.props.graph.vertices.map((vertex, index) =>\n                            <VertexComponent\n                                key={index}\n                                vertex={vertex}\n                                draggable={this.props.graphMode === GraphMode.DEFAULT}\n                                onClick={(e) => this.handleVertexClick(e, vertex)}\n                                onDragStart={e => this.handleVertexDragStart(e, vertex)}\n                                onDragEnd={e => this.handleVertexDragEnd(e, vertex)}\n                                onDragMove={e => this.handleVertexDragMove(e, vertex)}/>\n                        )\n                    }\n                </Layer>\n            </Stage>\n        );\n    }\n}\n\n\nconst mapDispatchToProps = dispatch => ({\n    addVertex: (x, y, radius) => dispatch(addVertex(x, y, radius)),\n    addEdge: (vertexFrom, vertexTo, weight) => dispatch(addEdge(vertexFrom, vertexTo, weight)),\n    removeVertex: (vertex) => dispatch(removeVertex(vertex)),\n    removeEdge: (edge) => dispatch(removeEdge(edge)),\n    updateVertexPosition: (vertexIndex, x, y) => dispatch(updateVertexPosition(vertexIndex, x, y)),\n    selectVertex: (vertex) => dispatch(selectVertex(vertex)),\n    unselectVertex: (vertex) => dispatch(unselectVertex(vertex)),\n    startDialogForResult: (title, text, hint, inputPlaceholder, onSubmit, onClose, pattern) =>\n        dispatch(startDialogForResult(title, text, hint, inputPlaceholder, onSubmit, onClose, pattern)),\n    callAlgorithm: (vertex, edge) => dispatch(call(vertex, edge)),\n    moveCanvas: (x, y) => dispatch(moveCanvas(x, y))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(GraphComponent);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./Buttons.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const ButtonComponent = ({ text, type = \"button\", onClick, activated, className, hotKeyHint }) => {\n    return (\n        <button type={type} className={cx(\"button\", className, {[`activated`]: activated})} onClick={onClick}>\n            {text}{hotKeyHint ? <span className={cx(\"hint\")}> ({hotKeyHint})</span> : \"\"}\n        </button>\n    );\n};","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./Sliders.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const SliderComponent = ({ label, value, min, max, onChange }) => {\n    return (\n        <div className={cx(\"slider-wrapper\")}>\n            <div className={cx(\"slider-label\")}>{label}</div>\n            <input\n                type={\"range\"}\n                className={cx(\"slider\")}\n                value={value}\n                min={min}\n                max={max}\n                onChange={onChange}/>\n        </div>\n    );\n};","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./DropDownLists.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const DropDownList = ({ items, onChange }) => {\n    return (\n        <select className={cx(\"drop-down-list\")} onChange={onChange}>\n            {items.map((item, index) => <option key={index} value={index}>{item}</option>)}\n        </select>\n    );\n};","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./ToggleSwitches.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const RoundedToggleSwitch = ({ text, onChange, className, isChecked }) => {\n    return (\n        <div className={cx(\"switch-round-wrapper\", className)}>\n            <label className={cx(\"switch-round\")}>\n                <input type={\"checkbox\"} onChange={onChange} checked={isChecked}/>\n                <span className={cx(\"slider\")}/>\n            </label>\n            <span className={cx(\"text\")}>{text}</span>\n        </div>\n    );\n};","export function sizeof(object) {\n    let objectList = [],\n        stack = [object],\n        bytes = 0,\n        value,\n        i;\n\n    while (stack.length) {\n        value = stack.pop();\n\n        if (typeof value === 'boolean') {\n            bytes += 4;\n        } else if (typeof value === 'string') {\n            bytes += value.length * 2;\n        } else if (typeof value === 'number') {\n            bytes += 8;\n        } else if (typeof value === 'object'\n            && objectList.indexOf(value) === -1) {\n            objectList.push(value);\n\n            for (i in value) {\n                if (value.hasOwnProperty(i)) {\n                    stack.push(value[i]);\n                }\n            }\n        }\n    }\n    return bytes;\n}","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet used = {};\nlet trace = [];\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList) => {\n    used[vertex] = true;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to = 0;\n    adjacencyList[vertex].forEach(toVertex => {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            dfs(to, adjacencyList);\n            trace.push({ from: to, to: vertex, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    });\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    memoryUsed += sizeof(to);\n};\n\nexport default {\n    name: \"Поиск в глубину\",\n\n    preCall: PreCallAction.SELECT_VERTEX,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges, start) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        dfs(start.name, adjacencyList);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dfs(v):\n      отметить v как посещённую\n\n      для всех рёбер (v, u):\n          если u не посещена:\n              dfs(u)\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Красные рёбра - рёбра дерева обхода</li>\n                </ul>\n            ]\n        };\n    }\n};","export class Queue {\n    constructor() {\n        this._queue = [];\n    }\n\n    get length() {\n        return this._queue.length;\n    }\n\n    isEmpty() {\n        return this._queue.length === 0;\n    }\n\n    push(value) {\n        this._queue.push(value);\n    }\n\n    pop() {\n        // TODO: O(N) -> O(1)\n        return this._queue.shift();\n    }\n\n    peek() {\n        return this._queue[0];\n    }\n}","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, adjacencyList, used, trace) => {\n    used[start] = true;\n    const queue = new Queue();\n    queue.push(start);\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let vertex = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.pop();\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                used[to] = true;\n                queue.push(to);\n                trace.push({ vertex: to, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        });\n        trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(queue) + sizeof(vertex) + sizeof(to);\n};\n\nexport default {\n    name: \"Поиск в ширину\",\n\n    preCall: PreCallAction.SELECT_VERTEX,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges, start) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        bfs(start.name, adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function bfs(start):\n      добавить вершину start в очередь\n\n      пока очередь не пуста:\n          достать вершину v из очереди\n          для всех рёбер (v, u):\n              если вершина u не обработана и не в очереди:\n                  добавить u в очередь\n          отметить v как обработанную\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - добавленные в очередь</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Жёлтая вершина - обрабатываемая</li>\n                    <li>Красные рёбра - рёбра дерева обхода</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst dijkstra = (start, vertices, adjacencyList, used, trace) => {\n    const d = {};\n    const p = {};\n    vertices.forEach(v => {\n        if (v === start)\n            return;\n        d[v] = Number.MAX_SAFE_INTEGER;\n        p[v] = null;\n        trace.push({ vertex: v, hint: \"∞\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n    });\n    d[start] = 0;\n    trace.push({ vertex: start, hint: \"0\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    for (let i in vertices) {\n        let v = -1;\n\n        memoryUsed += sizeof(v);\n\n        vertices.forEach(j => {\n            if (!used[j] && ((v === -1) || (d[j] < d[v])))\n                v = j;\n        });\n        if (d[v] === Number.MAX_SAFE_INTEGER)\n            break;\n\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n        for (let {name: to, weight} of adjacencyList[v]) {\n            if (used[to])\n                continue;\n            weight = Number(weight);\n\n            trace.push({ from: v, to, oriented: true, weight, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (d[v] + weight < d[to]) {\n                if (p[to] !== null) {\n                    trace.push({ from: p[to], to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n                }\n                d[to] = d[v] + weight;\n                p[to] = v;\n                trace.push({ from: v, to, oriented: true, weight, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                trace.push({ vertex: to, hint: d[to], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else {\n                trace.push({ from: v, to, oriented: true, weight, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(d);\n};\n\nexport default {\n    name: \"Поиск кратчайшего пути (Алгоритм Дейкстры)\",\n\n    preCall: PreCallAction.SELECT_VERTEX,\n\n    criteria: Criteria.WEIGHTED,\n\n    call: (vertices, edges, start) => {\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        dijkstra(start.name, vertices.map(v => v.name), adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V|^2 + |E|)\n                    </li>\n                    <li>\n                        Список смежности + двоичная куча: O((|V| + |E|) * log|V|)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dijkstra(start):\n      d[v] - кратчайшее расстояние от start до v\n\n      для всех вершин v кроме start:\n          d[v] = ∞\n      d[start] = 0\n\n      пока d[start] != ∞ и start != -1:\n          для всех рёбер (start, u):\n              d[u] = min(d[u], d[start] + вес ребра (start, u))\n\n          отметить start как посещённую\n\n          start = непосещённая вершина v с минимальным d[v]\n          если нет непосещённых вершин - start = -1\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Жёлтая вершина - обрабатываемая</li>\n                    <li>Красные рёбра - рёбра кратчайшего пути</li>\n                    <li>Красные числа - текущее кратчайшее расстояние</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst prim = (start, vertices, edges, adjacencyList, used, trace) => {\n    edges.forEach(e => {\n        trace.push({ from: e.from.name, to: e.to.name, oriented: false, weight: e.weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    });\n\n    const d = {};\n    const mst = {};\n    vertices.forEach(v => {\n        if (v === start)\n            return;\n        d[v] = Number.MAX_SAFE_INTEGER;\n        trace.push({ vertex: v, hint: \"∞\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n        mst[v] = null;\n    });\n    d[start] = 0;\n    trace.push({ vertex: start, hint: \"0\", action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    for (let i in vertices) {\n        let v = -1;\n\n        memoryUsed += sizeof(v);\n\n        vertices.forEach(j => {\n            if (!used[j] && ((v === -1) || (d[j] < d[v])))\n                v = j;\n        });\n        if (d[v] === Number.MAX_SAFE_INTEGER)\n            break;\n\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n        for (let {name: to, weight} of adjacencyList[v]) {\n            if (used[to])\n                continue;\n            weight = Number(weight);\n\n            trace.push({ from: v, to, oriented: false, weight, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (weight < d[to]) {\n                if (mst[to] !== null) {\n                    trace.push({ from: mst[to], to, oriented: false, weight: d[to], action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION, isChained: false });\n                }\n                d[to] = weight;\n                mst[to] = v;\n                trace.push({ from: v, to, oriented: false, weight, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                trace.push({ vertex: to, hint: d[to], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else {\n                trace.push({ from: v, to, oriented: false, weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    let mstWeight = 0;\n    for (const v in d)\n        mstWeight += d[v];\n\n    memoryUsed += sizeof(d) + sizeof(mst);\n\n    return mstWeight;\n};\n\nexport default {\n    name: \"Поиск минимального каркаса (Алгоритм Прима)\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.CONNECTED | Criteria.WEIGHTED | Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const start = vertices[Math.floor(Math.random() * vertices.length)];\n        const mstWeight = prim(start.name, vertices.map(v => v.name), edges, adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList) +\n            sizeof(start) +\n            sizeof(mstWeight);\n\n        return {\n            trace,\n            statistics: [\n                `Вес минимального каркаса: ${mstWeight}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V|^2 + |E|)\n                    </li>\n                    <li>\n                        Список смежности + двоичная куча: O((|V| + |E|) * log|V|)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function mst():\n      выбрать случайную вершину start\n\n      d[v] - вес ребра, по которому пришли в вершину v\n      для всех вершин v кроме start:\n          d[v] = ∞\n      d[start] = 0\n\n      пока есть непосещённые вершины:\n          для всех рёбер (start, u):\n              если u не посещена и вес ребра (start, u) < d[u]:\n                  если d[u] != ∞:\n                      исключить ребро, соединённое с u из MST\n                  добавить ребро (start, u) в MST\n                  d[u] = вес (start, u)\n\n          отметить start как посещённую\n\n          start = непосещённая вершина v с минимальным d[v]\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не добавленные в каркас</li>\n                    <li>Жёлтые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - добавленные в каркас</li>\n                    <li>Жёлтые рёбра - просматриваемые</li>\n                    <li>Красные рёбра - рёбра каркаса</li>\n                    <li>Числа - значения d[v] для вершины (см. псевдокод)</li>\n                </ul>\n            ]\n        };\n    }\n};","export class DSU {\n    constructor() {\n        this.parent = {};\n        this.size = {};\n    }\n\n    makeSet(x) {\n        this.parent[x] = x;\n        this.size[x] = 1;\n    }\n\n    find(x) {\n        if (x === this.parent[x])\n            return x;\n        this.parent[x] = this.find(this.parent[x]);\n        return this.parent[x];\n    }\n\n    union(x, y) {\n        x = this.find(x);\n        y = this.find(y);\n        if (x !== y)\n            if (this.size[x] < this.size[y])\n                [x, y] = [y, x];\n            this.parent[y] = x;\n            this.size[x] += this.size[y];\n    }\n}","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction } from \"./index\";\nimport { DSU } from \"../../utils/dsu\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst kruskal = (vertices, edges, trace) => {\n    const dsu = new DSU();\n    vertices.forEach(v => dsu.makeSet(v.name));\n    edges.sort((a, b) => a.weight - b.weight);\n\n    edges.forEach(e => {\n        trace.push({ from: e.from.name, to: e.to.name, oriented: false, weight: e.weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    });\n\n    let mstWeight = 0;\n    let from = 0, to = 0, weight = 0;\n    edges.forEach(e => {\n        from = e.from.name;\n        to = e.to.name;\n        weight = Number(e.weight);\n        trace.push({ from, to, oriented: false, weight, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n        if (dsu.find(from) !== dsu.find(to)) {\n            mstWeight += weight;\n            dsu.union(from, to);\n            trace.push({ from, to, oriented: false, weight, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n        } else {\n            trace.push({ from, to, oriented: false, weight, action: EdgeAction.SHADOW, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    });\n\n    memoryUsed +=\n        sizeof(dsu) +\n        sizeof(mstWeight) +\n        sizeof(from) +\n        sizeof(to) +\n        sizeof(weight);\n\n    return mstWeight;\n};\n\nexport default {\n    name: \"Поиск минимального каркаса (Алгоритм Краскала)\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.CONNECTED | Criteria.WEIGHTED | Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const mstWeight = kruskal(vertices, edges, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        return {\n            trace,\n            statistics: [\n                `Вес минимального каркаса: ${mstWeight}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список рёбер + СНМ: O(|E| * log|E|)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function mst():\n      отсортировать рёбра по возрастанию их веса\n\n      для каждого ребра E из списка:\n          если добавление ребра E в MST не образует цикл:\n              добавить E в MST\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Жёлтые рёбра - просматриваемые</li>\n                    <li>Красные рёбра - рёбра каркаса</li>\n                </ul>\n            ]\n        };\n    }\n};","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, vertices, adjacencyList, used, trace) => {\n    used[start] = true;\n    const queue = new Queue();\n    queue.push(start);\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let vertex = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.pop();\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                trace.push({ from: vertex, to: to, oriented: false, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n                used[to] = true;\n                queue.push(to);\n                trace.push({ vertex: to, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        });\n        trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n\n    memoryUsed += sizeof(queue) + sizeof(vertex) + sizeof(to);\n    for (const vertex of vertices) {\n        if (!used[vertex.name])\n            return false;\n    }\n    return true;\n};\n\nexport default {\n    name: \"Проверка на связность\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        let used = {};\n        vertices.forEach(vertex => used[vertex.name] = false);\n        let trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const start = vertices[Math.floor(Math.random() * vertices.length)];\n        const isConnected = bfs(start.name, vertices, adjacencyList, used, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(isConnected) +\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Граф ${isConnected ? \"связный\" : \"несвязный\"}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function check():\n      запустить обход в глубину/ширину от случайной вершины\n      если хотя бы одна вершина осталась непосещённой:\n          граф несвязный\n      иначе:\n          граф связный\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - добавленные в очередь</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Жёлтая вершина - обрабатываемая</li>\n                    <li>Красные рёбра - рёбра дерева обхода</li>\n                </ul>\n            ]\n        };\n    }\n};","import { AlgorithmActionType, Criteria, EdgeAction, getOperationsCount, PreCallAction, VertexAction } from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet used = {};\nlet trace = [];\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList, parent = -1, color = 1) => {\n    used[vertex] = color;\n    trace.push({ vertex, action: color === 1 ? VertexAction.COLOR_1 : VertexAction.COLOR_2, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to;\n    for (const toVertex of adjacencyList[vertex]) {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (!dfs(to, adjacencyList, vertex, 3 - color))\n                return false;\n            trace.push({ from: to, to: vertex, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n        } else if ((parent !== to) && (used[to] === color)) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            return false;\n        }\n    }\n    return true;\n};\n\nexport default {\n    name: \"Проверка на двудольность\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        used = {};\n        vertices.forEach(vertex => used[vertex.name] = 0);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        let isBipartite = true;\n        for (const {name: vertex} of vertices) {\n            if (!used[vertex]) {\n                isBipartite &= dfs(vertex, adjacencyList);\n                if (!isBipartite)\n                    break;\n            }\n        }\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(isBipartite) +\n            sizeof(used) +\n            sizeof(adjacencyList);\n\n        return {\n            trace,\n            statistics: [\n                `Граф ${isBipartite ? \"двудольный\" : \"недвудольный\"}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dfs(v, color):\n      покрасить v в цвет color\n\n      для всех рёбер (v, u):\n          если u не посещена:\n              dfs(u, цвет обратный color)\n          иначе:\n              если цвет u равен color:\n                  граф недвудольный\n\n  для всех непокрашенных вершин v:\n      dfs(v, случайный цвет)\n\n  если удалось покрасить все вершины:\n      граф двудольный\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Красные и синие вершины - обработанные</li>\n                    <li>Красные рёбра - рёбра дерева обхода</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, vertices, adjacencyList, used, trace) => {\n    const d = {}, p = {};\n    vertices.forEach(vertex => {\n        d[vertex.name] = Number.MAX_SAFE_INTEGER;\n        p[vertex.name] = -1;\n    });\n    used[start] = true;\n    const queue = new Queue();\n    queue.push({ vertex: start, level: 0 });\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    let vertex = 0, level = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.peek().vertex;\n        level = queue.pop().level;\n        d[vertex] = level;\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                used[to] = true;\n                queue.push({ vertex: to, level: level + 1 });\n                p[to] = vertex;\n            }\n        });\n    }\n\n    while (p[vertex] !== -1) {\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ from: p[vertex], to: vertex, oriented: false, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        vertex = p[vertex];\n    }\n    trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex: start, hint: level, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    memoryUsed +=\n        sizeof(d) +\n        sizeof(p) +\n        sizeof(queue) +\n        sizeof(vertex) +\n        sizeof(level) +\n        sizeof(to);\n\n    return level;\n};\n\nconst findRadius = (vertices, edges, adjacencyList, trace) => {\n    let used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n\n    let eccentricities = {};\n    let radius = Number.MAX_SAFE_INTEGER;\n    for (const {name: start} of vertices) {\n        vertices.forEach(vertex => used[vertex.name] = false);\n        eccentricities[start] = bfs(start, vertices, adjacencyList, used, trace);\n        trace.push({ vertex: start, hint: eccentricities[start], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n\n        trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n\n        radius = Math.min(radius, eccentricities[start]);\n    }\n\n    for (const {name: v} of vertices) {\n        if (eccentricities[v] === radius)\n            trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    }\n\n    memoryUsed +=\n        sizeof(used) +\n        sizeof(eccentricities) +\n        sizeof(radius);\n\n    return radius;\n};\n\nexport default {\n    name: \"Радиус и центр графа\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED | Criteria.CONNECTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const trace = [];\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const radius = findRadius(vertices, edges, adjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(radius);\n\n        return {\n            trace,\n            statistics: [\n                `Радиус графа: ${radius}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| * (|V| + |E|))\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^3)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function radius():\n      для всех вершин v:\n          запустить обход в ширину от вершины v\n          u - максимально удалённая от v (по кол-ву рёбер) вершина\n          эксцентриситет v = расстояние от v до u\n\n      радиус - минимальный из эксцентриситетов\n      центр графа - вершины, для которых эксцентриситет равен радиусу\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Жёлтые ребра и вершины (во время работы) - путь с макс. расстоянием</li>\n                    <li>Числа - эксцентриситеты вершин</li>\n                    <li>Жёлтые вершины (в конце) - центр графа</li>\n                </ul>,\n                \"! Расстояние вычисляется по кол-ву рёбер\"\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { Queue } from \"../../utils/queue\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet memoryUsed = 0;\n\nconst bfs = (start, vertices, adjacencyList, used, trace) => {\n    const d = {}, p = {};\n    vertices.forEach(vertex => {\n        d[vertex.name] = Number.MAX_SAFE_INTEGER;\n        p[vertex.name] = -1;\n    });\n    used[start] = true;\n    const queue = new Queue();\n    queue.push({ vertex: start, level: 0 });\n    trace.push({ vertex: start, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    let vertex = 0, level = 0, to = 0;\n    while (!queue.isEmpty()) {\n        vertex = queue.peek().vertex;\n        level = queue.pop().level;\n        d[vertex] = level;\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                used[to] = true;\n                queue.push({ vertex: to, level: level + 1 });\n                p[to] = vertex;\n            }\n        });\n    }\n\n    while (p[vertex] !== -1) {\n        trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ from: p[vertex], to: vertex, oriented: false, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        vertex = p[vertex];\n    }\n    trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex: start, hint: level, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    memoryUsed +=\n        sizeof(queue) +\n        sizeof(d) +\n        sizeof(p) +\n        sizeof(vertex) +\n        sizeof(level) +\n        sizeof(to);\n\n    return level;\n};\n\nconst findDiameter = (vertices, edges, adjacencyList, trace) => {\n    let used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n\n    let eccentricities = {};\n    let diameter = 0;\n    for (const {name: start} of vertices) {\n        vertices.forEach(vertex => used[vertex.name] = false);\n        eccentricities[start] = bfs(start, vertices, adjacencyList, used, trace);\n        trace.push({ vertex: start, hint: eccentricities[start], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n\n        trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n\n        diameter = Math.max(diameter, eccentricities[start]);\n    }\n\n    for (const {name: v} of vertices) {\n        if (eccentricities[v] === diameter)\n            trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    }\n\n    memoryUsed +=\n        sizeof(used) +\n        sizeof(eccentricities) +\n        sizeof(diameter);\n\n    return diameter;\n};\n\nexport default {\n    name: \"Диаметр и периферийные вершины графа\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED | Criteria.CONNECTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const trace = [];\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        const diameter = findDiameter(vertices, edges, adjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(diameter);\n\n        return {\n            trace,\n            statistics: [\n                `Диаметр графа: ${diameter}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| * (|V| + |E|))\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^3)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function diameter():\n      для всех вершин v:\n          запустить обход в ширину от вершины v\n          u - максимально удалённая от v (по кол-ву рёбер) вершина\n          эксцентриситет v = расстояние от v до u\n\n      диаметр - максимальный из эксцентриситетов\n      периферийные вершины - вершины, для которых эксцентриситет равен диаметру\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Жёлтые ребра и вершины (во время работы) - путь с макс. расстоянием</li>\n                    <li>Числа - эксцентриситеты вершин</li>\n                    <li>Жёлтые вершины (в конце) - периферийные вершины графа</li>\n                </ul>,\n                \"! Расстояние вычисляется по кол-ву рёбер\"\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet used = {};\nlet trace = [];\nlet topSortList = [];\nlet addedVertices = 0;\nlet sortedVertices = 0;\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList) => {\n    used[vertex] = true;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to = 0;\n    adjacencyList[vertex].forEach(toVertex => {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            dfs(to, adjacencyList);\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        }\n    });\n    trace.push({ vertex, hint: addedVertices++, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    topSortList.push(vertex);\n\n    memoryUsed += sizeof(to);\n};\n\nconst topSort = (vertices, edges, adjacencyList, trace) => {\n    used = {};\n    topSortList = [];\n    vertices.forEach(vertex => used[vertex.name] = false);\n    addedVertices = 0;\n    sortedVertices = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start]) {\n            dfs(start, adjacencyList);\n        }\n    }\n\n    for (const v of topSortList.reverse()) {\n        trace.push({ vertex: v, hint: sortedVertices++, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n        trace.push({ vertex: v, action: VertexAction.UNSELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n};\n\nexport default {\n    name: \"Топологическая сортировка\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.ORIENTED | Criteria.ACYCLIC,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        topSort(vertices, edges, adjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(used) +\n            sizeof(topSortList) +\n            sizeof(addedVertices) +\n            sizeof(sortedVertices);\n\n        return {\n            trace,\n            statistics: [\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dfs(v):\n      отметить v как посещённую\n\n      для всех рёбер (v, u):\n          если u не посещена:\n              dfs(u)\n      добавить v в конец списка sorted\n\n  function topological_sort():\n      sorted[] - упорядоченные по времени выхода вершины\n\n      для всех непосещённых вершин v:\n          dfs(v)\n\n      перевернуть sorted\n\n      переименовать:\n          вершину sorted[0] на 0\n          вершину sorted[1] на 1\n          ...\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Красные рёбра - рёбра обхода</li>\n                    <li>Синие числа - время выхода</li>\n                    <li>Красные числа - новые номера вершин</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet used = {};\nlet trace = [];\nlet timer = 0;\nlet tin = {}, tout = {};\nlet countBridges = 0;\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList, parent = -1) => {\n    used[vertex] = true;\n    tin[vertex] = tout[vertex] = timer++;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n\n    for (const {name: to} of adjacencyList[vertex]) {\n        if (to === parent)\n            continue;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            dfs(to, adjacencyList, vertex);\n            tout[vertex] = Math.min(tout[vertex], tout[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if (tout[to] > tin[vertex]) {\n                ++countBridges;\n                trace.push({ from: vertex, to, oriented: false, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        } else {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            tout[vertex] = Math.min(tout[vertex], tin[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    }\n\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n};\n\nconst findBridges = (vertices, edges, adjacencyList) => {\n    used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n    timer = 0;\n    tin = {};\n    tout = {};\n    countBridges = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start])\n            dfs(start, adjacencyList);\n    }\n};\n\nexport default {\n    name: \"Поиск мостов\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        findBridges(vertices, edges, adjacencyList);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList) +\n            sizeof(timer) +\n            sizeof(tin) +\n            sizeof(tout) +\n            sizeof(countBridges);\n\n        return {\n            trace,\n            statistics: [\n                `Количество мостов: ${countBridges}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dfs(v):\n      отметить v как посещённую\n      tin[v] = fup[v] = timer\n      timer++\n\n      для всех рёбер (v, u):\n          если u не посещена:\n              dfs(u)\n              fup[v] = min(fup[v], fup[u])\n              если fup[u] > tin[v]:\n                  ребро (v, u) - мост\n          иначе:\n              fup[v] = min(fup[v], tin[u])\n\n  timer - счётчик времени\n  tin[] - время входа в вершину\n  fup[v] - min(tin[v], fup[u], tin[p]), \n           где ребро (v, u) - прямое, (v, p) - обратное\n\n  для всех непосещённых вершин v:\n      dfs(v)\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Красные рёбра - рёбра обхода</li>\n                    <li>Жёлтые ребра - мосты</li>\n                    <li>Красные числа - пары tin и fup (см. псевдокод)</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet used = {};\nlet trace = [];\nlet timer = 0;\nlet tin = {}, tout = {};\nlet countArticulationPoints = 0;\nlet isArticulationPoint = {};\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList, parent = -1) => {\n    used[vertex] = true;\n    tin[vertex] = tout[vertex] = timer++;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n    trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n    let children = 0;\n\n    for (const {name: to} of adjacencyList[vertex]) {\n        if (to === parent)\n            continue;\n        if (!used[to]) {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            dfs(to, adjacencyList, vertex);\n            tout[vertex] = Math.min(tout[vertex], tout[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n            if ((tout[to] >= tin[vertex]) && (parent !== -1) && !isArticulationPoint[vertex]) {\n                ++countArticulationPoints;\n                isArticulationPoint[vertex] = true;\n                trace.push({ vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n            ++children;\n        } else {\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            tout[vertex] = Math.min(tout[vertex], tin[to]);\n            trace.push({ vertex, hint: tin[vertex] + \" \" + tout[vertex], action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n            trace.push({ from: vertex, to: to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION });\n        }\n    }\n\n    if (!isArticulationPoint[vertex]) {\n        trace.push({vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION});\n\n        if ((parent === -1) && (children > 1)) {\n            ++countArticulationPoints;\n            trace.push({vertex, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION});\n        }\n    }\n\n    memoryUsed += sizeof(children);\n};\n\nconst findArticulationPoints = (vertices, edges, adjacencyList) => {\n    used = {};\n    vertices.forEach(vertex => {\n        used[vertex.name] = false;\n        isArticulationPoint[vertex.name] = false;\n    });\n    timer = 0;\n    tin = {};\n    tout = {};\n    countArticulationPoints = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start])\n            dfs(start, adjacencyList);\n    }\n};\n\nexport default {\n    name: \"Поиск точек сочленения\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOT_ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        findArticulationPoints(vertices, edges, adjacencyList);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(used) +\n            sizeof(adjacencyList) +\n            sizeof(timer) +\n            sizeof(tin) +\n            sizeof(tout) +\n            sizeof(countArticulationPoints) +\n            sizeof(isArticulationPoint);\n\n        return {\n            trace,\n            statistics: [\n                `Количество точек сочленения: ${countArticulationPoints}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dfs(v, parent):\n      отметить v как посещённую\n      tin[v] = fup[v] = timer\n      timer++\n      children = 0\n\n      для всех рёбер (v, u):\n          если u не посещена:\n              children++\n              dfs(u)\n              fup[v] = min(fup[v], fup[u])\n              если fup[u] >= tin[v] и parent != -1:\n                  v - точка сочленения\n          иначе:\n              fup[v] = min(fup[v], tin[u])\n      если parent == -1 и children > 1:\n          v - точка сочленения\n\n  timer - счётчик времени\n  tin[] - время входа в вершину\n  fup[v] - min(tin[v], fup[u], tin[p]), \n           где ребро (v, u) - прямое, (v, p) - обратное\n\n  для всех непосещённых вершин v:\n      dfs(v, -1)\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Жёлтые вершины - точки сочленения</li>\n                    <li>Красные рёбра - рёбра обхода</li>\n                    <li>Красные числа - пары tin и fup (см. псевдокод)</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList, edgesListToReversedAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet used = {};\nlet trace = [];\nlet topSortList = [];\nlet addedVertices = 0;\nlet sortedVertices = 0;\nlet memoryUsed = 0;\n\nconst dfs = (vertex, adjacencyList) => {\n    used[vertex] = true;\n    trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n    let to = 0;\n    adjacencyList[vertex].forEach(toVertex => {\n        to = toVertex.name;\n        if (!used[to]) {\n            trace.push({ from: vertex, to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            dfs(to, adjacencyList);\n            trace.push({ from: vertex, to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n        }\n    });\n    trace.push({ vertex, hint: addedVertices++, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n    trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    topSortList.push(vertex);\n\n    memoryUsed += sizeof(to);\n};\n\nconst topSort = (vertices, edges, adjacencyList, trace) => {\n    used = {};\n    topSortList = [];\n    vertices.forEach(vertex => used[vertex.name] = false);\n    addedVertices = 0;\n    sortedVertices = 0;\n\n    for (const {name: start} of vertices) {\n        if (!used[start]) {\n            dfs(start, adjacencyList);\n        }\n    }\n\n    for (const v of topSortList.reverse()) {\n        trace.push({ vertex: v, hint: sortedVertices++, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION, isChained: true });\n        trace.push({ vertex: v, action: VertexAction.UNSELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    }\n};\n\nconst findComponents = (vertices, edges, adjacencyList, trace) => {\n    for (const {from, to} of edges) {\n        trace.push({ from: from.name, to: to.name, oriented: true, action: EdgeAction.FLIP, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    }\n    if (edges.length > 0)\n        trace[trace.length - 1].isChained = false;\n\n    vertices.forEach(vertex => used[vertex.name] = false);\n\n    let componentsNumber = 0;\n\n    const dfsComponents = (vertex) => {\n        used[vertex] = true;\n        trace.push({ vertex, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n        trace.push({ vertex, hint: componentsNumber, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION});\n\n        let to = 0;\n        adjacencyList[vertex].forEach(toVertex => {\n            to = toVertex.name;\n            if (!used[to]) {\n                trace.push({ from: vertex, to, oriented: true, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                dfsComponents(to);\n                trace.push({ from: vertex, to, oriented: true, action: EdgeAction.UNSELECT, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            }\n        });\n\n        trace.push({ vertex, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n        memoryUsed += sizeof(to);\n    };\n\n    for (const v of topSortList) {\n        if (!used[v]) {\n            dfsComponents(v);\n            ++componentsNumber;\n        }\n    }\n\n    for (const {from, to} of edges) {\n        trace.push({ from: from.name, to: to.name, oriented: true, action: EdgeAction.FLIP, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n    }\n\n    memoryUsed += sizeof(componentsNumber);\n\n    return componentsNumber;\n};\n\nexport default {\n    name: \"Поиск компонент сильной связности (Алгоритм Косарайю)\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.ORIENTED,\n\n    call: (vertices, edges) => {\n        if (vertices.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n        const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        topSort(vertices, edges, adjacencyList, trace);\n        const componentsNumber = findComponents(vertices, edges, reversedAdjacencyList, trace);\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(reversedAdjacencyList) +\n            sizeof(componentsNumber) +\n            sizeof(used) +\n            sizeof(topSortList) +\n            sizeof(addedVertices) +\n            sizeof(sortedVertices);\n\n        return {\n            trace,\n            statistics: [\n                `Количество компонент сильной связности: ${componentsNumber}`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|)\n                    </li>\n                    <li>\n                        Матрица смежности: O(|V|^2)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function dfs(v, component_number):\n      отметить v как посещённую\n      добавить v в КСС под номером component_number\n\n      для всех рёбер (v, u):\n          если u не посещена:\n              dfs(u, component_number)\n\n  function scc():\n      провести топологическую сортировку\n      перевернуть все рёбра\n\n      components = 0\n      для всех вершин v в порядке топологической сортировки:\n          если v не посещена:\n              dfs(v, components)\n              components++\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Красные рёбра - рёбра обхода</li>\n                    <li>Синие числа (при обходе) - время выхода</li>\n                    <li>Синие числа (после обхода) - новые номера вершин (тополог. отсорт.)</li>\n                    <li>Красные числа - номер КСС</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList, edgesListToReversedAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet trace = [];\nlet memoryUsed = 0;\n\nconst checkForEuler = (vertices, edges, adjacencyList, trace) => {\n    let oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    memoryUsed += sizeof(oriented) + sizeof(reversedAdjacencyList);\n\n    if (!oriented) {\n\n        // Delete loops to prevent odd degrees\n        for (const {name: v} of vertices) {\n            adjacencyList[v] = adjacencyList[v].filter(toVertex => toVertex.name !== v);\n        }\n\n        let oddVertices = 0;\n        memoryUsed += sizeof(oddVertices);\n\n        for (const {name: v} of vertices) {\n            if (adjacencyList[v].length % 2 === 1) {\n                ++oddVertices;\n                if (oddVertices > 2) {\n                    trace.push({ vertex: v, hint: 1, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                    return false;\n                } else\n                    trace.push({ vertex: v, hint: 1, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    } else {\n        let outOddVertices = 0;\n        let inOddVertices = 0;\n        let degree = 0;\n        memoryUsed += sizeof(outOddVertices) + sizeof(inOddVertices) + sizeof(degree);\n\n        for (const {name: v} of vertices) {\n            degree = reversedAdjacencyList[v].length - adjacencyList[v].length;\n            if (degree === 1) {\n                ++outOddVertices;\n                if (outOddVertices > 1) {\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                    return false;\n                } else\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else if (degree === -1) {\n                ++inOddVertices;\n                if (outOddVertices > 1) {\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                    return false;\n                } else\n                    trace.push({ vertex: v, hint: degree, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            } else if (degree !== 0) {\n                trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    }\n\n    const used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n    const dfs = (v) => {\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n        for (const {name: to} of adjacencyList[v]) {\n            if (!used[to]) {\n                trace.push({ from: v, to, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                dfs(to);\n            }\n        }\n        if (oriented) {\n            for (const {name: from} of reversedAdjacencyList[v]) {\n                if (!used[from]) {\n                    trace.push({ from, to: v, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                    dfs(from);\n                }\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    };\n\n    dfs(vertices[0].name);\n    memoryUsed += sizeof(used);\n\n    for (const {name: v} of vertices) {\n        if (!used[v]) {\n            if (adjacencyList[v].length > 0) {\n                trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: v, to: adjacencyList[v][0].name, oriented, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        }\n    }\n\n    return true;\n};\n\nconst findEulerPath = (vertices, edges, adjacencyList, trace) => {\n    const oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    let start = vertices[0].name;\n    for (const {name: v} of vertices) {\n        if (!oriented) {\n            if (adjacencyList[v].length % 2 === 1) {\n                start = v;\n                break;\n            }\n        } else {\n            if (reversedAdjacencyList[v].length - adjacencyList[v].length === 1) {\n                start = v;\n                break;\n            }\n        }\n    }\n    trace.push({ vertex: start, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    if (oriented)\n        adjacencyList = reversedAdjacencyList;\n\n    const currentVertices = [];\n    let pathLen = 0;\n    currentVertices.push(start);\n    let cur;\n    while (currentVertices.length > 0) {\n        cur = currentVertices[currentVertices.length - 1];\n        if (adjacencyList[cur].length > 0) {\n            currentVertices.push(adjacencyList[cur][0].name);\n            const to = adjacencyList[cur].shift().name;\n            if (!oriented) {\n                adjacencyList[to] = adjacencyList[to].filter(e => e.name !== cur);\n            }\n            trace.push({ from: cur, to, oriented: true, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n\n            memoryUsed += sizeof(to);\n        } else {\n            currentVertices.pop();\n            if (currentVertices.length > 0) {\n                if (pathLen === 0)\n                    trace.push({ vertex: cur, action: VertexAction.COLOR_1, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: cur, to: currentVertices[currentVertices.length - 1], oriented: true, weight: ++pathLen, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n    }\n\n    memoryUsed +=\n        sizeof(oriented) +\n        sizeof(reversedAdjacencyList) +\n        sizeof(start) +\n        sizeof(currentVertices) +\n        sizeof(pathLen) +\n        sizeof(cur);\n};\n\nexport default {\n    name: \"Эйлеров путь\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges) => {\n        if (edges.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        let isEuler = checkForEuler(vertices, edges, Object.assign({}, adjacencyList), trace);\n        if (isEuler) {\n            trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n            trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            findEulerPath(vertices, edges, adjacencyList, trace);\n        }\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(isEuler);\n\n        return {\n            trace,\n            statistics: [\n                `Эйлеров путь ${isEuler ? '' : 'не'} существует`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|) + проверка: O(|V|)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function find_euler_path():\n      эйлеров путь существует, если:\n          для неориентированного графа:\n              степени всех вершин чётны, кроме, может быть, двух\n              из всех компонент связности только в одной есть рёбра\n          для ориентированного графа: \n              полустепень входа каждой вершины равна полустепени исхода, кроме,\n                может быть, двух, для одной из которых:\n                  полустепень_входа - полустепень_исхода = 1,\n                а для другой:\n                  полустепень_входа - полустепень_исхода = -1\n              из всех компонент слабой связности только в одной есть рёбра\n\n      если граф неориентированный:\n          выбрать вершину v с нечётной степенью,\n          либо любую, если таких нет\n      иначе:\n          выбрать вершину v, для которой\n            полустепень_входа - полустепень_исхода = 1,\n          либо любую, если таких нет\n\n      v - конечная вершина пути\n\n      добавить v в стек S\n      пока стек не пуст:\n          w = S.top()\n          если существует ребро (u, w) входящее в w:\n              S.push(u)\n              удалить ребро (u, w) из рассмотрения\n          иначе:\n              S.pop()\n              w - следующая вершина в эйлеровом цикле\n              добавить ребро (w, S.top()) в эйлеров цикл, если стек не пуст\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Красные рёбра (при обходе) - рёбра обхода</li>\n                    <li>Синие числа (для неор.графа) - 0 - вершина с чётной степенью, 1 - с нечётной</li>\n                    <li>Синие числа (для ор.графа) - степень_входа - степень_выхода</li>\n                    <li>&nbsp;</li>\n                    <li>Жёлтая вершина - начальная (для обхода)</li>\n                    <li>Красная вершина - начальная (для эйлерова пути)</li>\n                    <li>Жёлтые ребра - рёбра обхода (при поиске пути)</li>\n                    <li>Красные ребра - рёбра эйлерова пути</li>\n                </ul>\n            ]\n        };\n    }\n};","import {\n    AlgorithmActionType,\n    Criteria,\n    EdgeAction,\n    getOperationsCount,\n    PreCallAction,\n    VertexAction,\n    VertexHintAction\n} from \"./index\";\nimport { edgesListToAdjacencyList, edgesListToReversedAdjacencyList } from \"../../utils/graphConverter\";\nimport { sizeof } from \"../../utils/sizeof\";\nimport React from \"react\";\n\nlet trace = [];\nlet memoryUsed = 0;\n\nconst checkForEuler = (vertices, edges, adjacencyList, trace) => {\n    let oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    memoryUsed += sizeof(oriented) + sizeof(reversedAdjacencyList);\n\n    if (!oriented) {\n\n        // Delete loops to prevent odd degrees\n        for (const {name: v} of vertices) {\n            adjacencyList[v] = adjacencyList[v].filter(toVertex => toVertex.name !== v);\n        }\n\n        for (const {name: v} of vertices) {\n            if (adjacencyList[v].length % 2 === 1) {\n                trace.push({ vertex: v, hint: 1, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    } else {\n        let degree = 0;\n        memoryUsed += sizeof(degree);\n\n        for (const {name: v} of vertices) {\n            degree = reversedAdjacencyList[v].length - adjacencyList[v].length;\n            if (degree !== 0) {\n                trace.push({ vertex: v, hint: degree, action: VertexHintAction.SET, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, hint: 0, action: VertexHintAction.HIGHLIGHT, actionType: AlgorithmActionType.VERTEX_HINT_ACTION });\n            }\n        }\n    }\n\n    const used = {};\n    vertices.forEach(vertex => used[vertex.name] = false);\n    const dfs = (v) => {\n        used[v] = true;\n        trace.push({ vertex: v, action: VertexAction.ENTER, actionType: AlgorithmActionType.VERTEX_ACTION });\n        for (const {name: to} of adjacencyList[v]) {\n            if (!used[to]) {\n                trace.push({ from: v, to, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                dfs(to);\n            }\n        }\n        if (oriented) {\n            for (const {name: from} of reversedAdjacencyList[v]) {\n                if (!used[from]) {\n                    trace.push({ from, to: v, oriented, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n                    dfs(from);\n                }\n            }\n        }\n        trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n    };\n\n    dfs(vertices[0].name);\n    memoryUsed += sizeof(used);\n\n    for (const {name: v} of vertices) {\n        if (!used[v]) {\n            if (adjacencyList[v].length > 0) {\n                trace.push({ vertex: v, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: v, to: adjacencyList[v][0].name, oriented, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n                return false;\n            } else {\n                trace.push({ vertex: v, action: VertexAction.EXIT, actionType: AlgorithmActionType.VERTEX_ACTION });\n            }\n        }\n    }\n\n    return true;\n};\n\nconst findEulerCycle = (vertices, edges, adjacencyList, trace) => {\n    const oriented = edges[0].isOriented();\n    const reversedAdjacencyList = edgesListToReversedAdjacencyList(vertices, edges);\n\n    let start = vertices[0].name;\n    trace.push({ vertex: start, action: VertexAction.SELECT, actionType: AlgorithmActionType.VERTEX_ACTION });\n\n    if (oriented)\n        adjacencyList = reversedAdjacencyList;\n\n    const currentVertices = [];\n    let pathLen = 0;\n    currentVertices.push(start);\n    let cur = 0;\n    while (currentVertices.length > 0) {\n        cur = currentVertices[currentVertices.length - 1];\n        if (adjacencyList[cur].length > 0) {\n            currentVertices.push(adjacencyList[cur][0].name);\n            const to = adjacencyList[cur].shift().name;\n            if (!oriented) {\n                adjacencyList[to] = adjacencyList[to].filter(e => e.name !== cur);\n            }\n            trace.push({ from: cur, to, oriented: true, action: EdgeAction.HIGHLIGHT, actionType: AlgorithmActionType.EDGE_ACTION });\n\n            memoryUsed += sizeof(to);\n        } else {\n            currentVertices.pop();\n            if (currentVertices.length > 0) {\n                if (pathLen === 0)\n                    trace.push({ vertex: cur, action: VertexAction.COLOR_1, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n                trace.push({ from: cur, to: currentVertices[currentVertices.length - 1], oriented: true, weight: ++pathLen, action: EdgeAction.WALK, actionType: AlgorithmActionType.EDGE_ACTION });\n            }\n        }\n    }\n\n    memoryUsed +=\n        sizeof(oriented) +\n        sizeof(reversedAdjacencyList) +\n        sizeof(start) +\n        sizeof(currentVertices) +\n        sizeof(pathLen) +\n        sizeof(cur);\n};\n\nexport default {\n    name: \"Эйлеров цикл\",\n\n    preCall: PreCallAction.NOTHING,\n\n    criteria: Criteria.NOTHING,\n\n    call: (vertices, edges) => {\n        if (edges.length === 0)\n            return {trace: [], statistics: []};\n\n        const adjacencyList = edgesListToAdjacencyList(vertices, edges);\n\n        trace = [];\n        memoryUsed = 0;\n\n        const startTime = window.performance.now();\n\n        let isEuler = checkForEuler(vertices, edges, Object.assign({}, adjacencyList), trace);\n        if (isEuler) {\n            trace.push({ action: VertexAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.VERTEX_ACTION, isChained: true });\n            trace.push({ action: EdgeAction.CLEAR_ALL_SELECTIONS, actionType: AlgorithmActionType.EDGE_ACTION, isChained: true });\n            findEulerCycle(vertices, edges, adjacencyList, trace);\n        }\n\n        const endTime = window.performance.now();\n        const duration = endTime - startTime;\n\n        memoryUsed +=\n            sizeof(adjacencyList) +\n            sizeof(isEuler);\n\n        return {\n            trace,\n            statistics: [\n                `Эйлеров цикл ${isEuler ? '' : 'не'} существует`,\n                `Время исполнения алгоритма: ${duration.toFixed(4)}мс`,\n                `Кол-во шагов визуализации: ${getOperationsCount(trace)}`,\n                `Память: ${memoryUsed} байт(а)`\n            ],\n            algorithmInfo: [\n                \"Временная сложность алгоритма:\",\n                <ul>\n                    <li>\n                        Список смежности: O(|V| + |E|) + проверка: O(|V|)\n                    </li>\n                </ul>,\n                \"Псевдокод:\",\n                <pre>\n                    <code>{`\n  function find_euler_cycle():\n      эйлеров цикл существует, если:\n          для неориентированного графа:\n              степени всех вершин чётны\n              из всех компонент связности только в одной есть рёбра\n          для ориентированного графа: \n              полустепень входа каждой вершины равна полустепени исхода\n              из всех компонент слабой связности только в одной есть рёбра\n\n      выбрать случайную вершину v\n\n      v - конечная и начальная вершина цикла\n\n      добавить v в стек S\n      пока стек не пуст:\n          w = S.top()\n          если существует ребро (u, w) входящее в w:\n              S.push(u)\n              удалить ребро (u, w) из рассмотрения\n          иначе:\n              S.pop()\n              w - следующая вершина в эйлеровом цикле\n              добавить ребро (w, S.top()) в эйлеров цикл, если стек не пуст\n                    `}</code>\n                </pre>,\n                \"Легенда:\",\n                <ul>\n                    <li>Белые вершины - не посещённые</li>\n                    <li>Серые вершины - обрабатываемые</li>\n                    <li>Чёрные вершины - обработанные</li>\n                    <li>Красные рёбра (при обходе) - рёбра обхода</li>\n                    <li>Синие числа (для неор.графа) - 0 - вершина с чётной степенью, 1 - с нечётной</li>\n                    <li>Синие числа (для ор.графа) - степень_входа - степень_выхода</li>\n                    <li>&nbsp;</li>\n                    <li>Жёлтая вершина - начальная (для обхода)</li>\n                    <li>Красная вершина - начальная (для эйлерова цикла)</li>\n                    <li>Жёлтые ребра - рёбра обхода (при поиске цикла)</li>\n                    <li>Красные ребра - рёбра эйлерова цикла</li>\n                </ul>\n            ]\n        };\n    }\n};","export const ActionType = Object.freeze({\n    START_MATRIX_DIALOG_FOR_RESULT: 'START_MATRIX_DIALOG_FOR_RESULT',\n    CLOSE_MATRIX_DIALOG: 'CLOSE_MATRIX_DIALOG'\n});\n\nexport const startMatrixDialogForResult = () => ({\n    type: ActionType.START_MATRIX_DIALOG_FOR_RESULT\n});\n\nconst closeMatrixDialog = () => ({\n   type: ActionType.CLOSE_MATRIX_DIALOG\n});\n\nexport const cancelMatrixDialog = (onCancel) => (dispatch) => {\n    if (onCancel)\n        onCancel();\n    dispatch(closeMatrixDialog());\n};\n\nexport const submitMatrixDialog = (onSubmit, result) => (dispatch) => {\n    if (onSubmit)\n        onSubmit(result);\n    dispatch(closeMatrixDialog());\n};","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./Menu.module.scss\";\nimport Draggable from 'react-draggable';\nimport { ButtonComponent } from \"../Buttons/Buttons\";\nimport { SliderComponent } from \"../Sliders/Sliders\";\nimport { DropDownList } from \"../DropDownLists/DropDownLists\";\nimport {\n    changeGraphMode,\n    cleanGraphSelections,\n    closeMessage,\n    invertOrientation,\n    moveCanvas,\n    setGraph,\n    showMessage\n} from \"../../actions\";\nimport { connect } from \"react-redux\";\nimport { Graph, GraphMode, vertexRadius } from \"../Graph/Graph\";\nimport { RoundedToggleSwitch } from \"../ToggleSwitches/ToggleSwitches\";\nimport {\n    call, clearAlgorithmInfo,\n    clearStatistics,\n    clearTrace,\n    continueCall,\n    pause,\n    preCall,\n    setAlgorithm,\n    setSpeed\n} from \"../../actions/algorithm\";\nimport DFS from \"../../algorithms/graph/dfs\"\nimport BFS from \"../../algorithms/graph/bfs\"\nimport Dijkstra from \"../../algorithms/graph/dijkstra\"\nimport PrimMST from \"../../algorithms/graph/prim-mst\"\nimport KruskalMST from \"../../algorithms/graph/kruskal-mst\"\nimport CheckConnected from \"../../algorithms/graph/check-connected\"\nimport CheckBipartite from \"../../algorithms/graph/check-bipartite\"\nimport FindRadius from \"../../algorithms/graph/radius\"\nimport FindDiameter from \"../../algorithms/graph/diameter\"\nimport TopologicalSort from \"../../algorithms/graph/topological-sort\"\nimport FindBridges from \"../../algorithms/graph/find-bridges\"\nimport FindArticulationPoints from \"../../algorithms/graph/find-articulation-points\"\nimport SCCKosaraju from \"../../algorithms/graph/scc-kosaraju\"\nimport EulerPath from \"../../algorithms/graph/euler-path\"\nimport EulerCycle from \"../../algorithms/graph/euler-cycle\"\nimport { Vertex } from \"../Graph/Vertex/Vertex\";\nimport { Edge } from \"../Graph/Edge/Edge\";\nimport { startMatrixDialogForResult } from \"../../actions/matrixDialog\";\n\nconst cx = classnames.bind(styles);\n\nconst minAlgorithmSpeed = 0;\nconst maxAlgorithmSpeed = 1000;\n\nconst mapStateToProps = state => ({\n    graphMode: state.graphReducer.graphMode,\n    isOriented: state.graphReducer.graph.isOriented(),\n    isVisualizationActive: state.algorithmReducer.isActive,\n    visualizationSpeed: state.algorithmReducer.speed,\n    selectedAlgorithm: state.algorithmReducer.algorithm,\n    remainingAlgorithmSteps: state.algorithmReducer.trace.length,\n    graph: state.graphReducer.graph\n});\n\nclass MenuComponent extends React.Component {\n    state = {\n        algorithms: [\n            DFS,\n            BFS,\n            Dijkstra,\n            PrimMST,\n            KruskalMST,\n            CheckConnected,\n            CheckBipartite,\n            FindRadius,\n            FindDiameter,\n            TopologicalSort,\n            FindBridges,\n            FindArticulationPoints,\n            SCCKosaraju,\n            EulerPath,\n            EulerCycle\n        ],\n        hidden: false\n    };\n\n    componentDidMount() {\n        this.props.setAlgorithm(this.state.algorithms[0]);\n        this.props.setSpeed((minAlgorithmSpeed + maxAlgorithmSpeed) / 2);\n    }\n\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n        if (nextProps.graphMode !== this.props.graphMode)\n            return true;\n        if (nextProps.isOriented !== this.props.isOriented)\n            return true;\n        if (nextProps.isVisualizationActive !== this.props.isVisualizationActive)\n            return true;\n        if (nextProps.visualizationSpeed !== this.props.visualizationSpeed)\n            return true;\n        if (nextProps.selectedAlgorithm !== this.props.selectedAlgorithm)\n            return true;\n        if (nextProps.remainingAlgorithmSteps !== this.props.remainingAlgorithmSteps)\n            return true;\n        if (nextState !== this.state)\n            return true;\n        return false;\n    }\n\n    handleAlgorithmChange = e => {\n        this.clearVisualization();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n        this.props.closeMessage();\n\n        this.props.setAlgorithm(this.state.algorithms[e.target.value]);\n    };\n\n    startVisualization = () => {\n        if (this.props.remainingAlgorithmSteps === 0) {\n            this.clearVisualization();\n            this.props.preCall();\n        } else if (this.props.isVisualizationActive) {\n            this.props.pause();\n        } else {\n            this.props.continue();\n        }\n    };\n\n    stepVisualization = () => {\n        if (this.props.remainingAlgorithmSteps === 0) {\n            this.clearVisualization();\n            this.props.preCall(true);\n        } else {\n            this.props.continue(true);\n        }\n    };\n\n    stopVisualization = () => {\n        this.clearVisualization();\n        this.props.closeMessage();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n    };\n\n    handleAlgorithmSpeedChange = e => {\n        this.props.setSpeed(maxAlgorithmSpeed - e.target.value);\n    };\n\n    askForAction = (message, graphMode) => {\n        this.clearVisualization();\n\n        this.props.showMessage(message);\n        this.props.changeGraphMode(graphMode);\n    };\n\n    closeMessage = () => {\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n        this.props.closeMessage();\n    };\n\n    invertOrientation = () => {\n        this.clearVisualization();\n\n        this.props.invertOrientation();\n    };\n\n    clearVisualization = () => {\n        this.props.pause();\n        this.props.cleanGraphSelections();\n        this.props.clearTrace();\n        this.props.clearStatistics();\n        this.props.clearAlgorithmInfo();\n    };\n\n    writeToFile = () => {\n        this.clearVisualization();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n\n        const json = JSON.stringify({\n            vertices: this.props.graph.vertices.map(v => ({\n                x: v.x,\n                y: v.y,\n                name: v.name\n            })),\n            edges: this.props.graph.edges.map(e => ({\n                from: e.from.name,\n                to: e.to.name,\n                weight: e.weight\n            })),\n            oriented: this.props.isOriented\n        });\n\n        const exportData = \"data:text/json;charset=utf-8,\" + escape(json);\n        const anchorElement = document.getElementById(\"fileSave\");\n        anchorElement.setAttribute(\"href\", exportData);\n        anchorElement.setAttribute(\"download\", \"graph.json\");\n        anchorElement.click();\n    };\n\n    askReadFromFile = () => {\n        this.clearVisualization();\n        this.props.changeGraphMode(GraphMode.DEFAULT);\n\n        document.getElementById(\"fileLoad\").click();\n    };\n\n    readFromFile = (e) => {\n        const reader = new FileReader();\n        const file = e.target.files[0];\n\n        reader.onload = (e) => {\n            try {\n                const json = JSON.parse(e.target.result);\n\n                const oriented = json.oriented;\n                const vertices = json.vertices.map(v => {\n                    if (isNaN(Number(v.name)))\n                        throw new Error(\"Name of vertex should be a number\");\n                    if (isNaN(Number(v.x)) || isNaN(Number(v.y)))\n                        throw new Error(\"Coordinates of vertex should be numbers\");\n                    return new Vertex(Number(v.x), Number(v.y), vertexRadius, Number(v.name));\n                });\n                const edges = json.edges.map(e => {\n                        return new Edge(\n                            vertices.find(v => v.name === Number(e.from)),\n                            vertices.find(v => v.name === Number(e.to)),\n                            oriented,\n                            isNaN(Number(e.weight)) ? undefined : Number(e.weight)\n                        );\n                    }\n                );\n\n                const graph = new Graph(oriented, vertices, edges);\n\n                if (oriented !== this.props.isOriented)\n                    this.invertOrientation();\n                this.props.setGraph(graph);\n                this.props.resetCanvasPosition();\n            } catch (e) {\n                this.props.showMessage(\"Некорректный формат файла\", true);\n            }\n        };\n\n        reader.readAsText(file);\n        document.getElementById(\"fileLoad\").value = null;\n    };\n\n    showAdjacencyMatrix = () => {\n        this.props.startMatrixDialog();\n    };\n\n    collapse = () => {\n        this.setState({ hidden: !this.state.hidden });\n        // FIXME: Fix unfolding in the bottom of the screen\n    };\n\n    render() {\n        return (\n            <Draggable grid={[4, 4]} bounds={\"body\"} cancel={[\"button\", \"input\", \"select\"]}>\n                <div className={cx(\"menu\", {[`menu-hidden`]: this.state.hidden})}>\n                    <div\n                        className={cx(\"collapse-button\")}\n                        onClick={() => this.collapse()}>\n                        &ndash;\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"graph-control-buttons\")}>\n                            <ButtonComponent\n                                text={\"Режим просмотра\"}\n                                onClick={() => this.closeMessage()}\n                                activated={this.props.graphMode === GraphMode.DEFAULT}\n                                hotKeyHint={\"1\"}/>\n                            <ButtonComponent\n                                text={\"Добавить вершину\"}\n                                onClick={() => this.askForAction(\"Выберите точку для добавления вершины\", GraphMode.ADD_VERTEX)}\n                                activated={this.props.graphMode === GraphMode.ADD_VERTEX}\n                                hotKeyHint={\"2\"}/>\n                            <ButtonComponent\n                                text={\"Добавить ребро\"}\n                                onClick={() => this.askForAction(\"Выберите вершины, которые нужно соединить ребром\", GraphMode.ADD_EDGE)}\n                                activated={this.props.graphMode === GraphMode.ADD_EDGE}\n                                hotKeyHint={\"3\"}/>\n                            <ButtonComponent\n                                text={\"Удалить вершину/ребро\"}\n                                onClick={() => this.askForAction(\"Выберите объект для удаления\", GraphMode.REMOVE_VERTEX_OR_EDGE)}\n                                activated={this.props.graphMode === GraphMode.REMOVE_VERTEX_OR_EDGE}\n                                hotKeyHint={\"4\"}/>\n                        </div>\n                        <RoundedToggleSwitch\n                            className={cx(\"switch\")}\n                            text={\"Ориентированный?\"}\n                            onChange={() => this.invertOrientation()}\n                            isChecked={this.props.isOriented}/>\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"algorithms-list\")}>\n                            <DropDownList\n                                items={this.state.algorithms.map(a => a.name)}\n                                onChange={this.handleAlgorithmChange}/>\n                        </div>\n                        <div className={cx(\"slider\")}>\n                            <SliderComponent\n                                label={\"Скорость анимации\"}\n                                value={maxAlgorithmSpeed - this.props.visualizationSpeed}\n                                min={minAlgorithmSpeed}\n                                max={maxAlgorithmSpeed}\n                                onChange={this.handleAlgorithmSpeedChange}/>\n                        </div>\n                        <div className={cx(\"visualization-control-buttons\")}>\n                            <ButtonComponent\n                                text={this.props.isVisualizationActive ? \"Пауза\" : \"Старт\"}\n                                onClick={this.startVisualization}/>\n                            <ButtonComponent text={\"Шаг\"} onClick={this.stepVisualization}/>\n                            <ButtonComponent text={\"Стоп\"} onClick={this.stopVisualization}/>\n                        </div>\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"file-control-buttons\")}>\n                            <ButtonComponent\n                                text={\"Сохранить\"}\n                                onClick={() => this.writeToFile()}\n                                activated={false}/>\n                            <a id=\"fileSave\" style={{\"display\": \"none\"}} aria-hidden={true} href=\"/#\">Save graph</a>\n\n                            <ButtonComponent\n                                text={\"Загрузить\"}\n                                onClick={() => this.askReadFromFile()}\n                                activated={false}/>\n                            <input id=\"fileLoad\" type=\"file\" accept=\".json\" style={{\"display\": \"none\"}} onChange={(e) => this.readFromFile(e)}/>\n                        </div>\n                    </div>\n                    <div className={cx(\"menu-sub\")}>\n                        <div className={cx(\"matrix-control-buttons\")}>\n                            <ButtonComponent\n                                text={\"Матрица смежности\"}\n                                onClick={() => this.showAdjacencyMatrix()}\n                                activated={false}/>\n                        </div>\n                    </div>\n                </div>\n            </Draggable>\n        );\n    }\n}\n\nconst mapDispatchToProps = dispatch => ({\n    changeGraphMode: (graphMode) => dispatch(changeGraphMode(graphMode)),\n    showMessage: (message, isAlert) => dispatch(showMessage(message, isAlert)),\n    closeMessage: () => dispatch(closeMessage()),\n    invertOrientation: () => dispatch(invertOrientation()),\n    setAlgorithm: (algorithm) => dispatch(setAlgorithm(algorithm)),\n    setSpeed: (speed) => dispatch(setSpeed(speed)),\n    preCall: (isOneStep) => dispatch(preCall(isOneStep)),\n    call: () => dispatch(call()),\n    pause: () => dispatch(pause()),\n    continue: (isOneStep) => dispatch(continueCall(isOneStep)),\n    cleanGraphSelections: () => dispatch(cleanGraphSelections()),\n    clearTrace: () => dispatch(clearTrace()),\n    clearStatistics: () => dispatch(clearStatistics()),\n    clearAlgorithmInfo: () => dispatch(clearAlgorithmInfo()),\n    setGraph: (graph) => dispatch(setGraph(graph)),\n    startMatrixDialog: () => dispatch(startMatrixDialogForResult()),\n    resetCanvasPosition: () => dispatch(moveCanvas(0, 0))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MenuComponent);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./MessageBox.module.scss\";\nimport { connect } from \"react-redux\";\n\nconst cx = classnames.bind(styles);\n\nconst mapStateToProps = state => ({\n    message: state.graphReducer.message,\n    isAlert: state.graphReducer.isAlert\n});\n\nconst MessageBox = ({ message, isAlert }) => {\n    return (\n        <div className={cx(\"message-box\", {[`invisible`]: message === undefined}, {[`alert`]: isAlert})}>\n            {message}\n        </div>\n    );\n};\n\nexport default connect(mapStateToProps)(MessageBox);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./TextInputs.module.scss\";\n\nconst cx = classnames.bind(styles);\n\nexport const TextInputComponent = ({ value, placeholder, onChange, pattern, className, autoFocus = false }) => {\n    return (\n        <input\n            className={cx(\"text-input\", className)}\n            type=\"text\"\n            pattern={pattern}\n            value={value}\n            onChange={onChange}\n            placeholder={placeholder}\n            autoFocus={autoFocus}/>\n    );\n};","import Modal from \"react-modal\";\nimport React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./InputDialog.module.scss\";\nimport { cancelDialog, submitDialog } from \"../../../actions/dialog\";\nimport { connect } from \"react-redux\";\nimport { ButtonComponent } from \"../../Buttons/Buttons\";\nimport { TextInputComponent } from \"../../TextInputs/TextInputs\";\n\nconst cx = classnames.bind(styles);\n\nconst customStyles = {\n    overlay: {zIndex: 100000}\n};\n\nconst mapStateToProps = state => ({\n    isOpen: state.dialogReducer.isOpen,\n    title: state.dialogReducer.title,\n    text: state.dialogReducer.text,\n    hint: state.dialogReducer.hint,\n    inputPlaceholder: state.dialogReducer.inputPlaceholder,\n    pattern: state.dialogReducer.pattern,\n    onSubmit: state.dialogReducer.onSubmit,\n    onCancel: state.dialogReducer.onCancel\n});\n\nclass InputDialog extends React.Component {\n    state = {\n        value: \"\"\n    };\n\n    handleChange = (e) => {\n        if (e.target.validity.valid)\n            this.setState({ value: e.target.value });\n    };\n\n    submit = (e) => {\n        e.preventDefault();\n        this.setState({ value: \"\" });\n        this.props.submitDialog(this.props.onSubmit, this.state.value);\n    };\n\n    cancel = () => {\n        this.setState({ value: \"\" });\n        this.props.cancelDialog(this.props.onCancel);\n    };\n\n    render() {\n        return (\n            <Modal\n                isOpen={this.props.isOpen}\n                onRequestClose={() => {\n                    this.setState({ value: \"\" });\n                    this.props.cancelDialog(this.props.onCancel);\n                }}\n                ariaHideApp={false}\n                className={cx(\"input-dialog\")}\n                style={customStyles}>\n\n                <h2>{this.props.title}</h2>\n                <div className={cx(\"text\")}>{this.props.text}</div>\n                <form onSubmit={(e) => this.submit(e)}>\n                    <TextInputComponent\n                        autoFocus={true}\n                        className={cx(\"text-input\")}\n                        placeholder={this.props.inputPlaceholder}\n                        pattern={this.props.pattern}\n                        onChange={this.handleChange}\n                        value={this.state.value}/>\n\n                    <ButtonComponent\n                        type={\"submit\"}\n                        className={cx(\"button\")}\n                        text={\"Ок\"}\n                        onClick={(e) => this.submit(e)}/>\n                    <ButtonComponent\n                        className={cx(\"button\")}\n                        text={\"Отмена\"}\n                        onClick={() => this.cancel()}/>\n                </form>\n\n                <div className={cx(\"hint\")}>{this.props.hint}</div>\n            </Modal>\n        );\n    }\n}\n\nconst mapDispatchToProps = dispatch => ({\n    submitDialog: (onSubmit, result) => dispatch(submitDialog(onSubmit, result)),\n    cancelDialog: (onCancel) => dispatch(cancelDialog(onCancel))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(InputDialog);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./InfoBox.module.scss\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\n\nconst cx = classnames.bind(styles);\n\nconst mapStateToProps = state => ({\n    lines: state.algorithmReducer.statistics,\n    isVisible: state.algorithmReducer.isStatisticsShown\n});\n\nconst InfoBox = ({ lines, isVisible }) => {\n    const writeToFile = (lines) => {\n        const exportData = \"data:text/plain;charset=UTF-8,\" + lines.map(line => line + \"\\n\").reduce((acc, cur) => acc + cur, \"\");\n        const anchorElement = document.getElementById(\"fileSave\");\n        anchorElement.setAttribute(\"href\", exportData);\n        anchorElement.setAttribute(\"download\", \"result.txt\");\n        anchorElement.click();\n    };\n\n    return (\n        <div className={cx(\"info-box\", {[`invisible`]: !(isVisible && Array.isArray(lines) && lines.length)})}>\n            {lines.map((line, index) => <div className={cx(\"text\")} key={index}>{line}</div>)}\n            <div className={cx(\"save-button\")} onClick={() => writeToFile(lines)}>Сохранить</div>\n            <a id=\"fileSave\" style={{\"display\": \"none\"}} aria-hidden={true} href=\"/#\">Save result</a>\n        </div>\n    );\n};\n\nInfoBox.propTypes = {\n    lines: PropTypes.arrayOf(PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.number,\n        PropTypes.symbol,\n        PropTypes.bool\n    ])),\n    isVisible: PropTypes.bool\n};\n\nexport default connect(mapStateToProps)(InfoBox);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./AdjacencyMatrix.module.scss\";\nimport { edgesListToAdjacencyMatrix } from \"../../../utils/graphConverter\";\n\nconst cx = classnames.bind(styles);\n\nconst MatrixCell = ({ cell, topLeft, topRight, bottomLeft, bottomRight, onClick }) => {\n    return (\n        <div className={cx(\"matrix-cell\", {[`empty`]: !cell},\n            {[`non-weighted`]: cell && !cell.weighted},\n            {[`top-left-cell`]: topLeft},\n            {[`top-right-cell`]: topRight},\n            {[`bottom-left-cell`]: bottomLeft},\n            {[`bottom-right-cell`]: bottomRight})}\n            onClick={onClick}\n            onContextMenu={onClick}>\n            {cell ? (cell.weighted ? cell.weight : \"+\") : \"X\"}\n        </div>\n    );\n};\n\nconst MatrixRow = ({ row, first, last, vertexNumber, onCellClick }) => {\n    return (\n        <div className={cx(\"matrix-row\")}>\n            <div className={cx(\"label-cell\")}>{vertexNumber}</div>\n            {row.map((cell, index) =>\n                <MatrixCell\n                    key={index}\n                    cell={cell}\n                    topLeft={(index === 0) && first}\n                    topRight={(index + 1 === row.length) && first}\n                    bottomLeft={(index === 0) && last}\n                    bottomRight={(index + 1 === row.length) && last}\n                    onClick={(e) => onCellClick(e, index)}/>)\n            }\n        </div>\n    );\n};\n\nconst AdjacencyMatrix = ({ graph, onCellClick }) => {\n    const {adjacencyMatrix, verticesNumbers} = edgesListToAdjacencyMatrix(graph.vertices, graph.edges);\n    return (\n        <div className={cx(\"matrix\")}>\n            <div className={cx(\"label-cell\")}>{\" \"}</div>\n            {verticesNumbers.map(v => <div key={v} className={cx(\"label-cell\")}>{v}</div>)}\n            {adjacencyMatrix.map((row, index) =>\n                <MatrixRow\n                    key={index}\n                    row={row}\n                    first={index === 0}\n                    last={index + 1 === graph.vertices.length}\n                    vertexNumber={verticesNumbers[index]}\n                    onCellClick={(e, column) => onCellClick(e, verticesNumbers[index], verticesNumbers[column])}/>)\n            }\n        </div>\n    );\n};\n\nexport default AdjacencyMatrix;","import Modal from \"react-modal\";\nimport React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./MatrixDialog.module.scss\";\nimport { connect } from \"react-redux\";\nimport { ButtonComponent } from \"../../Buttons/Buttons\";\nimport { edgesListToAdjacencyMatrix } from \"../../../utils/graphConverter\";\nimport { cancelMatrixDialog, submitMatrixDialog } from \"../../../actions/matrixDialog\";\nimport AdjacencyMatrix from \"./AdjacencyMatrix\";\nimport { startDialogForResult } from \"../../../actions/dialog\";\nimport { addEdge, removeEdge } from \"../../../actions\";\n\nconst cx = classnames.bind(styles);\n\nconst customStyles = {\n    overlay: {zIndex: 99999}\n};\n\nconst mapStateToProps = state => ({\n    isOpen: state.matrixDialogReducer.isOpen,\n    graph: state.graphReducer.graph\n});\n\nclass MatrixDialog extends React.Component {\n\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n        if (!this.props.isOpen && !nextProps.isOpen)\n            return false;\n        return true;\n    }\n\n    writeToFile = () => {\n        if (this.props.graph.vertices.length === 0)\n            return;\n\n        let {adjacencyMatrix} = edgesListToAdjacencyMatrix(this.props.graph.vertices, this.props.graph.edges);\n\n        adjacencyMatrix = adjacencyMatrix.map(row => row.map(cell => cell ? (cell.weighted ? cell.weight : \"+\") : \"X\"));\n        adjacencyMatrix = adjacencyMatrix.reduce((prev, arr) => prev + arr.reduce((line, cell) => line + cell + \" \", \"\") + \"\\n\", \"\");\n\n        const exportData = \"data:text/plain;charset=utf-8,\" + escape(adjacencyMatrix);\n        const anchorElement = document.getElementById(\"fileSave\");\n        anchorElement.setAttribute(\"href\", exportData);\n        anchorElement.setAttribute(\"download\", \"adjacencyMatrix.txt\");\n        anchorElement.click();\n    };\n\n    cancel = () => {\n        this.props.cancelDialog(null);\n    };\n\n    handleCellClick = (e, from, to) => {\n        const vertexFrom = this.props.graph.vertices.find(v => v.name === from);\n        const vertexTo = this.props.graph.vertices.find(v => v.name === to);\n\n        if (e.type === \"click\") {\n            if (vertexFrom && vertexTo) {\n                this.props.startDialogForResult(\n                    \"Введите вес ребра\",\n                    `(${from} ${this.props.graph.isOriented() ? '->' : '<->'} ${to})`,\n                    \"Оставьте поле пустым, чтобы добавить невзвешенное ребро\",\n                    \"Вес ребра\",\n                    (value) => {\n                        if (value === \"\")\n                            value = undefined;\n                        this.props.addEdge(vertexFrom, vertexTo, value);\n                    },\n                    null,\n                    \"[0-9]{0,2}\"\n                );\n            }\n        } else if (e.type === \"contextmenu\") {\n            e.preventDefault();\n\n            const edgeIndex = this.props.graph.findEdge(vertexFrom, vertexTo);\n            if (edgeIndex !== -1)\n                this.props.removeEdge(this.props.graph.edges[edgeIndex]);\n        }\n    };\n\n    render() {\n        return (\n            <Modal\n                isOpen={this.props.isOpen}\n                onRequestClose={() => this.cancel()}\n                ariaHideApp={false}\n                className={cx(\"matrix-dialog\")}\n                style={customStyles}>\n\n                {\n                    this.props.graph.vertices.length > 0 ?\n                        <div>\n                            <AdjacencyMatrix graph={this.props.graph} onCellClick={this.handleCellClick}/>\n                            <div>ЛКМ - добавить ребро, ПКМ - удалить ребро</div>\n                        </div>\n                    :\n                        <div style={{\"margin\": \"20px\", \"font-size\": \"1.2em\"}}>Добавьте хотя бы одну вершину</div>\n                }\n\n                <ButtonComponent\n                    type={\"submit\"}\n                    className={cx(\"button\", {[`deactivated-button`]: this.props.graph.vertices.length === 0})}\n                    text={\"Сохранить в файл\"}\n                    onClick={() => this.writeToFile()}/>\n                <a id=\"fileSave\" style={{\"display\": \"none\"}} aria-hidden={true} href=\"/#\">Save matrix</a>\n\n                <ButtonComponent\n                    className={cx(\"button\")}\n                    text={\"Закрыть\"}\n                    onClick={() => this.cancel()}/>\n            </Modal>\n        );\n    }\n}\n\nconst mapDispatchToProps = dispatch => ({\n    submitDialog: (onSubmit, result) => dispatch(submitMatrixDialog(onSubmit, result)),\n    cancelDialog: (onCancel) => dispatch(cancelMatrixDialog(onCancel)),\n    addEdge: (vertexFrom, vertexTo, weight) => dispatch(addEdge(vertexFrom, vertexTo, weight)),\n    removeEdge: (edge) => dispatch(removeEdge(edge)),\n    startDialogForResult: (title, text, hint, inputPlaceholder, onSubmit, onClose, pattern) =>\n        dispatch(startDialogForResult(title, text, hint, inputPlaceholder, onSubmit, onClose, pattern))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MatrixDialog);","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./HintBox.module.scss\";\nimport Draggable from 'react-draggable';\n\nconst cx = classnames.bind(styles);\n\nclass HintBox extends React.Component {\n    state = {\n        hidden: false\n    };\n\n    collapse = () => {\n        this.setState({ hidden: !this.state.hidden });\n        // FIXME: Fix unfolding in the bottom of the screen\n    };\n\n    render() {\n        return (\n            <Draggable grid={[4, 4]} bounds={\"body\"}>\n                <div className={cx(\"hint-box\", {[`hint-box-hidden`]: this.state.hidden})}>\n                    <div\n                        className={cx(\"close-button\")}\n                        onClick={() => this.collapse()}>\n                        &#x2715;\n                    </div>\n                    <div className={cx(\"text\")}>\n                        <p>\n                            Горячие клавиши:\n                        </p>\n                        <ul>\n                            <li>Ctrl + G - сгенерировать случайные рёбра</li>\n                            <li>Ctrl + Alt + C - удалить всё</li>\n                            <li>I - свернуть/развернуть информацию об алгоритме</li>\n                            <li>1, 2, 3, 4 - переключение режимов редактирования</li>\n                        </ul>\n                        <p className={cx(\"hint\")}>\n                            (Некоторые горячие клавиши могут работать только в английской раскладке)\n                        </p>\n                    </div>\n                </div>\n            </Draggable>\n        );\n    }\n}\n\nexport default HintBox;","import React from \"react\";\nimport classnames from \"classnames/bind\";\nimport styles from \"./AlgorithmInfoBox.module.scss\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\n\nconst cx = classnames.bind(styles);\n\nconst mapStateToProps = state => ({\n    lines: state.algorithmReducer.algorithmInfo,\n    isVisible: state.algorithmReducer.isAlgorithmInfoShown,\n    isCollapsed: state.algorithmReducer.isAlgorithmInfoCollapsed\n});\n\nconst AlgorithmInfoBox = ({ lines, isVisible, isCollapsed }) => {\n    return (\n        <div className={cx(\"algorithm-info-box\", {[`invisible`]: isCollapsed || !(isVisible && Array.isArray(lines) && lines.length)})}>\n            {Array.isArray(lines) ?\n                lines.map((line, index) => <div className={cx(\"text\")} key={index}>{line}</div>)\n                :\n                \"\"\n            }\n\n        </div>\n    );\n};\n\nAlgorithmInfoBox.propTypes = {\n    lines: PropTypes.arrayOf(PropTypes.node),\n    isVisible: PropTypes.bool\n};\n\nexport default connect(mapStateToProps)(AlgorithmInfoBox);","import React from 'react';\nimport classnames from \"classnames/bind\";\nimport styles from \"./App.module.scss\";\nimport GraphComponent, { GraphMode } from \"./Graph/Graph\";\nimport MenuComponent from \"./Menu/Menu\";\nimport MessageBox from \"./MessageBox/MessageBox\";\nimport InputDialog from \"./Dialogs/InputDialog/InputDialog\";\nimport InfoBox from \"./InfoBox/InfoBox\";\nimport MatrixDialog from \"./Dialogs/MatrixDialog/MatrixDialog\";\nimport { GlobalHotKeys } from \"react-hotkeys\";\nimport { connect } from \"react-redux\";\nimport {\n    changeGraphMode,\n    cleanGraphSelections,\n    clearGraph,\n    closeMessage,\n    generateGraph,\n    showMessage\n} from \"../actions\";\nimport HintBox from \"./HintBox/HintBox\";\nimport {\n    clearAlgorithmInfo,\n    clearStatistics,\n    clearTrace,\n    invertAlgorithmInfoCollapsed,\n    pause\n} from \"../actions/algorithm\";\nimport AlgorithmInfoBox from \"./AlgorithmInfoBox/AlgorithmInfoBox\";\n\nconst cx = classnames.bind(styles);\n\nconst App = ({\n    stopVisualization,\n    generateGraph,\n    clearGraph,\n    invertAlgorithmInfoCollapsed,\n    showMessage,\n    closeMessage,\n    changeGraphMode\n}) => {\n    const keyMap = {\n        GENERATE: [\"ctrl+g\", \"ctrl+п\"],\n        CLEAR: [\"ctrl+alt+c\", \"ctrl+alt+с\"],\n        COLLAPSE_ALGORITHM_INFO: [\"i\", \"ш\"],\n        CHANGE_GRAPH_MODE: [\"1\", \"2\", \"3\", \"4\"]\n    };\n\n    const handlers = {\n        GENERATE: (e) => {\n            e.preventDefault();\n            stopVisualization();\n            generateGraph();\n        },\n        CLEAR: (e) => {\n            e.preventDefault();\n            stopVisualization();\n            clearGraph();\n        },\n        COLLAPSE_ALGORITHM_INFO: (e) => {\n            e.preventDefault();\n            invertAlgorithmInfoCollapsed();\n        },\n        CHANGE_GRAPH_MODE: (e) => {\n            e.preventDefault();\n            switch (e.key) {\n                case \"1\":\n                    closeMessage();\n                    changeGraphMode(GraphMode.DEFAULT);\n                    break;\n                case \"2\":\n                    stopVisualization();\n                    showMessage(\"Выберите точку для добавления вершины\");\n                    changeGraphMode(GraphMode.ADD_VERTEX);\n                    break;\n                case \"3\":\n                    stopVisualization();\n                    showMessage(\"Выберите вершины, которые нужно соединить ребром\");\n                    changeGraphMode(GraphMode.ADD_EDGE);\n                    break;\n                case \"4\":\n                    stopVisualization();\n                    showMessage(\"Выберите объект для удаления\");\n                    changeGraphMode(GraphMode.REMOVE_VERTEX_OR_EDGE);\n                    break;\n                default:\n            }\n        }\n    };\n\n    return (\n        <div className={cx(\"app\")}>\n            <GlobalHotKeys keyMap={keyMap} handlers={handlers}/>\n            <MenuComponent/>\n            <GraphComponent/>\n            <MessageBox/>\n            <InfoBox/>\n            <HintBox/>\n            <AlgorithmInfoBox/>\n            <InputDialog/>\n            <MatrixDialog/>\n        </div>\n    );\n};\n\n\nconst mapDispatchToProps = dispatch => ({\n    generateGraph: () => dispatch(generateGraph()),\n    clearGraph: () => dispatch(clearGraph()),\n    stopVisualization: () => {\n        dispatch(pause());\n        dispatch(cleanGraphSelections());\n        dispatch(clearTrace());\n        dispatch(clearStatistics());\n        dispatch(clearAlgorithmInfo());\n    },\n    invertAlgorithmInfoCollapsed: () => dispatch(invertAlgorithmInfoCollapsed()),\n    changeGraphMode: (graphMode) => dispatch(changeGraphMode(graphMode)),\n    showMessage: (message) => dispatch(showMessage(message)),\n    closeMessage: () => dispatch(closeMessage())\n});\n\nexport default connect(null, mapDispatchToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ActionType } from \"../actions/dialog\";\nimport React from \"react\";\n\nconst defaultState = {\n    isOpen: false,\n    title: \"\",\n    text: \"\",\n    hint: \"\",\n    inputPlaceholder: \"\",\n    onSubmit: null,\n    onClose: null,\n    pattern: \".*\"\n};\n\nconst dialog = (state = defaultState, action) => {\n    let newState;\n    switch (action.type) {\n        case ActionType.START_DIALOG_FOR_RESULT:\n            newState = {\n                ...state,\n                isOpen: true,\n                title: action.title,\n                text: action.text,\n                hint: action.hint,\n                inputPlaceholder: action.inputPlaceholder,\n                pattern: action.pattern\n            };\n\n            newState.onSubmit = (value) => {\n                const onSubmit = action.onSubmit;\n                if (onSubmit)\n                    onSubmit(value);\n            };\n            newState.onCancel = () => {\n                const onCancel = action.onCancel;\n                if (onCancel)\n                    onCancel();\n            };\n\n            return newState;\n        case ActionType.CLOSE_DIALOG:\n            return defaultState;\n        default:\n            return state;\n    }\n};\n\nexport default dialog;","import { ActionType } from \"../actions/algorithm\";\nimport React from \"react\";\nimport { PreCallAction } from \"../algorithms/graph/index\";\n\nconst defaultState = {\n    trace: [],\n    isActive: false,\n    algorithm: null,\n    speed: 1000,\n    isOneStep: false,\n    statistics: [],\n    isStatisticsShown: false,\n    algorithmInfo: [],\n    isAlgorithmInfoShown: false,\n    isAlgorithmInfoCollapsed: false\n};\n\nconst algorithm = (state = defaultState, action) => {\n    let newState;\n    switch (action.type) {\n        case ActionType.CALL:\n            newState = {\n                ...state\n            };\n\n            const preCall = state.algorithm.preCall;\n            const vertices = action.graph.vertices;\n            const edges = action.graph.edges;\n            let result;\n            if (preCall === PreCallAction.SELECT_VERTEX) {\n                result = state.algorithm.call(vertices, edges, action.vertex);\n            } else if (preCall === PreCallAction.SELECT_EDGE) {\n                result = state.algorithm.call(vertices, edges, action.edge);\n            } else if (preCall === PreCallAction.NOTHING) {\n                result = state.algorithm.call(vertices, edges);\n            }\n            newState.trace = result.trace;\n            newState.statistics = result.statistics;\n            newState.algorithmInfo = result.algorithmInfo;\n\n            return newState;\n        case ActionType.POP_TRACE_STEP:\n            newState = {\n                ...state,\n                trace: [...state.trace]\n            };\n\n            newState.trace.shift();\n\n            return newState;\n        case ActionType.START:\n            return {\n                ...state,\n                isActive: true\n            };\n        case ActionType.PAUSE:\n            return {\n                ...state,\n                isActive: false\n            };\n        case ActionType.SET_ALGORITHM:\n            return {\n                ...state,\n                algorithm: action.algorithm\n            };\n        case ActionType.SET_SPEED:\n            return {\n                ...state,\n                speed: action.speed\n            };\n        case ActionType.SET_IS_ONE_STEP:\n            return {\n                ...state,\n                isOneStep: action.isOneStep\n            };\n        case ActionType.CLEAR_TRACE:\n            return {\n                ...state,\n                trace: []\n            };\n        case ActionType.SHOW_STATISTICS:\n            return {\n                ...state,\n                isStatisticsShown: true\n            };\n        case ActionType.CLEAR_STATISTICS:\n            return {\n                ...state,\n                statistics: [],\n                isStatisticsShown: false\n            };\n        case ActionType.SHOW_ALGORITHM_INFO:\n            return {\n                ...state,\n                isAlgorithmInfoShown: true\n            };\n        case ActionType.CLEAR_ALGORITHM_INFO:\n            return {\n                ...state,\n                algorithmInfo: [],\n                isAlgorithmInfoShown: false\n            };\n        case ActionType.INVERT_ALGORITHM_INFO_COLLAPSED:\n            return {\n                ...state,\n                isAlgorithmInfoCollapsed: !state.isAlgorithmInfoCollapsed\n            };\n        default:\n            return state;\n    }\n};\n\nexport default algorithm;","import { ActionType } from \"../actions/matrixDialog\";\nimport React from \"react\";\n\nconst defaultState = {\n    isOpen: false\n};\n\nconst matrixDialog = (state = defaultState, action) => {\n    switch (action.type) {\n        case ActionType.START_MATRIX_DIALOG_FOR_RESULT:\n            return {\n                ...state,\n                isOpen: true\n            };\n        case ActionType.CLOSE_MATRIX_DIALOG:\n            return defaultState;\n        default:\n            return state;\n    }\n};\n\nexport default matrixDialog;","import { Graph, GraphMode } from \"../components/Graph/Graph\";\nimport { ActionType } from \"../actions\";\nimport { VertexHintState, VertexState } from \"../components/Graph/Vertex/Vertex\";\nimport { combineReducers } from \"redux\";\nimport dialog from \"./dialog\";\nimport algorithm from \"./algorithm\";\nimport matrixDialog from \"./matrixDialog\";\nimport { AlgorithmActionType, EdgeAction, VertexAction, VertexHintAction } from \"../algorithms/graph\";\nimport { EdgeState } from \"../components/Graph/Edge/Edge\";\n\nconst defaultState = {\n    graph: new Graph(false),\n    message: undefined,\n    isAlert: false,\n    graphMode: GraphMode.DEFAULT,\n    selectedVertex: undefined, // For 'ADD_EDGE' // TODO: Do 'ADD_EDGE' in a cleaner way\n    canvasX: 0,\n    canvasY: 0\n};\n\nconst clone = object => {\n    return Object.assign( Object.create( Object.getPrototypeOf(object)), object);\n};\n\nconst unselectSelectedVertex = (state) => {\n    if (state.selectedVertex !== undefined) {\n        const i = state.graph.vertices.findIndex(v => v === state.selectedVertex);\n        if (i !== -1)\n            state.graph.vertices[i].state = VertexState.DEFAULT;\n        state.selectedVertex = undefined;\n    }\n};\n\nconst updateVertexByAction = (vertex, action) => {\n    switch (action) {\n        case VertexAction.SELECT:\n            vertex.state = VertexState.HIGHLIGHTED;\n            break;\n        case VertexAction.ENTER:\n            vertex.state = VertexState.PRE_COMPLETED;\n            break;\n        case VertexAction.EXIT:\n            vertex.state = VertexState.COMPLETED;\n            break;\n        case VertexAction.UNSELECT:\n            vertex.state = VertexState.DEFAULT;\n            break;\n        case VertexAction.COLOR_1:\n            vertex.state = VertexState.COLOR_1;\n            break;\n        case VertexAction.COLOR_2:\n            vertex.state = VertexState.COLOR_2;\n            break;\n        default:\n    }\n};\n\nconst updateEdgeByAction = (edge, action) => {\n    switch (action) {\n        case EdgeAction.WALK:\n            edge.state = EdgeState.WALKED;\n            break;\n        case EdgeAction.HIGHLIGHT:\n            edge.state = EdgeState.HIGHLIGHTED;\n            break;\n        case EdgeAction.SHADOW:\n            edge.state = EdgeState.SHADOWED;\n            break;\n        default:\n    }\n};\n\nconst updateVertexHintByAction = (vertex, action) => {\n    switch (action) {\n        case VertexHintAction.REMOVE:\n            vertex.hintState = VertexHintState.CLEAR;\n            break;\n        case VertexHintAction.SET:\n            vertex.hintState = VertexHintState.DEFAULT;\n            break;\n        case VertexHintAction.HIGHLIGHT:\n            vertex.hintState = VertexHintState.HIGHLIGHTED;\n            break;\n        default:\n    }\n};\n\nconst cleanGraphSelections = (state) => {\n    state.graph.vertices.forEach(v => {\n        v.state = VertexState.DEFAULT;\n        v.hintState = VertexHintState.CLEAR;\n        v.hint = \"\";\n    });\n    state.graph.edges.forEach(e => e.state = EdgeState.DEFAULT);\n    state.graph.visualizationEdges = [];\n    state.selectedVertex = undefined;\n};\n\nconst reducer = (state = defaultState, action) => {\n    let newState;\n    let i;\n    switch (action.type) {\n        case ActionType.ADD_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.addVertex(action.x, action.y, action.radius);\n\n            return newState;\n        case ActionType.ADD_EDGE:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.addEdge(action.vertexFrom, action.vertexTo, action.weight);\n\n            return newState;\n        case ActionType.REMOVE_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.removeVertex(action.vertex);\n\n            return newState;\n        case ActionType.REMOVE_EDGE:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.removeEdge(action.edge);\n\n            return newState;\n        case ActionType.UPDATE_VERTEX_POSITION:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.vertices[action.vertexIndex].x = action.x;\n            newState.graph.vertices[action.vertexIndex].y = action.y;\n\n            return newState;\n        case ActionType.CHANGE_GRAPH_MODE:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            if (action.graphMode !== newState.graphMode) {\n                newState.graphMode = action.graphMode;\n\n                unselectSelectedVertex(newState);\n            }\n\n            return newState;\n        case ActionType.SELECT_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            unselectSelectedVertex(newState);\n\n            i = newState.graph.vertices.findIndex(v => v === action.vertex);\n            if (i !== -1) {\n                newState.graph.vertices[i].state = VertexState.HIGHLIGHTED;\n                newState.selectedVertex = action.vertex;\n            }\n\n            return newState;\n        case ActionType.UNSELECT_VERTEX:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            unselectSelectedVertex(newState);\n\n            return newState;\n        case ActionType.SHOW_MESSAGE:\n            return {\n                ...state,\n                message: action.message,\n                isAlert: action.isAlert\n            };\n        case ActionType.CLOSE_MESSAGE:\n            return {\n                ...state,\n                message: undefined,\n                isAlert: false\n            };\n        case ActionType.INVERT_ORIENTATION:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.invertOrientation();\n\n            return newState;\n        case ActionType.ALGORITHM_STEP:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            const step = action.step;\n            if (step.actionType === AlgorithmActionType.VERTEX_ACTION) {\n                if (step.action === VertexAction.CLEAR_ALL_SELECTIONS) {\n                    newState.graph.vertices.forEach(v => v.state = VertexState.DEFAULT);\n                } else {\n                    const vertex = newState.graph.vertices.find(v => v.name === step.vertex);\n                    if (vertex)\n                        updateVertexByAction(vertex, step.action);\n                }\n            } else if (step.actionType === AlgorithmActionType.EDGE_ACTION) {\n                if (step.action === EdgeAction.CLEAR_ALL_SELECTIONS) {\n                    newState.graph.visualizationEdges = [];\n                } else if (step.action === EdgeAction.FLIP) {\n                    const vertexFrom = newState.graph.vertices.find(v => v.name === step.from);\n                    const vertexTo = newState.graph.vertices.find(v => v.name === step.to);\n                    const edge = newState.graph.findEdge(vertexFrom, vertexTo);\n                    if (edge !== -1) {\n                        if (newState.graph.edges[edge].state === EdgeState.FLIPPED)\n                            newState.graph.edges[edge].state = EdgeState.DEFAULT;\n                        else\n                            newState.graph.edges[edge].state = EdgeState.FLIPPED;\n                    }\n                } else {\n                    const vertexFrom = newState.graph.vertices.find(v => v.name === step.from);\n                    const vertexTo = newState.graph.vertices.find(v => v.name === step.to);\n                    if (step.action === EdgeAction.UNSELECT) {\n                        newState.graph.removeVisualizationEdgeByVertices(vertexFrom, vertexTo, step.oriented);\n                    } else {\n                        const edge = newState.graph.addVisualizationEdge(vertexFrom, vertexTo, step.oriented, step.weight);\n                        updateEdgeByAction(edge, step.action);\n                    }\n                }\n            } else if (step.actionType === AlgorithmActionType.VERTEX_HINT_ACTION) {\n                const vertex = newState.graph.vertices.find(v => v.name === step.vertex);\n                if (vertex) {\n                    if (step.action === VertexHintAction.REMOVE)\n                        vertex.hint = \"\";\n                    else\n                        vertex.hint = step.hint;\n                    updateVertexHintByAction(vertex, step.action);\n                }\n            }\n\n            return newState;\n        case ActionType.CLEAN_GRAPH_SELECTIONS:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            cleanGraphSelections(newState);\n\n            return newState;\n        case ActionType.SET_GRAPH:\n            return {\n                ...state,\n                graph: action.graph\n            };\n        case ActionType.MOVE_CANVAS:\n            return {\n                ...state,\n                canvasX: action.x,\n                canvasY: action.y\n            };\n        case ActionType.GENERATE_GRAPH:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.removeAllEdges();\n            newState.graph.vertices.forEach(vertexFrom => {\n                let edgesNumber = 1 + Math.max(0, Math.floor(Math.random() * Math.floor(Math.log2(newState.graph.vertices.length) - 2)));\n\n                while (edgesNumber--) {\n                    const vertexTo = newState.graph.vertices[Math.floor(Math.random() * Math.floor(newState.graph.vertices.length))];\n                    const weight = Math.floor(Math.random() * Math.floor(100));\n\n                    newState.graph.addEdge(vertexFrom, vertexTo, weight);\n                }\n            });\n\n            return newState;\n        case ActionType.CLEAR_GRAPH:\n            newState = {\n                ...state,\n                graph: clone(state.graph)\n            };\n\n            newState.graph.clearGraph();\n\n            return newState;\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    graphReducer: reducer,\n    dialogReducer: dialog,\n    algorithmReducer: algorithm,\n    matrixDialogReducer: matrixDialog\n});","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from \"react-redux\";\nimport { applyMiddleware, createStore } from \"redux\";\nimport rootReducer from \"./reducers/index\";\nimport thunk from \"redux-thunk\";\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__2at_H\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"menu\":\"Menu_menu__2xbQm\",\"menu-sub\":\"Menu_menu-sub__2jhA1\",\"graph-control-buttons\":\"Menu_graph-control-buttons__2CY62\",\"switch\":\"Menu_switch__3Y97k\",\"visualization-control-buttons\":\"Menu_visualization-control-buttons__1OTXW\",\"file-control-buttons\":\"Menu_file-control-buttons__3PmTU\",\"algorithms-list\":\"Menu_algorithms-list__2mwx1\",\"slider\":\"Menu_slider__RA1Ez\",\"matrix-control-buttons\":\"Menu_matrix-control-buttons__26fCf\",\"collapse-button\":\"Menu_collapse-button__Jv6Lk\",\"menu-hidden\":\"Menu_menu-hidden__2Ff-E\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Buttons_button__1L6GG\",\"hint\":\"Buttons_hint__2dL7_\",\"activated\":\"Buttons_activated__EZOmF\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"slider-wrapper\":\"Sliders_slider-wrapper__GIw-8\",\"slider-label\":\"Sliders_slider-label__1w08l\",\"slider\":\"Sliders_slider__1gqJy\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"drop-down-list\":\"DropDownLists_drop-down-list__ix94o\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"switch-round-wrapper\":\"ToggleSwitches_switch-round-wrapper__g2bxh\",\"switch-round\":\"ToggleSwitches_switch-round__1bQ1T\",\"slider\":\"ToggleSwitches_slider__Q-bUA\",\"text\":\"ToggleSwitches_text__1sKta\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"message-box\":\"MessageBox_message-box__2uEgD\",\"invisible\":\"MessageBox_invisible__10Wwp\",\"alert\":\"MessageBox_alert__14QTT\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"input-dialog\":\"InputDialog_input-dialog__2SLyF\",\"text-input\":\"InputDialog_text-input__2zjdU\",\"button\":\"InputDialog_button__1ZFHJ\",\"text\":\"InputDialog_text__2HUnn\",\"hint\":\"InputDialog_hint__1ftkv\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"text-input\":\"TextInputs_text-input__3mPdK\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"info-box\":\"InfoBox_info-box__3t_A2\",\"text\":\"InfoBox_text__sgPCj\",\"save-button\":\"InfoBox_save-button__2-on2\",\"invisible\":\"InfoBox_invisible__1un1A\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"matrix-dialog\":\"MatrixDialog_matrix-dialog__2YGd3\",\"button\":\"MatrixDialog_button__3KxWd\",\"deactivated-button\":\"MatrixDialog_deactivated-button__ONTjT\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"matrix\":\"AdjacencyMatrix_matrix__3b96v\",\"matrix-row\":\"AdjacencyMatrix_matrix-row__3vHpl\",\"top-left-cell\":\"AdjacencyMatrix_top-left-cell__1-lFt\",\"top-right-cell\":\"AdjacencyMatrix_top-right-cell__1RYRb\",\"bottom-left-cell\":\"AdjacencyMatrix_bottom-left-cell__23nQC\",\"bottom-right-cell\":\"AdjacencyMatrix_bottom-right-cell__2r29f\",\"matrix-cell\":\"AdjacencyMatrix_matrix-cell__2Z91s\",\"label-cell\":\"AdjacencyMatrix_label-cell__3YJYr\",\"empty\":\"AdjacencyMatrix_empty__3-1PZ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"hint-box\":\"HintBox_hint-box__3wNFO\",\"close-button\":\"HintBox_close-button__2Liam\",\"text\":\"HintBox_text__10ytA\",\"hint-box-hidden\":\"HintBox_hint-box-hidden__kYj-a\",\"hint\":\"HintBox_hint__3M49H\",\"invisible\":\"HintBox_invisible__13kxh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"algorithm-info-box\":\"AlgorithmInfoBox_algorithm-info-box__2f-JP\",\"text\":\"AlgorithmInfoBox_text__2JncT\",\"invisible\":\"AlgorithmInfoBox_invisible__3-C-v\"};"],"sourceRoot":""}